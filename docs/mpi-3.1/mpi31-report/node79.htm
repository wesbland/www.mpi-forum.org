<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Datatype Constructors</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node79">74. Datatype Constructors</span></h2>
<a href="node78.htm#Node78"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node77.htm#Node77"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node80.htm#Node80"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node77.htm#Node77"> Derived Datatypes</a>
<b>Next: </b><a href="node80.htm#Node80"> Subarray Datatype Constructor</a>
<b>Previous: </b><a href="node78.htm#Node78"> Type Constructors with Explicit Addresses</a>
<p>
  
<P> 
<P> 
Contiguous The simplest datatype constructor is  
<font face="sans-serif"> MPI_TYPE_CONTIGUOUS</font> which  
allows replication of a datatype into contiguous locations.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CONTIGUOUS(count, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>replication count (non-negative integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_contiguous(int count, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
<P> 
 <tt> MPI_Type_contiguous(count, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: count <br>TYPE(MPI_Datatype), INTENT(IN) :: oldtype <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_CONTIGUOUS(COUNT, OLDTYPE, NEWTYPE, IERROR)<br> INTEGER  COUNT, OLDTYPE, NEWTYPE, IERROR <br></tt>  
  
<P> 
<font face="sans-serif"> newtype</font> is the datatype obtained by concatenating  
<font face="sans-serif"> count</font> copies of  
<font face="sans-serif"> oldtype</font>.   Concatenation is defined using <em> extent</em> as the size of  
the concatenated copies.  
<P> 
<br><b> Example</b>  
  
Let <font face="sans-serif"> oldtype</font> have type map  
<img width=111 height=11 src="img18.gif" alt="Image file">
  
with extent 16,  
and let <img width=45 height=7 src="img19.gif" alt="Image file">
.  The type map of  
the datatype returned by <font face="sans-serif"> newtype</font> is  
<img width=343 height=11 src="img20.gif" alt="Image file">
  
i.e., alternating <tt> double</tt> and <tt> char</tt> elements, with displacements  
<i>0, 8, 16, 24, 32, 40</i>.  
  
<P> 
  
In general,  
assume that the type map of <font face="sans-serif"> oldtype</font> is  
<i> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</i>  
with extent <i>ex</i>.  
Then <font face="sans-serif"> newtype</font> has a type map with <img width=38 height=6 src="img21.gif" alt="Image file">
   
entries defined by:  
<img width=409 height=11 src="img22.gif" alt="Image file">
  
<img width=371 height=11 src="img23.gif" alt="Image file">
  
<P> 
<P> 
Vector The function  
<font face="sans-serif"> MPI_TYPE_VECTOR</font> is a more general constructor that  
allows replication of a datatype  
into locations that consist of equally spaced blocks.  Each block  
is obtained by concatenating the same number of copies of the old datatype.  
The spacing between blocks is a multiple of the extent of the old datatype.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_VECTOR(count, blocklength, stride, oldtype,  
newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks (non-negative integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>number of elements in each block  
(non-negative integer)</TD></TR>  
<TR><TD> IN stride</TD><TD>number of elements between start of each block (integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_vector(int count, int blocklength, int stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
<P> 
 <tt> MPI_Type_vector(count, blocklength, stride, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: count, blocklength, stride <br>TYPE(MPI_Datatype), INTENT(IN) :: oldtype <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_VECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR)<br> INTEGER  COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR <br></tt>  
  
<P> 
<br><b> Example</b>  
  
Assume, again, that <font face="sans-serif"> oldtype</font> has type map  
<img width=111 height=11 src="img24.gif" alt="Image file">
  
with extent 16.  
A call to <font face="sans-serif"> MPI_TYPE_VECTOR(2, 3, 4, oldtype, newtype)</font> will  
create the datatype with type map,  
<img width=337 height=11 src="img25.gif" alt="Image file">
  
<img width=354 height=11 src="img26.gif" alt="Image file">
  
That is, two blocks with three copies each of the old  
type, with a stride of 4 elements (<i>4 &#183; 16</i> bytes) between the the start of each block.  
  
<P> 
<br><b> Example</b>  
  
A call to <font face="sans-serif"> MPI_TYPE_VECTOR(3, 1, -2, oldtype, newtype)</font> will create  
the datatype,  
<img width=377 height=11 src="img27.gif" alt="Image file">
  
  
<P> 
In general, assume that <font face="sans-serif"> oldtype</font> has type map,  
<i> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</i>  
with extent <i>ex</i>.  Let <font face="sans-serif"> bl</font> be the <font face="sans-serif"> blocklength</font>.  
The newly created  datatype has a type map with  
<img width=54 height=8 src="img28.gif" alt="Image file">
<P> 
entries:  
<i> 
{ 
(type<SUB>0</SUB>, disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB>), 
</i>  
<i> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> + ex) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ex ), ..., 
</i>  
<img width=311 height=11 src="img29.gif" alt="Image file">
  
<img width=309 height=11 src="img30.gif" alt="Image file">
  
<img width=407 height=11 src="img31.gif" alt="Image file">
  
<img width=202 height=11 src="img32.gif" alt="Image file">
  
<img width=225 height=11 src="img33.gif" alt="Image file">
  
<img width=251 height=11 src="img34.gif" alt="Image file">
  
<img width=260 height=11 src="img35.gif" alt="Image file">
  
<P> 
A call to <font face="sans-serif"> MPI_TYPE_CONTIGUOUS(count, oldtype, newtype)</font> is  
equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_VECTOR(count, 1, 1, oldtype, newtype)</font>, or to a call to  
<font face="sans-serif"> MPI_TYPE_VECTOR(1, count, n, oldtype, newtype)</font>, <font face="sans-serif"> n</font> arbitrary.  
<P> 
<P> 
Hvector The function   
<font face="sans-serif"> MPI_TYPE_CREATE_HVECTOR</font>   
is identical to  
<font face="sans-serif"> MPI_TYPE_VECTOR</font>, except that <font face="sans-serif"> stride</font> is given in bytes,  
rather than in elements.  The use for both types of vector  
constructors is illustrated in Section <a href="node91.htm#Node91">Examples 
</a>.  
(<font face="sans-serif"> H</font> stands for ``heterogeneous'').  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HVECTOR(count, blocklength, stride,  
oldtype, newtype)</TD></TR> <TR><TD> IN count</TD><TD>number of blocks (non-negative  
integer)</TD></TR> <TR><TD> IN blocklength</TD><TD>number of elements in each block  
(non-negative integer)</TD></TR> <TR><TD> IN stride</TD><TD>number of bytes between start  
of each block (integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_hvector(int count, int blocklength, MPI_Aint stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
<P> 
 <tt> MPI_Type_create_hvector(count, blocklength, stride, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: count, blocklength <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: stride <br>TYPE(MPI_Datatype), INTENT(IN) :: oldtype <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_CREATE_HVECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR)<br> INTEGER COUNT, BLOCKLENGTH, OLDTYPE, NEWTYPE, IERROR<br>INTEGER(KIND=MPI_ADDRESS_KIND) STRIDE <br></tt>  
<P> 
  
<P> 
Assume that <font face="sans-serif"> oldtype</font> has type map,  
<i> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</i>  
with extent <i>ex</i>.  Let <font face="sans-serif"> bl</font> be the <font face="sans-serif"> blocklength</font>.  
The newly created  datatype has a type map with  
<img width=55 height=8 src="img36.gif" alt="Image file">
<P> 
entries:  
<i> 
{ 
(type<SUB>0</SUB>, disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB>), 
</i>  
<i> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> + ex) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ex ), ..., 
</i>  
<img width=311 height=11 src="img37.gif" alt="Image file">
  
<img width=271 height=11 src="img38.gif" alt="Image file">
  
<img width=190 height=11 src="img39.gif" alt="Image file">
  
<img width=213 height=11 src="img40.gif" alt="Image file">
  
<img width=392 height=11 src="img41.gif" alt="Image file">
  
<img width=251 height=11 src="img42.gif" alt="Image file">
  
<img width=260 height=11 src="img43.gif" alt="Image file">
  
<P> 
<P> 
Indexed The function  
<font face="sans-serif"> MPI_TYPE_INDEXED</font> allows  
replication of an old datatype into a sequence of blocks (each block is  
a concatenation of the old datatype), where  
each block can contain a different number of copies and have a different  
displacement.  All block displacements are multiples of the old type  
extent.  
<P> 
<P><img width=361 height=222 src="img44.gif" alt="Image file"><P>
 <tt> int MPI_Type_indexed(int count, const int array_of_blocklengths[], const int array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
<P> 
 <tt> MPI_Type_indexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: count, array_of_blocklengths(count),<br>    array_of_displacements(count) <br>TYPE(MPI_Datatype), INTENT(IN) :: oldtype <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_INDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<br> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_DISPLACEMENTS(*),<br>    OLDTYPE, NEWTYPE, IERROR <br></tt>  
  
<P> 
<br><b> Example</b>  
  
  
Let <font face="sans-serif"> oldtype</font> have type map  
<img width=111 height=11 src="img45.gif" alt="Image file">
  
with extent 16.  
Let  <font face="sans-serif"> B = (3, 1)</font> and let <font face="sans-serif"> D = (4, 0)</font>.  A call to  
<font face="sans-serif"> MPI_TYPE_INDEXED(2, B, D, oldtype, newtype)</font> returns a datatype with  
type map,  
<img width=354 height=11 src="img46.gif" alt="Image file">
  
<img width=106 height=11 src="img47.gif" alt="Image file">
  
That is, three copies of the old type starting at displacement  
64, and one copy starting at displacement 0.  
  
<P> 
In general,  
assume that <font face="sans-serif"> oldtype</font> has type map,  
<i> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</i>  
with extent <em> ex</em>.  
Let <font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklengths</font> argument and  
<font face="sans-serif"> D</font> be the  
<font face="sans-serif"> array_of_displacements</font> argument. The newly created datatype  
has <img width=78 height=14 src="img48.gif" alt="Image file">
 entries:  
<img width=304 height=11 src="img49.gif" alt="Image file">
  
<img width=418 height=11 src="img50.gif" alt="Image file">
  
<img width=357 height=11 src="img51.gif" alt="Image file">
  
<img width=254 height=11 src="img52.gif" alt="Image file">
  
<img width=263 height=11 src="img53.gif" alt="Image file">
  
<P> 
A call to <font face="sans-serif"> MPI_TYPE_VECTOR(count, blocklength, stride, oldtype,  
newtype)</font> is equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_INDEXED(count, B, D, oldtype, newtype)</font> where  
<img width=173 height=11 src="img54.gif" alt="Image file">
  
and  
<img width=187 height=11 src="img55.gif" alt="Image file">
  
<P> 
<P> 
Hindexed The function   
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font>   
is identical to  
<font face="sans-serif"> MPI_TYPE_INDEXED</font>, except that block displacements in  
<font face="sans-serif"> array_of_displacements</font> are specified in  
bytes, rather than in multiples of the <font face="sans-serif"> oldtype</font> extent.  
<P> 
<P><img width=409 height=209 src="img56.gif" alt="Image file"><P>
 <tt> int MPI_Type_create_hindexed(int count, const int array_of_blocklengths[], const MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
<P> 
 <tt> MPI_Type_create_hindexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: count, array_of_blocklengths(count) <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <br>    array_of_displacements(count) <br>TYPE(MPI_Datatype), INTENT(IN) :: oldtype <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_CREATE_HINDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<br> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), OLDTYPE, NEWTYPE, IERROR<br>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*) <br></tt>  
<P> 
  
<P> 
Assume that <font face="sans-serif"> oldtype</font> has type map,  
<i> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</i>  
with extent <i>ex</i>.  
Let <font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklengths</font> argument and  
<font face="sans-serif"> D</font> be the  
<font face="sans-serif"> array_of_displacements</font> argument. The newly created datatype  
has a type map with  
<img width=78 height=14 src="img57.gif" alt="Image file">
 entries:  
<img width=266 height=11 src="img58.gif" alt="Image file">
  
<img width=195 height=11 src="img59.gif" alt="Image file">
  
<img width=219 height=11 src="img60.gif" alt="Image file">
  
<img width=319 height=11 src="img61.gif" alt="Image file">
  
<img width=254 height=11 src="img62.gif" alt="Image file">
  
<img width=263 height=11 src="img63.gif" alt="Image file">
  
<P> 
<P> 
Indexed_block This function is the same as <font face="sans-serif"> MPI_TYPE_INDEXED</font> except that the  
blocklength is the same for all blocks.  
There are many codes using indirect addressing arising from  
unstructured grids where the blocksize is always 1 (gather/scatter).  The  
following convenience function allows for constant blocksize and arbitrary  
displacements.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_INDEXED_BLOCK(count, blocklength, array_of_displacements, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>length of array of displacements (non-negative   
        integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>size of block (non-negative   
        integer)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>array of displacements (array of integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_indexed_block(int count, int blocklength, const int array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
<P> 
 <tt> MPI_Type_create_indexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: count, blocklength,<br>    array_of_displacements(count) <br>TYPE(MPI_Datatype), INTENT(IN) :: oldtype <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_CREATE_INDEXED_BLOCK(COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <br> INTEGER COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS(*), OLDTYPE,<br>    NEWTYPE, IERROR <br></tt>  
<P> 
  
<P> 
<P> 
Hindexed_block The function <font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED_BLOCK</font> is identical  
to <font face="sans-serif"> MPI_TYPE_CREATE_INDEXED_BLOCK</font>, except that block  
displacements in <font face="sans-serif"> array_of_displacements</font> are specified in  
bytes, rather than in multiples of the <font face="sans-serif"> oldtype</font> extent.  
 <P> 
<P><img width=403 height=154 src="img64.gif" alt="Image file"><P>
 <tt> int MPI_Type_create_hindexed_block(int count, int blocklength, const MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
<P> 
 <tt> MPI_Type_create_hindexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: count, blocklength <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <br>    array_of_displacements(count) <br>TYPE(MPI_Datatype), INTENT(IN) :: oldtype <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_CREATE_HINDEXED_BLOCK(COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<br> INTEGER COUNT, BLOCKLENGTH, OLDTYPE, NEWTYPE, IERROR<br>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*) <br></tt>  
<P> 
<P> 
Struct <font face="sans-serif"> MPI_TYPE_CREATE_STRUCT</font> is the most general type constructor.  
It further generalizes  
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font>   
in that it allows each block to consist of replications of  
different datatypes.  
<P> 
<P><img width=397 height=222 src="img65.gif" alt="Image file"><P>
 <tt> int MPI_Type_create_struct(int count, const int array_of_blocklengths[], const MPI_Aint array_of_displacements[], const MPI_Datatype array_of_types[], MPI_Datatype *newtype) <br></tt>  
<P> 
 <tt> MPI_Type_create_struct(count, array_of_blocklengths, array_of_displacements, array_of_types, newtype, ierror) <br> INTEGER, INTENT(IN) :: count, array_of_blocklengths(count) <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <br>    array_of_displacements(count) <br>TYPE(MPI_Datatype), INTENT(IN) :: array_of_types(count) <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_CREATE_STRUCT(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, ARRAY_OF_TYPES, NEWTYPE, IERROR)<br> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_TYPES(*), NEWTYPE,<br>    IERROR<br>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*) <br></tt>  
<P> 
  
<P> 
<br><b> Example</b>  
  
Let <font face="sans-serif"> type1</font> have type map,  
<P><img width=112 height=11 src="img66.gif" alt="Image file"><P>
  
with extent 16.  
Let <font face="sans-serif"> B = (2, 1, 3)</font>, <font face="sans-serif"> D = (0, 16, 26)</font>,  
and <font face="sans-serif"> T = (MPI_FLOAT, type1, MPI_CHAR)</font>.  Then a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT(3, B, D, T, newtype)</font> returns  
a datatype with type map,  
<img width=383 height=11 src="img67.gif" alt="Image file">
  
That is, two copies of <font face="sans-serif"> MPI_FLOAT</font> starting at 0, followed by  
one copy of <font face="sans-serif"> type1</font> starting at 16, followed by three copies of  
<font face="sans-serif"> MPI_CHAR</font>, starting at 26.  
(We assume that a float occupies four bytes.)  
  
<P> 
In general,  
let <font face="sans-serif"> T</font> be the <font face="sans-serif"> array_of_types</font> argument, where <font face="sans-serif"> T[i]</font>  
is a handle to,  
<i> 
typemap<SUB>i</SUB> = { (type<SUB>0</SUB><SUP>i</SUP> , disp<SUB>0</SUB><SUP>i</SUP> ) , ... , (type<SUB>n<SUB>i</SUB>-1</SUB><SUP>i</SUP> , 
disp<SUB>n<SUB>i</SUB>-1</SUB><SUP>i</SUP> ) } , 
</i>  
with extent <i>ex<SUB>i</SUB></i>.  
Let  
<font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklength</font> argument and <font face="sans-serif"> D</font> be  
the <font face="sans-serif"> array_of_displacements</font> argument.Let <font face="sans-serif"> c</font> be the  
<font face="sans-serif"> count</font> argument.  
Then the newly created datatype has a type map with  
<img width=60 height=13 src="img68.gif" alt="Image file">
<P> 
entries:  
<img width=252 height=13 src="img69.gif" alt="Image file">
  
<img width=404 height=13 src="img70.gif" alt="Image file">
  
<img width=330 height=15 src="img71.gif" alt="Image file">
  
<img width=251 height=13 src="img72.gif" alt="Image file">
  
<img width=258 height=15 src="img73.gif" alt="Image file">
  
<P> 
A call to   
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED(count, B, D, oldtype, newtype)</font>  
is equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT(count, B, D, T, newtype)</font>,   
where each entry of <font face="sans-serif"> T</font> is equal to <font face="sans-serif"> oldtype</font>.  
<P> 

<P>
<hr>
<a href="node78.htm#Node78"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node77.htm#Node77"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node80.htm#Node80"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node77.htm#Node77"> Derived Datatypes</a>
<b>Next: </b><a href="node80.htm#Node80"> Subarray Datatype Constructor</a>
<b>Previous: </b><a href="node78.htm#Node78"> Type Constructors with Explicit Addresses</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
