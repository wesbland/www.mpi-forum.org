<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Fortran Derived Types</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node425">369. Fortran Derived Types</span></h2>
<a href="node424.htm#Node424"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node426.htm#Node426"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node426.htm#Node426"> Optimization Problems, an Overview</a>
<b>Previous: </b><a href="node424.htm#Node424"> Special Constants</a>
<p>
  
  
<P> 
<font face="sans-serif"> MPI</font> supports passing Fortran  
entities of <tt> BIND(C)</tt> and <tt> SEQUENCE</tt> derived  
types to choice dummy arguments, provided no type component  
has the <tt> ALLOCATABLE</tt> or <tt> POINTER</tt> attribute.  
<P> 
The following code fragment shows  
some possible ways to send scalars or arrays of interoperable   
derived type in Fortran. The example assumes that all data is passed by address.  
<br> 
<pre><tt>    type, BIND(C) :: mytype 
       integer :: i 
       real :: x 
       double precision :: d 
       logical :: l  
    end type mytype 
 
    type(mytype) :: foo, fooarr(5) 
    integer :: blocklen(4), type(4) 
    integer(KIND=MPI_ADDRESS_KIND) :: disp(4), base, lb, extent 
 
    call MPI_GET_ADDRESS(foo%i, disp(1), ierr) 
    call MPI_GET_ADDRESS(foo%x, disp(2), ierr) 
    call MPI_GET_ADDRESS(foo%d, disp(3), ierr) 
    call MPI_GET_ADDRESS(foo%l, disp(4), ierr) 
      
    base = disp(1) 
    disp(1) = disp(1) - base 
    disp(2) = disp(2) - base 
    disp(3) = disp(3) - base 
    disp(4) = disp(4) - base 
 
    blocklen(1) = 1 
    blocklen(2) = 1 
    blocklen(3) = 1 
    blocklen(4) = 1 
 
    type(1) = MPI_INTEGER 
    type(2) = MPI_REAL 
    type(3) = MPI_DOUBLE_PRECISION 
    type(4) = MPI_LOGICAL 
 
    call MPI_TYPE_CREATE_STRUCT(4, blocklen, disp, type, newtype, ierr) 
    call MPI_TYPE_COMMIT(newtype, ierr) 
  
    call MPI_SEND(foo%i, 1, newtype, dest, tag, comm, ierr) 
    ! or 
    call MPI_SEND(foo, 1, newtype, dest, tag, comm, ierr) 
    ! expects that base == address(foo%i) == address(foo) 
 
    call MPI_GET_ADDRESS(fooarr(1), disp(1), ierr) 
    call MPI_GET_ADDRESS(fooarr(2), disp(2), ierr) 
    extent = disp(2) - disp(1) 
    lb = 0 
    call MPI_TYPE_CREATE_RESIZED(newtype, lb, extent, newarrtype, ierr) 
    call MPI_TYPE_COMMIT(newarrtype, ierr) 
 
    call MPI_SEND(fooarr, 5, newarrtype, dest, tag, comm, ierr) 
</tt></pre> 
  
Using the derived type variable <tt>foo</tt> instead of its   
first basic type element <tt>foo%i</tt> may be impossible   
if the <font face="sans-serif"> MPI</font> library implements choice buffer arguments   
through overloading instead of using   
<tt>TYPE(*), DIMENSION(..)</tt>, or through a   
non-standardized extension such as <tt> !$PRAGMA IGNORE_TKR</tt>;  
see   
Section <a href="node413.htm#Node413"><font face="sans-serif"> MPI</font> for Different Fortran Standard Versions 
</a>.  
<P> 
To use a derived type in an array requires a correct extent of the datatype handle  
to take care of the alignment rules applied by the compiler.  
These alignment rules may imply that there are gaps between  
the components of a derived type, and also between the subsuquent  
elements of an array of a derived type.  
The extent of an interoperable derived type (i.e., defined with <tt> BIND(C)</tt>)  
and a <tt> SEQUENCE</tt> derived type with the same content  
may be different because C and Fortran may apply different alignment rules.  
As recommended in the advice to users  
in Section <a href="node83.htm#Node83">Lower-Bound and Upper-Bound Markers 
</a>,  
one should add an additional fifth structure element with one numerical storage unit  
at the end of this structure to force in most cases that the array of structures is contiguous.  
Even with such an additional element, one should keep this resizing due to the  
special alignment rules that can be used by the compiler for structures,  
as also mentioned in this advice.  
<P> 
Using the extended semantics defined in TS 29113, it is also possible   
to use entities or derived types without either the <tt> BIND(C)</tt> or the   
<tt> SEQUENCE</tt> attribute as choice buffer arguments; some additional   
constraints must be observed, e.g., no <tt> ALLOCATABLE</tt> or   
<tt> POINTER</tt> type components may exist.   
In this case, the <tt> base</tt> address in the example must be changed   
to become the address of <tt> foo</tt> instead of <tt> foo%i</tt>, because the   
Fortran compiler may rearrange type components or add padding.  
Sending the structure <tt> foo</tt> should then also be performed by   
providing it (and not <tt> foo%i</tt>) as actual argument for <tt> MPI_Send</tt>.  
<P> 

<P>
<hr>
<a href="node424.htm#Node424"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node426.htm#Node426"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node426.htm#Node426"> Optimization Problems, an Overview</a>
<b>Previous: </b><a href="node424.htm#Node424"> Special Constants</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
