<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Use of General Datatypes in Communication</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node88">83. Use of General Datatypes in Communication</span></h2>
<a href="node87.htm#Node87"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node77.htm#Node77"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node89.htm#Node89"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node77.htm#Node77"> Derived Datatypes</a>
<b>Next: </b><a href="node89.htm#Node89"> Correct Use of Addresses</a>
<b>Previous: </b><a href="node87.htm#Node87"> Duplicating a Datatype</a>
<p>
  
<P> 
Handles to derived datatypes can be passed to a communication call wherever a  
datatype argument is required.  
A call of the form <font face="sans-serif"> MPI_SEND(buf, count, datatype, ...)</font>, where  
<img width=44 height=7 src="img82.gif" alt="Image file">
, is interpreted as if the call was passed a new datatype  
which is the  
concatenation of <font face="sans-serif"> count</font> copies of <font face="sans-serif"> datatype</font>.  
Thus,  
<font face="sans-serif"> MPI_SEND(buf, count, datatype, dest, tag, comm)</font> is equivalent to,  
<br> 
<pre><tt>MPI_TYPE_CONTIGUOUS(count, datatype, newtype) 
MPI_TYPE_COMMIT(newtype) 
MPI_SEND(buf, 1, newtype, dest, tag, comm) 
MPI_TYPE_FREE(newtype). 
</tt></pre> 
Similar statements apply to all other communication functions that have a  
<font face="sans-serif"> count</font> and <font face="sans-serif"> datatype</font> argument.  
<P> 
Suppose that a send operation <font face="sans-serif"> MPI_SEND(buf, count,  
datatype, dest, tag, comm)</font> is executed, where  
<font face="sans-serif"> datatype</font> has type map,  
<p><i> 
{(type<SUB>0</SUB>, disp<SUB>0</SUB>),...,(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>)}, 
</i><p>  
and extent <i>extent</i>.  (Explicit lower bound and upper bound markers are not listed in the type map, but  
they affect the value of <i>extent</i>.)  
The send  
operation sends <img width=40 height=6 src="img83.gif" alt="Image file">
 entries, where entry <i>i 
&#183; n + j</i> is at location  
<img width=153 height=11 src="img84.gif" alt="Image file">
<P> 
and has type <i>type<SUB>j</SUB></i>,  
for <img width=91 height=9 src="img85.gif" alt="Image file">
 and <i>j = 0 ,..., n-1</i>.  
These entries need not be contiguous, nor distinct; their order can be  
arbitrary.  
<P> 
The variable stored at address <i>addr<SUB>i,j</SUB></i> in the calling program  
should be of a type that matches <i>type<SUB>j</SUB></i>, where  
type matching is defined as in Section <a href="node54.htm#Node54">Type Matching Rules 
</a>.  
The message sent contains <img width=40 height=6 src="img86.gif" alt="Image file">
 entries, where entry  
<i>i &#183; n +j</i> has type <i>type<SUB>j</SUB></i>.  
<P> 
Similarly, suppose that a receive operation  
<font face="sans-serif"> MPI_RECV(buf, count, datatype, source, tag, comm, status)</font> is  
executed, where <font face="sans-serif"> datatype</font> has type map,  
<i> 
{(type<SUB>0</SUB>, disp<SUB>0</SUB>) ,...,(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) }, 
</i>  
  
with extent <i>extent</i>.  (Again,  explicit lower bound and upper bound markers are not listed in the type map, but  
they affect the value of <i>extent</i>.)  
This receive operation receives  
<img width=40 height=6 src="img87.gif" alt="Image file">
 entries, where entry <i>i &#183; n + j</i> is at location  
<img width=106 height=11 src="img88.gif" alt="Image file">
<P> 
and has type <i>type<SUB>j</SUB></i>.  If the incoming message consists of <i>k</i>  
elements, then we must have <img width=59 height=8 src="img89.gif" alt="Image file">
; the <i>i &#183; n + 
j</i>-th element of the message should have a type that matches <i>type<SUB>j</SUB></i>.  
<P> 
<b> Type matching</b>  
is defined according to the type signature of  
the corresponding datatypes, that is, the sequence of basic type  
components.  Type matching does not depend on some aspects of the  
datatype definition, such as the displacements (layout in memory) or the  
intermediate types used.  
<P> 
<br><b> Example</b>  
  
  
This example shows that type matching is defined in terms of  
the basic types that a derived type consists of.  
<br> 
<pre><tt>... 
CALL MPI_TYPE_CONTIGUOUS(2, MPI_REAL, type2, ...) 
CALL MPI_TYPE_CONTIGUOUS(4, MPI_REAL, type4, ...) 
CALL MPI_TYPE_CONTIGUOUS(2, type2, type22, ...) 
... 
CALL MPI_SEND(a, 4, MPI_REAL, ...) 
CALL MPI_SEND(a, 2, type2, ...) 
CALL MPI_SEND(a, 1, type22, ...) 
CALL MPI_SEND(a, 1, type4, ...) 
... 
CALL MPI_RECV(a, 4, MPI_REAL, ...) 
CALL MPI_RECV(a, 2, type2, ...) 
CALL MPI_RECV(a, 1, type22, ...) 
CALL MPI_RECV(a, 1, type4, ...) 
</tt></pre> 
Each of the sends matches any of the receives.  
  
<P> 
A datatype may specify overlapping entries. The use of such a  
datatype in a receive operation is erroneous. (This is erroneous even  
if the actual message received is short enough not to write any entry  
more than once.)  
<P> 
Suppose that  
<font face="sans-serif"> MPI_RECV(buf, count, datatype, dest, tag, comm, status)</font> is  
executed, where <font face="sans-serif"> datatype</font> has type map,  
<i> 
{(type<SUB>0</SUB>, disp<SUB>0</SUB>) ,...,(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) }. 
</i>  
The received message need not fill all the receive buffer, nor does it  
need to fill a number of locations which is a multiple of <i>n</i>.  
Any number, <i>k</i>, of basic  
elements can be received, where <img width=80 height=8 src="img90.gif" alt="Image file">
.  
The number of basic elements received can be retrieved from  
<font face="sans-serif"> status</font> using the query functions <font face="sans-serif"> MPI_GET_ELEMENTS</font> or <font face="sans-serif"> MPI_GET_ELEMENTS_X</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GET_ELEMENTS(status, datatype, count)</TD></TR>  
<TR><TD> IN status</TD><TD>return status of receive operation (Status)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype used by receive operation (handle)</TD></TR>  
<TR><TD> OUT count</TD><TD>number of received basic elements (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Get_elements(const MPI_Status *status, MPI_Datatype datatype, int *count) <br></tt>  
<P> 
 <tt> MPI_Get_elements(status, datatype, count, ierror) <br> TYPE(MPI_Status), INTENT(IN) :: status <br>TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>INTEGER, INTENT(OUT) :: count <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GET_ELEMENTS(STATUS, DATATYPE, COUNT, IERROR)<br> INTEGER  STATUS(MPI_STATUS_SIZE), DATATYPE, COUNT, IERROR <br></tt>  
  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_GET_ELEMENTS_X(status, datatype, count)</TD></TR>  
<TR><TD> IN status</TD><TD>return status of receive operation (Status)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype used by receive operation (handle)</TD></TR>  
<TR><TD> OUT count</TD><TD>number of received basic elements (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Get_elements_x(const MPI_Status *status, MPI_Datatype datatype, MPI_Count *count) <br></tt>  
<P> 
 <tt> MPI_Get_elements_x(status, datatype, count, ierror) <br> TYPE(MPI_Status), INTENT(IN) :: status <br>TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: count <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GET_ELEMENTS_X(STATUS, DATATYPE, COUNT, IERROR)<br> INTEGER  STATUS(MPI_STATUS_SIZE), DATATYPE, IERROR<br>INTEGER(KIND=MPI_COUNT_KIND) COUNT <br></tt>  
<P> 
The <font face="sans-serif"> datatype</font> argument should match the argument provided by the  
receive call that set the <font face="sans-serif"> status</font> variable.  
For both functions, if the  OUT parameter cannot express the value to  
be returned (e.g., if the parameter is too small to hold the output  
value), it is set to <font face="sans-serif">  MPI_UNDEFINED</font>.  
<P> 
The previously defined function  
<font face="sans-serif"> MPI_GET_COUNT</font>  
(Section <a href="node51.htm#Node51">Return Status 
</a>),   
has a different behavior.  
It returns the number of ``top-level  
entries'' received, i.e. the number of ``copies'' of type  
<font face="sans-serif"> datatype</font>.  
In the previous example, <font face="sans-serif"> MPI_GET_COUNT</font>  
may return any integer value <i>k</i>, where <img width=66 height=8 src="img91.gif" alt="Image file">
.  
If <font face="sans-serif"> MPI_GET_COUNT</font> returns <i>k</i>, then the number of basic  
elements received (and the value returned by   
<font face="sans-serif"> MPI_GET_ELEMENTS</font> or <font face="sans-serif"> MPI_GET_ELEMENTS_X</font>)  
is <i>n &#183; k</i>.   If the number of basic elements received is not a  
multiple of <i>n</i>, that is, if the receive operation has not received an  
integral number of <font face="sans-serif"> datatype</font> ``copies,'' then  
<font face="sans-serif"> MPI_GET_COUNT</font> sets the value of <font face="sans-serif"> count</font> to <font face="sans-serif">  MPI_UNDEFINED</font>.  
<P> 
<br><b> Example</b>  
  
Usage of <font face="sans-serif"> MPI_GET_COUNT</font> and   
<font face="sans-serif"> MPI_GET_ELEMENTS</font>.  
<br> 
<pre><tt>... 
CALL MPI_TYPE_CONTIGUOUS(2, MPI_REAL, Type2, ierr) 
CALL MPI_TYPE_COMMIT(Type2, ierr) 
... 
CALL MPI_COMM_RANK(comm, rank, ierr) 
IF (rank.EQ.0) THEN 
      CALL MPI_SEND(a, 2, MPI_REAL, 1, 0, comm, ierr) 
      CALL MPI_SEND(a, 3, MPI_REAL, 1, 0, comm, ierr) 
ELSE IF (rank.EQ.1) THEN 
      CALL MPI_RECV(a, 2, Type2, 0, 0, comm, stat, ierr) 
      CALL MPI_GET_COUNT(stat, Type2, i, ierr)     ! returns i=1 
      CALL MPI_GET_ELEMENTS(stat, Type2, i, ierr)  ! returns i=2 
      CALL MPI_RECV(a, 2, Type2, 0, 0, comm, stat, ierr) 
      CALL MPI_GET_COUNT(stat, Type2, i, ierr)     ! returns i=MPI_UNDEFINED 
      CALL MPI_GET_ELEMENTS(stat, Type2, i, ierr)  ! returns i=3 
END IF 
</tt></pre> 
  
<P> 
The functions <font face="sans-serif"> MPI_GET_ELEMENTS</font> and <font face="sans-serif"> MPI_GET_ELEMENTS_X</font> can also be used after a probe  
to find the number of elements in the probed message.  
Note that the   
<font face="sans-serif"> MPI_GET_COUNT</font>,   
<font face="sans-serif"> MPI_GET_ELEMENTS</font>, and <font face="sans-serif"> MPI_GET_ELEMENTS_X</font>  
return the same values when they are used  
with basic datatypes as long as the limits of their respective <font face="sans-serif"> count</font> arguments are not exceeded.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The extension given to the definition of <font face="sans-serif"> MPI_GET_COUNT</font> seems  
natural: one would expect this function to return the value of the  
<font face="sans-serif"> count</font> argument, when the receive buffer is filled.  
Sometimes <font face="sans-serif"> datatype</font> represents  
a basic unit of data one wants to transfer,  
for example, a record in an array of records (structures).  
One should be able to find out how many components were received  
without bothering to divide by the number of elements in each  
component.   However, on other occasions, <font face="sans-serif"> datatype</font> is used to  
define a complex layout of data in the receiver memory, and does not represent  
a basic unit of data for transfers.  In such cases, one needs to use  
the function <font face="sans-serif"> MPI_GET_ELEMENTS</font> or <font face="sans-serif"> MPI_GET_ELEMENTS_X</font>.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The definition implies that a receive cannot change the value of  
storage outside the entries defined to compose the communication  
buffer.  
In particular, the definition implies that padding space in a structure  
should not be modified when such a structure is copied from one process to  
another. This would  
prevent the obvious optimization of copying the structure, together  
with the padding, as one contiguous block.  
The implementation is free to do this optimization when it does not  
impact the outcome of the computation.  
The user can ``force'' this optimization by explicitly including  
padding as part of the message.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node87.htm#Node87"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node77.htm#Node77"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node89.htm#Node89"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node77.htm#Node77"> Derived Datatypes</a>
<b>Next: </b><a href="node89.htm#Node89"> Correct Use of Addresses</a>
<b>Previous: </b><a href="node87.htm#Node87"> Duplicating a Datatype</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
