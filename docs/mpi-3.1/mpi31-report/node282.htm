<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Lock</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node282">257. Lock</span></h2>
<a href="node281.htm#Node281"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node279.htm#Node279"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node283.htm#Node283"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node279.htm#Node279"> Synchronization Calls</a>
<b>Next: </b><a href="node283.htm#Node283"> Flush and Sync</a>
<b>Previous: </b><a href="node281.htm#Node281"> General Active Target Synchronization</a>
<p>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_LOCK(lock_type, rank, assert, win)</TD></TR>   
<TR><TD> IN lock_type</TD><TD>either <font face="sans-serif">  MPI_LOCK_EXCLUSIVE</font> or  
<font face="sans-serif">  MPI_LOCK_SHARED</font> (state)</TD></TR>  
<TR><TD> IN rank</TD><TD>rank of locked window (non-negative integer)</TD></TR>  
<TR><TD> IN assert</TD><TD>program assertion (integer)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_lock(int lock_type, int rank, int assert, MPI_Win win) <br></tt>  
<P> 
 <tt> MPI_Win_lock(lock_type, rank, assert, win, ierror) <br> INTEGER, INTENT(IN) :: lock_type, rank, assert <br>TYPE(MPI_Win), INTENT(IN) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_WIN_LOCK(LOCK_TYPE, RANK, ASSERT, WIN, IERROR)<br> INTEGER LOCK_TYPE, RANK, ASSERT, WIN, IERROR <br></tt>  
<P> 
  
<P> 
Starts an <font face="sans-serif"> RMA</font> access epoch.  
The  
window at the  
process with rank <font face="sans-serif"> rank</font> can be accessed by <font face="sans-serif"> RMA</font> operations  
on <font face="sans-serif"> win</font> during that  
epoch.  
Multiple <font face="sans-serif"> RMA</font> access epochs (with calls to <font face="sans-serif"> MPI_WIN_LOCK</font>)  
can occur simultaneously; however, each access epoch must target a  
different process.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_LOCK_ALL(assert, win)</TD></TR>   
<TR><TD> IN assert</TD><TD>program assertion (integer)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_lock_all(int assert, MPI_Win win) <br></tt>  
<P> 
 <tt> MPI_Win_lock_all(assert, win, ierror) <br> INTEGER, INTENT(IN) :: assert <br>TYPE(MPI_Win), INTENT(IN) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_WIN_LOCK_ALL(ASSERT, WIN, IERROR)<br> INTEGER ASSERT, WIN, IERROR <br></tt>  
<P> 
<P> 
Starts an <font face="sans-serif"> RMA</font> access epoch to all processes in  
<font face="sans-serif"> win</font>, with a lock type of <font face="sans-serif">  MPI_LOCK_SHARED</font>.   
During the epoch, the calling process can access the window memory on all  
processes in <font face="sans-serif"> win</font> by using <font face="sans-serif"> RMA</font> operations. A window locked with  
<font face="sans-serif"> MPI_WIN_LOCK_ALL</font> must be unlocked with  
<font face="sans-serif"> MPI_WIN_UNLOCK_ALL</font>.  This routine is not collective  
--- the <font face="sans-serif"> ALL</font> refers to a lock on all members of the group of the window.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
There may be additional overheads associated with using  
<font face="sans-serif"> MPI_WIN_LOCK</font> and <font face="sans-serif"> MPI_WIN_LOCK_ALL</font> concurrently  
on the same window. These overheads could be avoided by specifying the  
assertion <font face="sans-serif">  MPI_MODE_NOCHECK</font> when possible (see  
Section <a href="node284.htm#Node284">Assertions 
</a>).  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_UNLOCK(rank, win)</TD></TR>  
<TR><TD> IN rank</TD><TD>rank of window (non-negative integer)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_unlock(int rank, MPI_Win win) <br></tt>  
<P> 
 <tt> MPI_Win_unlock(rank, win, ierror) <br> INTEGER, INTENT(IN) :: rank <br>TYPE(MPI_Win), INTENT(IN) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_WIN_UNLOCK(RANK, WIN, IERROR)<br> INTEGER RANK, WIN, IERROR <br></tt>  
<P> 
  
<P> 
Completes an <font face="sans-serif"> RMA</font> access epoch started by a call to  
<font face="sans-serif"> MPI_WIN_LOCK</font> on window <font face="sans-serif"> win</font>.  
<font face="sans-serif"> RMA</font> operations issued during this  
period will have completed both at the origin and at the target when the call returns.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_UNLOCK_ALL(win)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_unlock_all(MPI_Win win) <br></tt>  
<P> 
 <tt> MPI_Win_unlock_all(win, ierror) <br> TYPE(MPI_Win), INTENT(IN) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_WIN_UNLOCK_ALL(WIN, IERROR)<br> INTEGER WIN, IERROR <br></tt>  
<P> 
<P> 
Completes a shared <font face="sans-serif"> RMA</font> access epoch started by a call to  
<font face="sans-serif"> MPI_WIN_LOCK_ALL</font> on window <font face="sans-serif"> win</font>.  
<font face="sans-serif"> RMA</font> operations issued during this  
epoch will have completed both at the origin and at the target when the call returns.  
<P> 
  
Locks are used to protect accesses to the locked target  
window effected by <font face="sans-serif"> RMA</font> calls issued between the lock and unlock  
calls, and to protect  
load/store accesses to a locked local or shared  
memory window executed between the lock and unlock  
calls.   
Accesses that are protected by an exclusive lock  
will not be concurrent at the window site  
with other accesses to the same window that are lock protected.  
Accesses that are protected by a shared lock will not be  
concurrent at the window site with  
accesses protected by an exclusive lock to the same window.  
<P> 
It is erroneous to have a window locked and exposed (in an exposure  
epoch) concurrently.  For example, a process may not call  
<font face="sans-serif"> MPI_WIN_LOCK</font> to lock a target window if the target process  
has called <font face="sans-serif"> MPI_WIN_POST</font> and has not yet called  
<font face="sans-serif"> MPI_WIN_WAIT</font>; it is erroneous to call  
<font face="sans-serif"> MPI_WIN_POST</font> while the local window is locked.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
An alternative is to require <font face="sans-serif"> MPI</font> to enforce mutual exclusion between exposure epochs and locking periods.  But this would entail additional  
overheads when locks or active target synchronization do not interact  
in support of those rare interactions between the two mechanisms.  The  
programming style that we encourage here is that a set of windows is  
used with only one synchronization mechanism at a time, with shifts  
from one mechanism to another being rare and involving global synchronization.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Users need to use explicit synchronization code in order to enforce  
mutual exclusion between locking periods and exposure epochs on a  
window.  
 (<em> End of advice to users.</em>) <br> 
Implementors may restrict the use of <font face="sans-serif"> RMA</font> communication that is   
synchronized by lock calls to windows in memory allocated by   
<font face="sans-serif"> MPI_ALLOC_MEM</font>   
(Section <a href="node216.htm#Node216">Memory Allocation 
</a>),  
<font face="sans-serif"> MPI_WIN_ALLOCATE</font> (Section <a href="node262.htm#Node262">Window That Allocates Memory 
</a>), or attached with  
<font face="sans-serif"> MPI_WIN_ATTACH</font> (Section <a href="node264.htm#Node264">Window of Dynamically Attached Memory 
</a>).  
Locks can be used portably only in such memory.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The implementation of passive target communication when memory is not shared  
may require an asynchronous software   
agent.  Such an agent can be implemented more easily, and can achieve  
better performance, if restricted to specially allocated memory.  It  
can be avoided altogether if shared memory is used. It seems natural to  
impose restrictions that allows one to use shared memory for third  
party communication in shared memory machines.  
<P> 
 (<em> End of rationale.</em>) <br> 
Consider the sequence of calls in the example below.  
<br><b> Example</b>  
  
<br> 
<pre><tt>MPI_Win_lock(MPI_LOCK_EXCLUSIVE, rank, assert, win); 
MPI_Put(..., rank, ..., win); 
MPI_Win_unlock(rank, win); 
</tt></pre> 
  
  
<P> 
The call to <font face="sans-serif"> MPI_WIN_UNLOCK</font> will not return until the put  
transfer has completed at the origin  
and at the target.  
This still leaves much freedom to implementors.  
The call to  
<font face="sans-serif"> MPI_WIN_LOCK</font> may block until an  
exclusive lock on the window is acquired; or, the first  
two calls may not block, while <font face="sans-serif"> MPI_WIN_UNLOCK</font> blocks until  
a lock is acquired --- the update of the target window is then  
postponed until the call to <font face="sans-serif"> MPI_WIN_UNLOCK</font> occurs.  
However,  if the call to <font face="sans-serif"> MPI_WIN_LOCK</font> is used to lock a  
local window, then the call must block until the lock is acquired,  
since the lock may protect local load/store accesses to the window issued  
after the lock call returns.  
<P> 

<P>
<hr>
<a href="node281.htm#Node281"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node279.htm#Node279"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node283.htm#Node283"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node279.htm#Node279"> Synchronization Calls</a>
<b>Next: </b><a href="node283.htm#Node283"> Flush and Sync</a>
<b>Previous: </b><a href="node281.htm#Node281"> General Active Target Synchronization</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
