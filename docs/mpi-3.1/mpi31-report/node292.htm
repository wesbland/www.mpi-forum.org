<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Progress</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node292">267. Progress</span></h2>
<a href="node291.htm#Node291"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node289.htm#Node289"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node293.htm#Node293"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node289.htm#Node289"> Semantics and Correctness</a>
<b>Next: </b><a href="node293.htm#Node293"> Registers and Compiler Optimizations</a>
<b>Previous: </b><a href="node291.htm#Node291"> Ordering</a>
<p>
One-sided communication has the same progress requirements as  
point-to-point communication: once a communication is enabled it  
is guaranteed to complete.  <font face="sans-serif"> RMA</font> calls must have local semantics,  
except when required for synchronization with other <font face="sans-serif"> RMA</font> calls.  
<P> 
There is some fuzziness in the definition of the time when a <font face="sans-serif"> RMA</font>  
communication  
becomes enabled.  This fuzziness provides to the implementor more  
flexibility  
than with point-to-point communication.  
Access to a target window becomes enabled once the corresponding synchronization (such as <font face="sans-serif"> MPI_WIN_FENCE</font> or <font face="sans-serif"> MPI_WIN_POST</font>) has executed.  On the origin process, an <font face="sans-serif"> RMA</font>  
communication may become enabled as soon as the corresponding put, get  
or accumulate call has executed, or as late as when  
the ensuing synchronization call is issued.  Once the  
communication is enabled both at the origin and at the target, the communication must complete.  
<P> 
Consider the code fragment in Example <a href="node281.htm#Node281">General Active Target Synchronization 
</a>.  
Some of  
the calls may block if the target window is not posted.  However, if  
the target window is posted, then the code fragment must complete.  
The data transfer may start as soon as the put call occurs, but may be delayed until the ensuing complete call occurs.  
<P> 
Consider the code fragment in Example <a href="node282.htm#Node282">Lock 
</a>.  
Some of the calls may block if another process holds a conflicting  
lock.  However, if no conflicting lock is held, then the code fragment  
must complete.  
<P> 
Consider the code illustrated  in  
Figure <a href="node292.htm#Figure25">25 
</a>.  
<div style=\"text-align:center\"><P><img width=300 height=227 src="symmetric.gif" alt="Image file"><P>
</div>  
<br> 
<b>Figure 25: </b><span id="Figure25">Symmetric communication</span><P> 
  
  
Each process updates the window of the other process using a put  
operation, then accesses its own window.  The post calls are  
nonblocking, and should complete.  Once the post calls occur, <font face="sans-serif"> RMA</font>  
access to the windows is enabled, so that each process should complete  
the sequence of calls start-put-complete.  Once these are done,  
the wait calls should complete at both processes.  Thus, this  
communication should not deadlock, irrespective of the amount of data   
transferred.  
<P> 
Assume, in the last example, that the order of the post and start  
calls is reversed at each process.  
Then, the code may deadlock, as  
each process may block on the start call, waiting for the matching post  
to occur.  
Similarly, the program will deadlock if the  
order of the complete and   
wait calls is reversed at each process.  
<P> 
The following two examples illustrate the fact that the  
synchronization between complete and wait is not symmetric: the wait  
call blocks until the complete executes, but not vice versa.  
Consider the code illustrated in Figure <a href="node292.htm#Figure26">26 
</a>.  
<div style=\"text-align:center\"><P><img width=281 height=158 src="deadlck1.gif" alt="Image file"><P>
</div>  
<P> 
<br> 
<b>Figure 26: </b><span id="Figure26">Deadlock situation</span><P> 
  
  
This code will deadlock: the wait of process 1 blocks until process 0  
calls complete, and the receive of process 0 blocks until process 1  
calls send.  Consider, on the other hand, the code  
illustrated in Figure <a href="node292.htm#Figure27">27 
</a>.  
<div style=\"text-align:center\"><P><img width=259 height=155 src="deadlck2.gif" alt="Image file"><P>
</div>  
<P> 
<br> 
<b>Figure 27: </b><span id="Figure27">No deadlock</span><P> 
  
  
This code will not deadlock.  Once process 1 calls post, then the  
sequence start, put, complete on process 0 can proceed to completion.  
Process 0 will reach the send call, allowing the receive call of  
process 1 to complete.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
<font face="sans-serif"> MPI</font> implementations must guarantee that a process makes progress on  
all enabled communications it participates in,  
while blocked on an <font face="sans-serif"> MPI</font> call.  This is  
true for send-receive communication and applies to <font face="sans-serif"> RMA</font> communication  
as well.  Thus, in the example in Figure <a href="node292.htm#Figure27">27 
</a>,  
the put and complete calls of process 0 should complete  
while process 1 is blocked on the receive call.  This may require the  
involvement of process 1, e.g., to transfer the data put, while it is  
blocked on the receive   
call.  
<P> 
A similar issue is whether such progress must occur  
while a process is busy computing, or blocked in a  
non-<font face="sans-serif"> MPI</font> call.  Suppose that in the last example the send-receive  
pair is replaced by a write-to-socket/read-from-socket pair.  Then  
<font face="sans-serif"> MPI</font> does not specify whether deadlock is avoided.  
Suppose that the blocking  
receive of process 1 is replaced by a very long compute loop.  Then,  
according to one interpretation of  
the <font face="sans-serif"> MPI</font> standard, process 0 must return from the complete call after  
a bounded delay, even if process 1 does not reach any <font face="sans-serif"> MPI</font> call in  
this period of time.  According to another interpretation, the  
complete call may block until process 1 reaches the wait call, or  
reaches another <font face="sans-serif"> MPI</font> call.  The qualitative behavior is the same,  
under both interpretations, unless a process is caught in an infinite compute loop, in which case the difference may not matter.  
However, the quantitative expectations are different.  
Different <font face="sans-serif"> MPI</font> implementations reflect these different  
interpretations.  
While this ambiguity is unfortunate, the <font face="sans-serif"> MPI</font> Forum decided not to define  
which interpretation of the standard is the correct one, since the issue is  
contentious.  
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node291.htm#Node291"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node289.htm#Node289"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node293.htm#Node293"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node289.htm#Node289"> Semantics and Correctness</a>
<b>Next: </b><a href="node293.htm#Node293"> Registers and Compiler Optimizations</a>
<b>Previous: </b><a href="node291.htm#Node291"> Ordering</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
