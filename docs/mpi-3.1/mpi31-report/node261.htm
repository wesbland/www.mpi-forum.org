<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Window Creation</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node261">240. Window Creation</span></h2>
<a href="node260.htm#Node260"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node260.htm#Node260"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node262.htm#Node262"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node260.htm#Node260"> Initialization</a>
<b>Next: </b><a href="node262.htm#Node262"> Window That Allocates Memory</a>
<b>Previous: </b><a href="node260.htm#Node260"> Initialization</a>
<p>
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_CREATE(base, size, disp_unit, info, comm, win)</TD></TR>  
<TR><TD> IN base</TD><TD>initial address of window (choice)</TD></TR>  
<TR><TD> IN size</TD><TD>size of window in bytes (non-negative integer)</TD></TR>  
<TR><TD> IN disp_unit</TD><TD>local unit size for displacements, in bytes (positive integer)</TD></TR>  
<TR><TD> IN info</TD><TD>info argument (handle)</TD></TR>  
<TR><TD> IN comm</TD><TD>intra-communicator (handle)</TD></TR>  
<TR><TD> OUT win</TD><TD>window object returned by the call (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_create(void *base, MPI_Aint size, int disp_unit, MPI_Info info, MPI_Comm comm, MPI_Win *win) <br></tt>  
  
 <tt> MPI_Win_create(base, size, disp_unit, info, comm, win, ierror) <br> TYPE(*), DIMENSION(..), ASYNCHRONOUS :: base <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size <br>INTEGER, INTENT(IN) :: disp_unit <br>TYPE(MPI_Info), INTENT(IN) :: info <br>TYPE(MPI_Comm), INTENT(IN) :: comm <br>TYPE(MPI_Win), INTENT(OUT) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_WIN_CREATE(BASE, SIZE, DISP_UNIT, INFO, COMM, WIN, IERROR)<br>  &lt;type&gt; BASE(*) <br>INTEGER(KIND=MPI_ADDRESS_KIND) SIZE  <br>INTEGER DISP_UNIT, INFO, COMM, WIN, IERROR <br></tt>  
<P> 
  
<P> 
This is a collective call executed by all processes in the group of  
<font face="sans-serif"> comm</font>.  It returns a window object that can be used by these  
processes to perform <font face="sans-serif"> RMA</font> operations.  Each process specifies  
a window of existing memory that it exposes to <font face="sans-serif"> RMA</font> accesses by the  
processes in the group of  
<font face="sans-serif"> comm</font>.  
The window consists of <font face="sans-serif"> size</font> bytes,  
starting at address <font face="sans-serif"> base</font>.  
In C, <font face="sans-serif"> base</font> is the starting  
address of a memory region.   
In Fortran, one can pass the first element of a memory region  
or a whole array, which must be `simply contiguous'   
(for `simply contiguous,' see also   
Section <a href="node422.htm#Node422">Problems Due to Data Copying and Sequence Association with Subscript Triplets 
</a>).  
A process may elect to expose no memory by  
specifying <font face="sans-serif"> size = 0</font>.  
<P> 
The displacement unit argument  
is provided to facilitate address arithmetic in <font face="sans-serif"> RMA</font>  
operations: the target displacement argument of an <font face="sans-serif"> RMA</font> operation is  
scaled by the factor <font face="sans-serif"> disp_unit</font> specified by the target  
process, at window creation.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The window size is specified using an address-sized integer,  
rather than a basic integer type, to allow windows that span more memory than  
can be described with a basic integer type.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Common choices for <font face="sans-serif"> disp_unit</font>  
are 1 (no scaling), and (in C syntax) <tt>sizeof(type)</tt>, for a  
window that consists of an array of elements of type <tt>type</tt>.  The  
latter  
choice will allow one to use array indices in <font face="sans-serif"> RMA</font> calls,  
and have those scaled correctly to byte displacements, even in a  
heterogeneous environment.  
 (<em> End of advice to users.</em>) <br> 
The <font face="sans-serif"> info</font> argument provides  
optimization hints to the runtime about the expected  
usage pattern of the window.  
The following info keys are predefined:  
<P> 
<dl> 
 
<dt> 
<b></b><dd> 
<font face="sans-serif"> no_locks</font> --- if set to <font face="sans-serif">  true</font>,  
then the implementation may assume that passive target synchronization (i.e.,  
<font face="sans-serif"> MPI_WIN_LOCK</font>, <font face="sans-serif"> MPI_WIN_LOCK_ALL</font>) will not be used on  
the given window. This implies that this window is not used for 3-party  
communication, and <font face="sans-serif"> RMA</font> can be implemented with no (less) asynchronous  
agent activity at this process.  
 
<dt> 
<b></b><dd> 
<font face="sans-serif"> accumulate_ordering</font> --- controls the ordering of accumulate   
operations at the target.  See Section <a href="node291.htm#Node291">Ordering 
</a> for details.  
 
<dt> 
<b></b><dd> 
<font face="sans-serif"> accumulate_ops</font> --- if set to <font face="sans-serif"> same_op</font>,  
the implementation will assume that all concurrent accumulate calls  
to the same target address will use the same operation. If set to  
<font face="sans-serif"> same_op_no_op</font>, then the implementation will assume that  
all concurrent accumulate calls to the same target address will use the  
same operation or <font face="sans-serif"> MPI_NO_OP</font>. This can eliminate the need to  
protect access for certain operation types where the hardware can  
guarantee atomicity. The default is <font face="sans-serif"> same_op_no_op</font>.  
 
<dt> 
<b></b><dd> 
<font face="sans-serif"> same_size</font> --- if set to <font face="sans-serif">  true</font>,  
then the implementation may assume that the argument <font face="sans-serif"> size</font> is  
identical on all processes, and that all processes have provided this  
info key with the same value.  
 
<dt> 
<b></b><dd> 
<font face="sans-serif"> same_disp_unit</font> --- if set to <font face="sans-serif">  true</font>,  
then the implementation  
may assume that the argument <font face="sans-serif"> disp_unit</font>  
is identical on all processes, and  
that all processes have provided this info key with the same value.  
</dl> 
<br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The info query mechanism described in Section <a href="node267.htm#Node267">Window Info 
</a>  
can be used to query the specified info arguments  
for  
windows that have been  
passed to a library. It is recommended that libraries check attached  
info keys for each passed window.  
 (<em> End of advice to users.</em>) <br> 
The various processes in the group of  
<font face="sans-serif"> comm</font> may specify completely different  
target windows, in location, size, displacement  
units, and info arguments.   
As long as all the get, put and accumulate accesses   
to a particular process fit their  
specific target window this should pose no problem.  
The same area in memory may appear in multiple windows, each  
associated with a different window object.  However, concurrent  
communications to distinct, overlapping windows may lead to  
undefined  
results.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The reason for specifying the memory that may be accessed from another  
process in an <font face="sans-serif"> RMA</font> operation is to permit the programmer to specify  
what memory can be a target of <font face="sans-serif"> RMA</font> operations and for the  
implementation to enforce that specification.  For example, with this  
definition, a server process can safely allow a client process to use  
<font face="sans-serif"> RMA</font> operations, knowing that (under the assumption that the <font face="sans-serif"> MPI</font>  
implementation does enforce the specified limits on the exposed  
memory) an error in the client cannot affect any memory other than  
what was explicitly exposed.    
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
A window can be created in any part of the process memory.  However,  
on some systems, the performance of windows in  
memory allocated by <font face="sans-serif"> MPI_ALLOC_MEM</font>   
(Section <a href="node216.htm#Node216">Memory Allocation 
</a>) will be better.  
Also, on some systems, performance is improved when window boundaries  
are aligned at ``natural'' boundaries (word, double-word, cache line,  
page frame, etc.).  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
In cases where <font face="sans-serif"> RMA</font> operations use different mechanisms in different  
memory areas (e.g., load/store in a shared memory segment, and an  
asynchronous handler in private memory), the <font face="sans-serif"> MPI_WIN_CREATE</font>  
call needs to figure out which type of memory is used for the  
window.  To do so, <font face="sans-serif"> MPI</font> maintains, internally, the  
list of memory segments allocated by <font face="sans-serif"> MPI_ALLOC_MEM</font>, or by  
other, implementation-specific,  
mechanisms, together with information   
on the type of memory segment allocated.  When a call to   
<font face="sans-serif"> MPI_WIN_CREATE</font> occurs, then <font face="sans-serif"> MPI</font> checks which segment  
contains each window, and decides, accordingly, which mechanism to use  
for <font face="sans-serif"> RMA</font> operations.  
<P> 
Vendors may provide additional, implementation-specific mechanisms to  
allocate or to specify memory regions that are preferable for use in  
one-sided communication. In particular, such mechanisms can be used to  
place static variables into such preferred regions.  
<P> 
Implementors should document any performance impact of window alignment.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node260.htm#Node260"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node260.htm#Node260"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node262.htm#Node262"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node260.htm#Node260"> Initialization</a>
<b>Next: </b><a href="node262.htm#Node262"> Window That Allocates Memory</a>
<b>Previous: </b><a href="node260.htm#Node260"> Initialization</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
