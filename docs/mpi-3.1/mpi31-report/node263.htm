<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Window That Allocates Shared Memory</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node263">242. Window That Allocates Shared Memory</span></h2>
<a href="node262.htm#Node262"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node260.htm#Node260"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node264.htm#Node264"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node260.htm#Node260"> Initialization</a>
<b>Next: </b><a href="node264.htm#Node264"> Window of Dynamically Attached Memory</a>
<b>Previous: </b><a href="node262.htm#Node262"> Window That Allocates Memory</a>
<p>
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_ALLOCATE_SHARED(size, disp_unit, info, comm, baseptr, win)</TD></TR>  
<TR><TD> IN size</TD><TD>size of local window in bytes (non-negative integer)</TD></TR>  
<TR><TD> IN disp_unit</TD><TD>local unit size for displacements, in bytes (positive integer)</TD></TR>  
<TR><TD> IN info</TD><TD>info argument (handle)</TD></TR>  
<TR><TD> IN comm</TD><TD>intra-communicator (handle)</TD></TR>  
<TR><TD> OUT baseptr</TD><TD>address of local allocated window segment (choice)</TD></TR>  
<TR><TD> OUT win</TD><TD>window object returned by the call (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_allocate_shared(MPI_Aint size, int disp_unit, MPI_Info info, MPI_Comm comm, void *baseptr, MPI_Win *win) <br></tt>  
<P> 
 <tt> MPI_Win_allocate_shared(size, disp_unit, info, comm, baseptr, win, ierror) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size <br>INTEGER, INTENT(IN) :: disp_unit <br>TYPE(MPI_Info), INTENT(IN) :: info <br>TYPE(MPI_Comm), INTENT(IN) :: comm <br>TYPE(C_PTR), INTENT(OUT) :: baseptr <br>TYPE(MPI_Win), INTENT(OUT) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_WIN_ALLOCATE_SHARED(SIZE, DISP_UNIT, INFO, COMM, BASEPTR, WIN, IERROR)<br> INTEGER DISP_UNIT, INFO, COMM, WIN, IERROR <br>INTEGER(KIND=MPI_ADDRESS_KIND) SIZE, BASEPTR  <br></tt>  
<P> 
<P> 
This is a collective call executed by all processes in the group of  
<font face="sans-serif"> comm</font>. On each process, it allocates memory of at least  
<font face="sans-serif"> size</font> bytes that is shared among all processes in <font face="sans-serif"> comm</font>,  
and returns a pointer to  
the locally allocated segment in <font face="sans-serif"> baseptr</font> that can be used for  
load/store accesses on the calling process. The locally allocated memory can be   
the target of load/store accesses by remote processes; the base pointers for  
other processes can be queried using the function  
<font face="sans-serif"> MPI_WIN_SHARED_QUERY</font>. The call also returns a window object that  
can be used by all processes in <font face="sans-serif"> comm</font> to perform <font face="sans-serif"> RMA</font> operations. The  
size argument may be different at each process and <font face="sans-serif"> size = 0</font> is  
valid.  It is the user's responsibility to ensure that the communicator  
<font face="sans-serif"> comm</font> represents a group of processes that can create a shared  
memory segment that can be accessed by all processes in the group.  
The discussions of   
rationales for <font face="sans-serif"> MPI_ALLOC_MEM</font> and <font face="sans-serif"> MPI_FREE_MEM</font> in  
Section <a href="node216.htm#Node216">Memory Allocation 
</a> also apply to  
<font face="sans-serif"> MPI_WIN_ALLOCATE_SHARED</font>; in particular, see the rationale in  
Section <a href="node216.htm#Node216">Memory Allocation 
</a> for an explanation of the type used for  
<font face="sans-serif"> baseptr</font>. The allocated memory is contiguous across process  
ranks unless the info key <font face="sans-serif">  alloc_shared_noncontig</font> is  
specified. Contiguous across process ranks means that the first  
address in the memory segment of process <i>i</i> is consecutive with the last  
address in the memory segment of process <i>i-1</i>. This may enable the user to  
calculate remote address offsets with local information only.   
 <P> 
If the Fortran compiler provides <tt> TYPE(C_PTR)</tt>,   
then the following generic interface must be provided in the <tt>mpi</tt>  
module and should be provided in <tt>mpif.h</tt> through overloading,   
i.e., with the same routine name as the  
routine with <tt> INTEGER(KIND=MPI_ADDRESS_KIND) BASEPTR</tt>,   
but with a different specific procedure name:  
 <P> 
<br> 
<pre><tt>INTERFACE MPI_WIN_ALLOCATE_SHARED 
    SUBROUTINE MPI_WIN_ALLOCATE_SHARED(SIZE, DISP_UNIT, INFO, COMM, &amp; 
                                       BASEPTR, WIN, IERROR) 
        IMPORT ::  MPI_ADDRESS_KIND 
        INTEGER DISP_UNIT, INFO, COMM, WIN, IERROR 
        INTEGER(KIND=MPI_ADDRESS_KIND) SIZE, BASEPTR 
    END SUBROUTINE 
    SUBROUTINE MPI_WIN_ALLOCATE_SHARED_CPTR(SIZE, DISP_UNIT, INFO, COMM, &amp; 
                                            BASEPTR, WIN, IERROR) 
        USE, INTRINSIC ::  ISO_C_BINDING, ONLY : C_PTR 
        IMPORT ::  MPI_ADDRESS_KIND 
        INTEGER ::  DISP_UNIT, INFO, COMM, WIN, IERROR 
        INTEGER(KIND=MPI_ADDRESS_KIND) ::  SIZE 
        TYPE(C_PTR) ::  BASEPTR 
    END SUBROUTINE 
END INTERFACE 
</tt></pre> 
The base procedure name of this overloaded function is<font face="sans-serif"> MPI_WIN_ALLOCATE_SHARED_CPTR</font>. The implied specific procedure names  
are described in Section <a href="node412.htm#Node412">Interface Specifications, Procedure Names, and the Profiling Interface 
</a>.  
<P> 
The <font face="sans-serif"> info</font> argument can be used to specify hints  
similar to the <font face="sans-serif"> info</font> argument for <font face="sans-serif"> MPI_WIN_CREATE</font>,  
<font face="sans-serif"> MPI_WIN_ALLOCATE</font>, and <font face="sans-serif"> MPI_ALLOC_MEM</font>. The additional info  
key <font face="sans-serif">  alloc_shared_noncontig</font> allows the library to optimize the layout  
of the shared memory segments in memory.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
If the info key <font face="sans-serif">  alloc_shared_noncontig</font> is not set to true, the  
allocation strategy is to allocate contiguous memory across process  
ranks. This may limit the performance on some architectures because it  
does not allow the implementation to modify the data layout (e.g.,  
padding to reduce access latency).  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
If the user sets the info key <font face="sans-serif">  alloc_shared_noncontig</font> to true, the  
implementation can allocate the memory requested by each process in a  
location that is close to this process. This can be achieved by padding  
or allocating memory in special memory segments. Both techniques may  
make the address space across consecutive ranks noncontiguous.   
 (<em> End of advice to implementors.</em>) <br> 
The consistency of load/store accesses from/to the shared memory as  
observed by the user program depends on the architecture. A consistent  
view can be created in the <em> unified memory model</em> (see   
Section <a href="node278.htm#Node278">Memory Model 
</a>) by utilizing the window  
synchronization functions (see Section <a href="node279.htm#Node279">Synchronization Calls 
</a>) or  
explicitly completing outstanding store accesses (e.g., by calling  
<font face="sans-serif"> MPI_WIN_FLUSH</font>). <font face="sans-serif"> MPI</font> does not define semantics for  
accessing shared memory windows in the <em> separate memory model</em>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_SHARED_QUERY(win, rank, size, disp_unit, baseptr)</TD></TR>  
<TR><TD> IN win</TD><TD>shared memory window object (handle)</TD></TR>  
<TR><TD> IN rank</TD><TD>rank in the group of window win (non-negative integer)  
or <font face="sans-serif">  MPI_PROC_NULL</font></TD></TR>  
<TR><TD> OUT size</TD><TD>size of the window segment (non-negative integer)</TD></TR>  
<TR><TD> OUT disp_unit</TD><TD>local unit size for displacements, in bytes (positive integer)</TD></TR>  
<TR><TD> OUT baseptr</TD><TD>address for load/store access to window   
segment (choice)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_shared_query(MPI_Win win, int rank, MPI_Aint *size, int *disp_unit, void *baseptr) <br></tt>  
<P> 
 <tt> MPI_Win_shared_query(win, rank, size, disp_unit, baseptr, ierror) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(MPI_Win), INTENT(IN) :: win <br>INTEGER, INTENT(IN) :: rank <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: size <br>INTEGER, INTENT(OUT) :: disp_unit <br>TYPE(C_PTR), INTENT(OUT) :: baseptr <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_WIN_SHARED_QUERY(WIN, RANK, SIZE, DISP_UNIT, BASEPTR, IERROR)<br> INTEGER WIN, RANK, DISP_UNIT, IERROR<br>INTEGER (KIND=MPI_ADDRESS_KIND) SIZE, BASEPTR  <br></tt>  
<P> 
This function queries the process-local address for remote memory segments  
created with <font face="sans-serif"> MPI_WIN_ALLOCATE_SHARED</font>. This function can return  
different process-local addresses for the same physical memory on different  
processes. The returned memory can be used for load/store accesses subject to  
the constraints defined in Section <a href="node289.htm#Node289">Semantics and Correctness 
</a>. This function  
can only be called with windows of  
flavor  
<font face="sans-serif"> MPI_WIN_FLAVOR_SHARED</font>. If the passed window is not of flavor  
<font face="sans-serif"> MPI_WIN_FLAVOR_SHARED</font>, the error  
<font face="sans-serif"> MPI_ERR_RMA_FLAVOR</font> is raised.  
When <font face="sans-serif"> rank</font> is <font face="sans-serif">  MPI_PROC_NULL</font>, the pointer,  
<font face="sans-serif"> disp_unit</font>, and <font face="sans-serif"> size</font> returned are  
the pointer, <font face="sans-serif"> disp_unit</font>, and <font face="sans-serif"> size</font> of the memory  
segment belonging the lowest rank that   
specified <font face="sans-serif"> size</font> <i>&gt; 0</i>. If all processes in the group attached to  
the window specified <font face="sans-serif"> size</font> <i>= 0</i>, then the call returns  
<font face="sans-serif"> size</font> <i>= 0</i> and a <font face="sans-serif"> baseptr</font> as if <font face="sans-serif"> MPI_ALLOC_MEM</font>  
was called with <font face="sans-serif"> size</font> <i>= 0</i>.  
 <P> 
If the Fortran compiler provides <tt> TYPE(C_PTR)</tt>,   
then the following generic interface must be provided in the <tt>mpi</tt>  
module and should be provided in <tt>mpif.h</tt> through overloading,   
i.e., with the same routine name as the  
routine with <tt> INTEGER(KIND=MPI_ADDRESS_KIND) BASEPTR</tt>,   
but with a different specific procedure name:  
 <P> 
<br> 
<pre><tt>INTERFACE MPI_WIN_SHARED_QUERY 
    SUBROUTINE MPI_WIN_SHARED_QUERY(WIN, RANK, SIZE, DISP_UNIT, &amp; 
                                    BASEPTR, IERROR) 
        IMPORT :: MPI_ADDRESS_KIND 
        INTEGER WIN, RANK, DISP_UNIT, IERROR 
        INTEGER (KIND=MPI_ADDRESS_KIND) SIZE, BASEPTR 
    END SUBROUTINE 
    SUBROUTINE MPI_WIN_SHARED_QUERY_CPTR(WIN, RANK, SIZE, DISP_UNIT, &amp; 
                                         BASEPTR, IERROR) 
        USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR 
        IMPORT :: MPI_ADDRESS_KIND 
        INTEGER :: WIN, RANK, DISP_UNIT, IERROR 
        INTEGER(KIND=MPI_ADDRESS_KIND) :: SIZE 
        TYPE(C_PTR) :: BASEPTR 
    END SUBROUTINE 
END INTERFACE 
</tt></pre> 
The base procedure name of this overloaded function is  
<font face="sans-serif"> MPI_WIN_SHARED_QUERY_CPTR</font>. The implied specific  
procedure names  
are described in Section <a href="node412.htm#Node412">Interface Specifications, Procedure Names, and the Profiling Interface 
</a>.  
<P> 

<P>
<hr>
<a href="node262.htm#Node262"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node260.htm#Node260"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node264.htm#Node264"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node260.htm#Node260"> Initialization</a>
<b>Next: </b><a href="node264.htm#Node264"> Window of Dynamically Attached Memory</a>
<b>Previous: </b><a href="node262.htm#Node262"> Window That Allocates Memory</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
