<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-topol/topol.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Graph Constructor</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node194">182. Graph Constructor</span></h2>
<a href="node193.htm#Node193"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node191.htm#Node191"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node195.htm#Node195"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node191.htm#Node191"> Topology Constructors</a>
<b>Next: </b><a href="node195.htm#Node195"> Distributed Graph Constructor</a>
<b>Previous: </b><a href="node193.htm#Node193"> Cartesian Convenience Function: <font face="sans-serif"> MPI_DIMS_CREATE</font></a>
<p>
  
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_CREATE(comm_old, nnodes, index, edges, reorder, comm_graph)</TD></TR>  
<TR><TD> IN  comm_old</TD><TD> input communicator (handle)</TD></TR>  
<TR><TD> IN  nnodes</TD><TD> number of nodes in graph (integer)</TD></TR>  
<TR><TD> IN  index</TD><TD>array of integers describing node degrees (see below)</TD></TR>  
<TR><TD> IN  edges</TD><TD>array of integers describing graph edges (see below)</TD></TR>  
<TR><TD> IN  reorder</TD><TD> ranking may be reordered (<font face="sans-serif">  true</font>) or not (<font face="sans-serif">  false</font>) (logical)</TD></TR>  
<TR><TD> OUT  comm_graph</TD><TD> communicator with graph topology added (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graph_create(MPI_Comm comm_old, int nnodes, const int index[], const int edges[], int reorder, MPI_Comm *comm_graph) <br></tt>  
<P> 
 <tt> MPI_Graph_create(comm_old, nnodes, index, edges, reorder, comm_graph, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm_old <br>INTEGER, INTENT(IN) :: nnodes, index(nnodes), edges(*) <br>LOGICAL, INTENT(IN) :: reorder <br>TYPE(MPI_Comm), INTENT(OUT) :: comm_graph <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GRAPH_CREATE(COMM_OLD, NNODES, INDEX, EDGES, REORDER, COMM_GRAPH, IERROR)<br> INTEGER COMM_OLD, NNODES, INDEX(*), EDGES(*), COMM_GRAPH, IERROR <br>LOGICAL REORDER <br></tt>  
<P> 
  
<P> 
<font face="sans-serif"> MPI_GRAPH_CREATE</font> returns a handle to a new communicator to which the  
graph topology information is attached.  If <font face="sans-serif"> reorder = false</font> then the  
rank of each process in the new group is identical to its rank in the old  
group.  Otherwise, the function may reorder the processes.  If the size,  
<font face="sans-serif"> nnodes</font>, of the graph is smaller than the size of the group of  
<font face="sans-serif"> comm_old</font>, then some processes are returned <font face="sans-serif">  MPI_COMM_NULL</font>, in  
analogy to <font face="sans-serif"> MPI_CART_CREATE</font> and <font face="sans-serif"> MPI_COMM_SPLIT</font>.  
If the graph is empty, i.e., <font face="sans-serif"> nnodes == 0</font>,   
then <font face="sans-serif">  MPI_COMM_NULL</font> is returned in all processes.   
The call  
is erroneous if it specifies a graph that is larger than the group size of the  
input communicator.  
<P> 
The three parameters <font face="sans-serif"> nnodes, index</font> and <font face="sans-serif"> edges</font> define the graph  
structure.  
<font face="sans-serif"> nnodes</font> is the number of nodes of the graph.   The nodes are numbered  
from <font face="sans-serif"> 0</font> to <font face="sans-serif"> nnodes-1</font>.  
The   
<font face="sans-serif"> i</font>-th   
entry of array <font face="sans-serif"> index</font> stores the total number of  
neighbors of the first <font face="sans-serif"> i</font> graph nodes.   The lists of neighbors of  
nodes <font face="sans-serif"> 0, 1, ..., nnodes-1</font> are stored in consecutive locations in array  
<font face="sans-serif"> edges</font>.  The array <font face="sans-serif"> edges</font> is a flattened representation  
of the edge lists.  
The total number of entries in <font face="sans-serif"> index</font> is <font face="sans-serif"> nnodes</font> and  
the total number of entries in <font face="sans-serif"> edges</font> is equal to the number of  
graph edges.  
<P> 
The definitions of the arguments <font face="sans-serif"> nnodes</font>, <font face="sans-serif"> index</font>, and  
<font face="sans-serif"> edges</font> are illustrated with the following simple example.  
<P> 
<br><b> Example</b>  
  
  
Assume there are four processes 0, 1, 2, 3 with the following  
adjacency matrix:  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT"> neighbors </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT"> 1, 3      </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT"> 0         </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT"> 3         </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT"> 0, 2      </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
</div>  
 Then, the input arguments are:  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="LEFT">nnodes =</TD><TD ALIGN="LEFT"> 4 </TD></TR> 
<TR><TD ALIGN="LEFT">  
index =</TD><TD ALIGN="LEFT"> 2, 3, 4, 6 </TD></TR> 
<TR><TD ALIGN="LEFT">  
edges =</TD><TD ALIGN="LEFT"> 1, 3, 0, 3, 0, 2  
</TD></TR></TABLE> 
</div>  
<P> 
Thus, in C, <tt>index[0]</tt> is the degree of node zero, and <tt>index[i] - 
index[i-1]</tt> is the degree of node <tt>i, i=1, ..., nnodes-1</tt>;  
the list of neighbors of node zero is stored in <tt>edges[j]</tt>, for  
<img width=104 height=10 src="img161.gif" alt="Image file">
 and the   
list of neighbors of node <tt>i</tt>,  
<img width=24 height=7 src="img162.gif" alt="Image file">
,  
is stored in <tt>edges[j]</tt>, <img width=155 height=10 src="img163.gif" alt="Image file">
.  
<P> 
In Fortran, <tt>index(1)</tt> is the degree of node zero, and <tt>index(i+1) - 
index(i)</tt> is the degree of node <tt>i, i=1, ..., nnodes-1</tt>;  
the list of neighbors of node zero is stored in <tt>edges(j)</tt>, for  
<img width=83 height=10 src="img164.gif" alt="Image file">
 and the list of neighbors of node  
<tt>i</tt>, <img width=24 height=7 src="img165.gif" alt="Image file">
,  
is stored in <tt>edges(j)</tt>, <img width=146 height=10 src="img166.gif" alt="Image file">
.  
<P> 
  
<P> 
A single process is allowed to be defined multiple times in the list of  
neighbors of a process (i.e., there may be multiple edges between two  
processes). A process is also allowed to be a neighbor to itself (i.e., a self  
loop in the graph). The adjacency matrix is allowed to be non-symmetric.  
 
<br> 
<em> Advice to users.</em>  
 <P> 
Performance implications of using multiple edges or a non-symmetric  
adjacency matrix are not defined. The definition of a node-neighbor  
edge does not imply a direction of the communication.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The following topology information is likely to be stored with a communicator:  
<ul> 
 
<li>Type of topology (Cartesian/graph),  
 
<li>For a Cartesian topology:  
   <ol> 
    
1. <font face="sans-serif"> ndims</font> (number of dimensions),  
    
<br> 
2. <font face="sans-serif"> dims</font> (numbers of processes per coordinate direction),  
    
<br> 
3. <font face="sans-serif"> periods</font> (periodicity information),  
    
<br> 
4. <font face="sans-serif"> own_position</font> (own position in grid, could also be computed  
                          from rank and dims)  
   </ol> 
 
<li>For a graph topology:  
   <ol> 
    
1. <font face="sans-serif"> index</font>,  
    
<br> 
2. <font face="sans-serif"> edges</font>,  
   </ol> 
which are the vectors defining the graph structure.  
</ul> 
<br> 
For a graph structure the number of nodes is equal to the number of processes  
in the group. Therefore, the number of nodes does not have to be stored explicitly.  An  
additional zero entry at the start of array <font face="sans-serif"> index</font> simplifies  
access to the topology information.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node193.htm#Node193"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node191.htm#Node191"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node195.htm#Node195"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node191.htm#Node191"> Topology Constructors</a>
<b>Next: </b><a href="node195.htm#Node195"> Distributed Graph Constructor</a>
<b>Previous: </b><a href="node193.htm#Node193"> Cartesian Convenience Function: <font face="sans-serif"> MPI_DIMS_CREATE</font></a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
