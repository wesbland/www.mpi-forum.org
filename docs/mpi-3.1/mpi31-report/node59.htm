<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Buffer Allocation and Usage</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node59">54. Buffer Allocation and Usage</span></h1>
<a href="node58.htm#Node58"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node60.htm#Node60"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node60.htm#Node60"> Model Implementation of Buffered Mode</a>
<b>Previous: </b><a href="node58.htm#Node58"> Semantics of Point-to-Point Communication</a>
<p>
  
  
<P> 
A user may specify a buffer to be used for buffering messages sent in buffered  
mode.   Buffering is done by the sender.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BUFFER_ATTACH(buffer, size)</TD></TR>  
<TR><TD> IN buffer</TD><TD>initial buffer address (choice)</TD></TR>  
<TR><TD> IN size</TD><TD>buffer size, in bytes (non-negative   
integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Buffer_attach(void* buffer, int size) <br></tt>  
<P> 
 <tt> MPI_Buffer_attach(buffer, size, ierror) <br> TYPE(*), DIMENSION(..), ASYNCHRONOUS :: buffer <br>INTEGER, INTENT(IN) :: size <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_BUFFER_ATTACH(BUFFER, SIZE, IERROR)<br> &lt;type&gt; BUFFER(*) <br>INTEGER  SIZE, IERROR <br></tt>  
  
<P> 
Provides to <font face="sans-serif"> MPI</font> a buffer in the user's memory to be used for buffering outgoing  
messages.  The buffer is used only by messages sent in buffered mode.  
Only one buffer can be attached to a process at a time.  
In C, <font face="sans-serif"> buffer</font> is the starting address of a memory region.  
In Fortran, one can pass the first element of a memory region  
or a whole array, which must be `simply contiguous'   
(for `simply contiguous,' see also   
Section <a href="node422.htm#Node422">Problems Due to Data Copying and Sequence Association with Subscript Triplets 
</a>).  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BUFFER_DETACH(buffer_addr, size)</TD></TR>  
<TR><TD> OUT buffer_addr</TD><TD>initial buffer address (choice)</TD></TR>  
<TR><TD> OUT size</TD><TD>buffer size, in bytes (non-negative   
integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Buffer_detach(void* buffer_addr, int* size) <br></tt>  
<P> 
 <tt> MPI_Buffer_detach(buffer_addr, size, ierror) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(C_PTR), INTENT(OUT) :: buffer_addr <br>INTEGER, INTENT(OUT) :: size <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_BUFFER_DETACH(BUFFER_ADDR, SIZE, IERROR)<br> &lt;type&gt; BUFFER_ADDR(*) <br>INTEGER  SIZE, IERROR <br></tt>  
  
<P> 
Detach the buffer currently associated with <font face="sans-serif"> MPI</font>.  The call returns the  
address and the size of the detached buffer.  This operation  
will block until all messages currently in the buffer have been transmitted.  
Upon return of  
this function, the user may reuse or deallocate the space taken by the buffer.  
<P> 
<br><b> Example</b>  
  
  
  
Calls to attach and detach buffers.  
<br> 
<pre><tt>#define BUFFSIZE 10000 
int size; 
char *buff; 
MPI_Buffer_attach( malloc(BUFFSIZE), BUFFSIZE); 
/* a buffer of 10000 bytes can now be used by MPI_Bsend */ 
MPI_Buffer_detach( &amp;buff, &amp;size); 
/* Buffer size reduced to zero */ 
MPI_Buffer_attach( buff, size); 
/* Buffer of 10000 bytes available again */ 
</tt></pre> 
  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Even though the C functions  
<font face="sans-serif"> MPI_Buffer_attach</font> and <font face="sans-serif"> MPI_Buffer_detach</font> both have  
a first argument of type <font face="sans-serif"> void*</font>, these arguments are used  
differently: A pointer to the buffer is passed to <font face="sans-serif"> MPI_Buffer_attach</font>;  
the address of the pointer is passed to <font face="sans-serif"> MPI_Buffer_detach</font>, so that  
this call can return the pointer value.  
In Fortran with the <tt>mpi</tt> module or <tt>mpif.h</tt>, the type of the <font face="sans-serif"> buffer_addr</font> argument is  
wrongly defined and the argument is therefore unused.  
In Fortran with the <tt>mpi_f08</tt> module, the address of the buffer is returned  
as <tt> TYPE(C_PTR)</tt>, see also   
Example <a href="node216.htm#Node216">Memory Allocation 
</a>  
about the use of <tt> C_PTR</tt> pointers.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
Both arguments are defined to be of type <font face="sans-serif">  void*</font> (rather than  
<font face="sans-serif">  void*</font> and <font face="sans-serif">  void**</font>, respectively), so as to avoid complex type  
casts. E.g., in the last example, <font face="sans-serif"> &amp;buff</font>, which is of type  
<font face="sans-serif">  char**</font>, can be passed as argument to <font face="sans-serif"> MPI_Buffer_detach</font>  
without type casting.  If the formal parameter had type <font face="sans-serif"> void**</font> then we  
would need a type cast before and after the call.  
 (<em> End of rationale.</em>) <br> 
The statements made in this section describe the behavior of <font face="sans-serif"> MPI</font>  
for buffered-mode sends.  
When no buffer is currently associated, <font face="sans-serif"> MPI</font> behaves as if a  
zero-sized buffer is associated with the process.  
<P> 
<font face="sans-serif"> MPI</font> must provide as much buffering for outgoing messages <em> as if</em>  
outgoing message  
data were buffered by the sending process, in the specified buffer space,  
using a circular, contiguous-space allocation policy.  
We outline below a model implementation that defines this policy.  
<font face="sans-serif"> MPI</font> may provide more buffering, and may use a better buffer allocation  
algorithm  
than described below.  On the other hand, <font face="sans-serif"> MPI</font> may signal an error whenever the  
simple buffering allocator described below would run out of space.  In  
particular, if no buffer is explicitly associated with the process, then any  
buffered send may cause an error.  
<P> 
<font face="sans-serif"> MPI</font> does not provide mechanisms for querying or controlling buffering done by  
standard mode sends.   It is expected that vendors will provide such  
information  
for their implementations.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
There is a wide spectrum of possible implementations of buffered communication:  
buffering can be done at sender, at receiver, or both; buffers can be dedicated  
to one sender-receiver pair, or be shared by  
all communications; buffering can be done in real or  
in virtual memory; it can use dedicated memory, or memory shared by other  
processes; buffer space may be allocated statically or be changed dynamically;  
etc.   It does not seem feasible to provide a portable mechanism for querying  
or controlling buffering that would be compatible with all these choices, yet  
provide meaningful information.  
 (<em> End of rationale.</em>) <br> 
<ul> 
</ul> 

<P>
<hr>
<a href="node58.htm#Node58"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node60.htm#Node60"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node60.htm#Node60"> Model Implementation of Buffered Mode</a>
<b>Previous: </b><a href="node58.htm#Node58"> Semantics of Point-to-Point Communication</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
