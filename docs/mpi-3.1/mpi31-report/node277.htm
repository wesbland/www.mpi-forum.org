<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Request-based RMA Communication Operations</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node277">252. Request-based RMA Communication Operations</span></h2>
<a href="node272.htm#Node276"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node268.htm#Node268"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node278.htm#Node278"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node268.htm#Node268"> Communication Calls</a>
<b>Next: </b><a href="node278.htm#Node278"> Memory Model</a>
<b>Previous: </b><a href="node272.htm#Node276"> Compare and Swap Function</a>
<p>
  
  
<P> 
Request-based <font face="sans-serif"> RMA</font> communication operations allow the user to  
associate a request handle with the <font face="sans-serif"> RMA</font> operations and test or wait  
for the completion of these requests using the functions described in  
Section <a href="node64.htm#Node64">Communication Completion 
</a>. Request-based <font face="sans-serif"> RMA</font> operations  
are only valid within a passive target  
epoch (see Section <a href="node279.htm#Node279">Synchronization Calls 
</a>).   
<P> 
Upon returning from a completion call in which an <font face="sans-serif"> RMA</font> operation  
completes, the <font face="sans-serif">  MPI_ERROR</font> field in the associated status  
object is set appropriately (see Section <a href="node51.htm#Node51">Return Status 
</a>). All  
other fields of status and the results of status query functions (e.g.,  
<font face="sans-serif"> MPI_GET_COUNT</font>) are undefined. It is  
valid to mix different request types (e.g., any combination of <font face="sans-serif"> RMA</font>  
requests, collective requests, I/O requests, generalized requests, or  
point-to-point requests) in functions that enable multiple completions  
(e.g., <font face="sans-serif"> MPI_WAITALL</font>). It is erroneous to call  
<font face="sans-serif"> MPI_REQUEST_FREE</font> or <font face="sans-serif"> MPI_CANCEL</font> for a request  
associated with an <font face="sans-serif"> RMA</font> operation. <font face="sans-serif"> RMA</font> requests are not persistent.  
<P> 
The end of the epoch, or explicit bulk synchronization using  
<font face="sans-serif"> MPI_WIN_FLUSH</font>, <font face="sans-serif"> MPI_WIN_FLUSH_ALL</font>,  
<font face="sans-serif"> MPI_WIN_FLUSH_LOCAL</font>, or  
<font face="sans-serif"> MPI_WIN_FLUSH_LOCAL_ALL</font>, also indicates completion of  
the <font face="sans-serif"> RMA</font> operations. However, users must still wait or test on the  
<font face="sans-serif"> request</font> handle to allow the <font face="sans-serif"> MPI</font> implementation to clean up  
any resources associated with these requests; in such cases the wait  
operation will complete locally.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_RPUT(origin_addr, origin_count,  
    origin_datatype, target_rank, target_disp, target_count,  
    target_datatype, win, request)</TD></TR>   
<TR><TD> IN origin_addr</TD><TD>initial address of origin buffer (choice)</TD></TR>   
<TR><TD> IN origin_count</TD><TD>number of entries in origin buffer  
(non-negative integer)</TD></TR>  
<TR><TD> IN origin_datatype</TD><TD>datatype of each entry in origin buffer  
(handle)</TD></TR>  
<TR><TD> IN target_rank</TD><TD>rank of target (non-negative integer)</TD></TR>  
<TR><TD> IN target_disp</TD><TD>displacement from start of window to target  
buffer  
(non-negative integer)</TD></TR>  
<TR><TD> IN target_count</TD><TD>number of entries in target buffer  
(non-negative  
integer)</TD></TR>  
<TR><TD> IN target_datatype</TD><TD>datatype of each entry in target buffer  
(handle)</TD></TR>  
<TR><TD> IN win</TD><TD>window object used for communication (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>RMA request (handle)</TD></TR>  
<P> 
</TABLE>  
<P> 
 <tt> int MPI_Rput(const void *origin_addr, int origin_count, MPI_Datatype origin_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype, MPI_Win win, MPI_Request *request) <br></tt>  
<P> 
 <tt> MPI_Rput(origin_addr, origin_count, origin_datatype, target_rank, target_disp, target_count, target_datatype, win, request, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: origin_addr <br>INTEGER, INTENT(IN) :: origin_count, target_rank, target_count <br>TYPE(MPI_Datatype), INTENT(IN) :: origin_datatype, target_datatype <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp <br>TYPE(MPI_Win), INTENT(IN) :: win <br>TYPE(MPI_Request), INTENT(OUT) :: request <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_RPUT(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE, WIN, REQUEST, IERROR)<br> &lt;type&gt; ORIGIN_ADDR(*)<br>INTEGER(KIND=MPI_ADDRESS_KIND) TARGET_DISP <br>INTEGER ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_COUNT, TARGET_DATATYPE,  WIN, REQUEST, IERROR <br></tt>  
<P> 
<font face="sans-serif"> MPI_RPUT</font> is similar to <font face="sans-serif"> MPI_PUT</font>  
(Section <a href="node269.htm#Node269">Put 
</a>), except that it  
allocates a communication request object and associates it with the  
request handle (the argument <font face="sans-serif"> request</font>). The completion of an  
<font face="sans-serif"> MPI_RPUT</font> operation (i.e., after the corresponding test or wait) indicates that the sender is now free to  
update the locations in the origin buffer. It does not indicate that  
the data is available at the target window. If remote completion is  
required, <font face="sans-serif"> MPI_WIN_FLUSH</font>, <font face="sans-serif"> MPI_WIN_FLUSH_ALL</font>,  
<font face="sans-serif"> MPI_WIN_UNLOCK</font>, or  
<font face="sans-serif"> MPI_WIN_UNLOCK_ALL</font> can be used.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_RGET(origin_addr, origin_count,  
    origin_datatype, target_rank, target_disp, target_count, <br>  
    target_datatype, win, request)</TD></TR>   
<TR><TD> OUT origin_addr</TD><TD>initial address of origin buffer (choice)</TD></TR>   
<TR><TD> IN origin_count</TD><TD>number of entries in origin buffer  
(non-negative  
integer)</TD></TR>  
<TR><TD> IN origin_datatype</TD><TD>datatype of each entry in origin buffer  
(handle)</TD></TR>  
<TR><TD> IN target_rank</TD><TD>rank of target  
  (non-negative integer)</TD></TR>   
<TR><TD> IN target_disp</TD><TD>displacement from window start to the beginning  
of the target buffer (non-negative integer)</TD></TR>  
<TR><TD> IN target_count</TD><TD>number of entries in target buffer  
(non-negative integer)</TD></TR>  
<TR><TD> IN target_datatype</TD><TD>datatype of each entry in target buffer  
(handle)</TD></TR>  
<TR><TD> IN win</TD><TD>window object used for communication (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>RMA request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Rget(void *origin_addr, int origin_count, MPI_Datatype origin_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype, MPI_Win win, MPI_Request *request) <br></tt>  
<P> 
 <tt> MPI_Rget(origin_addr, origin_count, origin_datatype, target_rank, target_disp, target_count, target_datatype, win, request, ierror) <br> TYPE(*), DIMENSION(..), ASYNCHRONOUS :: origin_addr <br>INTEGER, INTENT(IN) :: origin_count, target_rank, target_count <br>TYPE(MPI_Datatype), INTENT(IN) :: origin_datatype, target_datatype <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp <br>TYPE(MPI_Win), INTENT(IN) :: win <br>TYPE(MPI_Request), INTENT(OUT) :: request <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_RGET(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE, WIN, REQUEST, IERROR)<br> &lt;type&gt; ORIGIN_ADDR(*) <br>INTEGER(KIND=MPI_ADDRESS_KIND) TARGET_DISP <br>INTEGER ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_COUNT, TARGET_DATATYPE, WIN, REQUEST, IERROR <br></tt>  
<P> 
<font face="sans-serif"> MPI_RGET</font> is similar to <font face="sans-serif"> MPI_GET</font>  
(Section <a href="node270.htm#Node270">Get 
</a>), except that it  
allocates a communication request object and associates it with the  
request handle (the argument <font face="sans-serif"> request</font>) that can be used to wait  
or test for completion. The completion of an <font face="sans-serif"> MPI_RGET</font>  
operation indicates that the data is available in the origin buffer. If  
<font face="sans-serif"> origin_addr</font> points to memory attached to a window, then the  
data becomes available in the private copy of this window.  
<P> 
<P><img width=371 height=299 src="img199.gif" alt="Image file"><P>
 <tt> int MPI_Raccumulate(const void *origin_addr, int origin_count, MPI_Datatype origin_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype, MPI_Op op, MPI_Win win, MPI_Request *request) <br></tt>  
<P> 
 <tt> MPI_Raccumulate(origin_addr, origin_count, origin_datatype, target_rank, target_disp, target_count, target_datatype, op, win, request, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: origin_addr <br>INTEGER, INTENT(IN) :: origin_count, target_rank, target_count <br>TYPE(MPI_Datatype), INTENT(IN) :: origin_datatype, target_datatype <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp <br>TYPE(MPI_Op), INTENT(IN) :: op <br>TYPE(MPI_Win), INTENT(IN) :: win <br>TYPE(MPI_Request), INTENT(OUT) :: request <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_RACCUMULATE(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE, OP, WIN, REQUEST, IERROR) <br> &lt;type&gt; ORIGIN_ADDR(*) <br>INTEGER(KIND=MPI_ADDRESS_KIND) TARGET_DISP <br>INTEGER ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_COUNT, TARGET_DATATYPE, OP, WIN, REQUEST, IERROR <br></tt>  
<P> 
<font face="sans-serif"> MPI_RACCUMULATE</font> is similar to <font face="sans-serif"> MPI_ACCUMULATE</font>  
(Section <a href="node272.htm#Node272">Accumulate Functions 
</a>),  
except that it allocates a communication request object and associates  
it with the request handle (the argument <font face="sans-serif"> request</font>) that can be  
used to wait or test for completion. The completion of an  
<font face="sans-serif"> MPI_RACCUMULATE</font> operation indicates that the origin buffer  
is free to be updated. It does not indicate that the operation has  
completed at the target window.  
<P> 
<P><img width=382 height=394 src="img200.gif" alt="Image file"><P>
 <tt> int MPI_Rget_accumulate(const void *origin_addr, int origin_count, MPI_Datatype origin_datatype, void *result_addr, int result_count, MPI_Datatype result_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype, MPI_Op op, MPI_Win win, MPI_Request *request) <br></tt>  
<P> 
 <tt> MPI_Rget_accumulate(origin_addr, origin_count, origin_datatype, result_addr, result_count, result_datatype, target_rank, target_disp, target_count, target_datatype, op, win, request, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: origin_addr <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: result_addr <br>INTEGER, INTENT(IN) :: origin_count, result_count, target_rank, target_count <br>TYPE(MPI_Datatype), INTENT(IN) :: origin_datatype, target_datatype, result_datatype <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp <br>TYPE(MPI_Op), INTENT(IN) :: op <br>TYPE(MPI_Win), INTENT(IN) :: win <br>TYPE(MPI_Request), INTENT(OUT) :: request <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_RGET_ACCUMULATE(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, RESULT_ADDR, RESULT_COUNT, RESULT_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE, OP, WIN, REQUEST, IERROR) <br> &lt;type&gt; ORIGIN_ADDR(*), RESULT_ADDR(*) <br>INTEGER(KIND=MPI_ADDRESS_KIND) TARGET_DISP <br>INTEGER ORIGIN_COUNT, ORIGIN_DATATYPE, RESULT_COUNT, RESULT_DATATYPE, TARGET_RANK, TARGET_COUNT, TARGET_DATATYPE, OP, WIN, REQUEST, IERROR <br></tt>  
<P> 
<font face="sans-serif"> MPI_RGET_ACCUMULATE</font> is similar to  
<font face="sans-serif"> MPI_GET_ACCUMULATE</font> (Section <a href="node272.htm#Node274">Get Accumulate Function 
</a>), except that it allocates a  
communication request object and associates it with the request handle  
(the argument <font face="sans-serif"> request</font>) that can be used to wait or test for  
completion. The completion of an <font face="sans-serif"> MPI_RGET_ACCUMULATE</font>  
operation indicates that the data is available in the result buffer  
and the origin buffer is free to be updated. It does not indicate that  
the operation has been completed at the target window.  
<P> 

<P>
<hr>
<a href="node272.htm#Node276"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node268.htm#Node268"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node278.htm#Node278"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node268.htm#Node268"> Communication Calls</a>
<b>Next: </b><a href="node278.htm#Node278"> Memory Model</a>
<b>Previous: </b><a href="node272.htm#Node276"> Compare and Swap Function</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
