<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-io/io-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Examples</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node349">314. Examples</span></h2>
<a href="node348.htm#Node348"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node338.htm#Node338"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node349.htm#Node350"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node338.htm#Node338"> Consistency and Semantics</a>
<b>Next: </b><a href="node349.htm#Node350"> Asynchronous I/O</a>
<b>Previous: </b><a href="node348.htm#Node348"> File Size</a>
<p>
  
<P> 
The examples in this section illustrate  
the application of the <font face="sans-serif"> MPI</font> consistency and semantics guarantees.  
These address  
<ul> 
 
<li>conflicting accesses on file handles obtained from a   
single collective open, and  
 
<li>all accesses on file handles obtained from two separate  
collective opens.  
</ul> 
<br> 
The simplest way to achieve consistency for conflicting accesses is  
to obtain sequential consistency by setting atomic mode.  
For the code below,  
process 1 will read either 0 or 10 integers.  
If the latter, every element of <tt> b</tt> will be <font face="sans-serif">  5</font>.  
If nonatomic mode is set, the results of the read are undefined.  
<br> 
<pre><tt>/* Process 0 */ 
int  i, a[10]; 
int  TRUE = 1; 
 
for ( i=0;i&lt;10;i++) 
   a[i] = 5; 
 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh0 ); 
MPI_File_set_view( fh0, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
MPI_File_set_atomicity( fh0, TRUE ); 
MPI_File_write_at(fh0, 0, a, 10, MPI_INT, &amp;status); 
/* MPI_Barrier( MPI_COMM_WORLD ); */ 
</tt></pre> 
<br> 
<pre><tt>/* Process 1 */ 
int  b[10]; 
int  TRUE = 1; 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh1 ); 
MPI_File_set_view( fh1, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
MPI_File_set_atomicity( fh1, TRUE ); 
/* MPI_Barrier( MPI_COMM_WORLD ); */ 
MPI_File_read_at(fh1, 0, b, 10, MPI_INT, &amp;status); 
</tt></pre> 
A user may guarantee that the write on process <font face="sans-serif">  0</font>  
precedes the read on process <font face="sans-serif">  1</font> by imposing temporal order  
with, for example, calls to <font face="sans-serif"> MPI_BARRIER</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Routines other than <font face="sans-serif"> MPI_BARRIER</font> may be used to impose   
temporal order.  In the example above, process 0 could use <font face="sans-serif"> MPI_SEND</font>  
to send a 0 byte message, received by process 1 using <font face="sans-serif"> MPI_RECV</font>.  
 (<em> End of advice to users.</em>) <br> 
Alternatively, a user can impose consistency with nonatomic mode set:  
<br> 
<pre><tt>/* Process 0 */ 
int  i, a[10]; 
for ( i=0;i&lt;10;i++) 
   a[i] = 5; 
 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh0 ); 
MPI_File_set_view( fh0, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
MPI_File_write_at(fh0, 0, a, 10, MPI_INT, &amp;status ); 
MPI_File_sync( fh0 ); 
MPI_Barrier( MPI_COMM_WORLD ); 
MPI_File_sync( fh0 ); 
</tt></pre> 
<br> 
<pre><tt>/* Process 1 */ 
int  b[10]; 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh1 ); 
MPI_File_set_view( fh1, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
MPI_File_sync( fh1 ); 
MPI_Barrier( MPI_COMM_WORLD ); 
MPI_File_sync( fh1 ); 
MPI_File_read_at(fh1, 0, b, 10, MPI_INT, &amp;status ); 
</tt></pre> 
The ``sync-barrier-sync'' construct is required because:  
<ul> 
 
<li>The barrier ensures that the write on process 0 occurs  
before the read on process 1.  
 
<li>The first sync guarantees that the data written by all  
processes is transferred to the storage device.    
 
<li>The second sync guarantees that all data which has been  
transferred to the storage device is visible to all processes.  
(This does not affect process 0 in this example.)  
</ul> 
<br> 
The following program represents an erroneous attempt to achieve consistency  
by eliminating the apparently superfluous second ``sync'' call for  
each process.  
<br> 
<pre><tt>/* ----------------  THIS EXAMPLE IS ERRONEOUS --------------- */ 
/* Process 0 */ 
int  i, a[10]; 
for ( i=0;i&lt;10;i++) 
   a[i] = 5; 
 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh0 ); 
MPI_File_set_view( fh0, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
MPI_File_write_at(fh0, 0, a, 10, MPI_INT, &amp;status ); 
MPI_File_sync( fh0 ); 
MPI_Barrier( MPI_COMM_WORLD ); 
</tt></pre> 
<br> 
<pre><tt>/* Process 1 */ 
int  b[10]; 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh1 ); 
MPI_File_set_view( fh1, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
MPI_Barrier( MPI_COMM_WORLD ); 
MPI_File_sync( fh1 ); 
MPI_File_read_at(fh1, 0, b, 10, MPI_INT, &amp;status ); 
 
/* ----------------  THIS EXAMPLE IS ERRONEOUS --------------- */ 
</tt></pre> 
The above program also violates the <font face="sans-serif"> MPI</font> rule  
against out-of-order collective operations  
and  
will deadlock for implementations in which <font face="sans-serif"> MPI_FILE_SYNC</font> blocks.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Some implementations may choose to implement <font face="sans-serif"> MPI_FILE_SYNC</font>  
as a temporally synchronizing function.  When using such an  
implementation, the ``sync-barrier-sync'' construct above can  
be replaced by a single ``sync.''  The results of using such  
code with an implementation for which <font face="sans-serif"> MPI_FILE_SYNC</font> is not  
temporally synchronizing is undefined.  
 (<em> End of advice to users.</em>) <br> 
<ul> 
</ul> 

<P>
<hr>
<a href="node348.htm#Node348"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node338.htm#Node338"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node349.htm#Node350"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node338.htm#Node338"> Consistency and Semantics</a>
<b>Next: </b><a href="node349.htm#Node350"> Asynchronous I/O</a>
<b>Previous: </b><a href="node348.htm#Node348"> File Size</a>
<p>
<hr><h3><span id="Node350">314.1. Asynchronous I/O</span></h3>
<a href="node349.htm#Node349"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node349.htm#Node349"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node351.htm#Node351"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node349.htm#Node349"> Examples</a>
<b>Next: </b><a href="node351.htm#Node351"> I/O Error Handling</a>
<b>Previous: </b><a href="node349.htm#Node349"> Examples</a>
<p>
The behavior of asynchronous I/O operations is determined by  
applying the rules specified above for synchronous I/O operations.  
<P> 
The following examples all access a preexisting file ``<tt>myfile</tt>.''  
Word <font face="sans-serif">  10</font> in myfile initially contains the integer <font face="sans-serif">  2</font>.  
Each example writes and reads word <font face="sans-serif">  10</font>.  
<P> 
First consider the following code fragment:  
<br> 
<pre><tt>int a = 4, b, TRUE=1; 
MPI_File_open( MPI_COMM_WORLD, "myfile",  
               MPI_MODE_RDWR, MPI_INFO_NULL, &amp;fh ); 
MPI_File_set_view( fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
/* MPI_File_set_atomicity( fh, TRUE );   Use this to set atomic mode. */ 
MPI_File_iwrite_at(fh, 10, &amp;a, 1, MPI_INT, &amp;reqs[0]); 
MPI_File_iread_at(fh,  10, &amp;b, 1, MPI_INT, &amp;reqs[1]); 
MPI_Waitall(2, reqs, statuses);  
</tt></pre> 
For asynchronous data access operations, <font face="sans-serif"> MPI</font> specifies   
that the access occurs at any time between the call to the asynchronous   
data access routine and the return from the corresponding   
request complete routine.  
Thus, executing either the read before the write,  
or the write before the read is consistent with program order.  
If atomic mode is set, then <font face="sans-serif"> MPI</font> guarantees sequential   
consistency, and the program will read either <font face="sans-serif">  2</font> or   
<font face="sans-serif">  4</font> into <tt> b</tt>.    
If atomic mode is not set, then sequential consistency is not   
guaranteed and the program may read something other than <font face="sans-serif">  2</font>   
or <font face="sans-serif">  4</font> due to the conflicting data access.  
<P> 
Similarly, the following code fragment does not order file accesses:  
<br> 
<pre><tt>int a = 4, b; 
MPI_File_open( MPI_COMM_WORLD, "myfile",  
               MPI_MODE_RDWR, MPI_INFO_NULL, &amp;fh ); 
MPI_File_set_view( fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
/* MPI_File_set_atomicity( fh, TRUE );   Use this to set atomic mode. */ 
MPI_File_iwrite_at(fh, 10, &amp;a, 1, MPI_INT, &amp;reqs[0]); 
MPI_File_iread_at(fh,  10, &amp;b, 1, MPI_INT, &amp;reqs[1]); 
MPI_Wait(&amp;reqs[0], &amp;status); 
MPI_Wait(&amp;reqs[1], &amp;status); 
</tt></pre> 
If atomic mode is set, either <font face="sans-serif">  2</font> or <font face="sans-serif">  4</font> will be read   
into <tt> b</tt>.  Again, <font face="sans-serif"> MPI</font> does not guarantee sequential consistency  
in nonatomic mode.  
<P> 
On the other hand, the following code fragment:  
<br> 
<pre><tt>int a = 4, b; 
MPI_File_open( MPI_COMM_WORLD, "myfile",  
               MPI_MODE_RDWR, MPI_INFO_NULL, &amp;fh ); 
MPI_File_set_view( fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
MPI_File_iwrite_at(fh, 10, &amp;a, 1, MPI_INT, &amp;reqs[0]); 
MPI_Wait(&amp;reqs[0], &amp;status); 
MPI_File_iread_at(fh,  10, &amp;b, 1, MPI_INT, &amp;reqs[1]); 
MPI_Wait(&amp;reqs[1], &amp;status); 
</tt></pre> 
defines the same ordering as:  
<br> 
<pre><tt>int a = 4, b; 
MPI_File_open( MPI_COMM_WORLD, "myfile",  
               MPI_MODE_RDWR, MPI_INFO_NULL, &amp;fh ); 
MPI_File_set_view( fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ); 
MPI_File_write_at(fh, 10, &amp;a, 1, MPI_INT, &amp;status ); 
MPI_File_read_at(fh,  10, &amp;b, 1, MPI_INT, &amp;status ); 
</tt></pre> 
Since  
<ul> 
 
<li>nonconcurrent operations on a single file handle are sequentially consistent, and  
 
<li>the program fragments specify an order for the operations,  
</ul> 
<br> 
<font face="sans-serif"> MPI</font> guarantees that both program fragments will read the value   
<font face="sans-serif">  4</font> into  
<tt> b</tt>.  There is no need to set atomic mode for this example.  
<P> 
Similar considerations apply to conflicting accesses of the form:  
<br> 
<pre><tt>MPI_File_iwrite_all(fh,...); 
MPI_File_iread_all(fh,...); 
MPI_Waitall(...); 
</tt></pre> 
In addition, as mentioned in Section <a href="node343.htm#Node343">Nonblocking Collective File Operations 
</a>,  
nonblocking collective I/O  
operations have to be called in the same order on the file handle by all  
processes.  
<P> 
Similar considerations apply to conflicting accesses of the form:  
<br> 
<pre><tt>MPI_File_write_all_begin(fh,...); 
MPI_File_iread(fh,...); 
MPI_Wait(fh,...); 
MPI_File_write_all_end(fh,...); 
</tt></pre> 
Recall that constraints governing consistency and semantics are not  
relevant to the following:  
<br> 
<pre><tt>MPI_File_write_all_begin(fh,...); 
MPI_File_read_all_begin(fh,...); 
MPI_File_read_all_end(fh,...); 
MPI_File_write_all_end(fh,...); 
</tt></pre> 
since split collective operations on the same file handle may not overlap  
(see Section <a href="node330.htm#Node330">Split Collective Data Access Routines 
</a>).  
<P> 

<P>
<hr>
<a href="node349.htm#Node349"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node349.htm#Node349"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node351.htm#Node351"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node349.htm#Node349"> Examples</a>
<b>Next: </b><a href="node351.htm#Node351"> I/O Error Handling</a>
<b>Previous: </b><a href="node349.htm#Node349"> Examples</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
