<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Problems with Code Movement and Register Optimization</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node427">371. Problems with Code Movement and Register Optimization</span></h2>
<a href="node426.htm#Node426"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node428"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node427.htm#Node428"> Nonblocking Operations</a>
<b>Previous: </b><a href="node426.htm#Node426"> Optimization Problems, an Overview</a>
<p>
  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node426.htm#Node426"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node428"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node427.htm#Node428"> Nonblocking Operations</a>
<b>Previous: </b><a href="node426.htm#Node426"> Optimization Problems, an Overview</a>
<p>
<hr><h3><span id="Node428">371.1. Nonblocking Operations</span></h3>
<a href="node427.htm#Node427"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node429"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node429"> Persistent Operations</a>
<b>Previous: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<p>
  
<P> 
If a variable is local to a Fortran subroutine (i.e., not in  
a module or a <tt>COMMON</tt> block), the compiler will assume that it cannot be modified  
by a called subroutine unless it is an actual argument of the  
call.  In the most common linkage convention, the subroutine is  
expected to save and restore certain registers. Thus, the optimizer  
will assume that a register which held a valid copy of such a  
variable before the call will still hold a valid copy on return.  
 <P> 
<br><b> Example</b>  
Fortran 90 register optimization --- extreme.   
   
  
<br>   
Source compiled as or compiled as  
  
<br> 
<pre><tt>REAL :: buf, b1            REAL :: buf, b1            REAL :: buf, b1 
call MPI_IRECV(buf,..req)  call MPI_IRECV(buf,..req)  call MPI_IRECV(buf,..req) 
                           register = buf             b1 = buf 
call MPI_WAIT(req,..)      call MPI_WAIT(req,..)      call MPI_WAIT(req,..) 
b1 = buf                   b1 = register 
</tt></pre> 
  
Example <a href="node426.htm#Equation20">0 
</a>   
shows extreme, but allowed, possibilities.  
<font face="sans-serif"> MPI_WAIT</font> on a concurrent thread modifies <font face="sans-serif"> buf</font>  
between the invocation of <font face="sans-serif"> MPI_IRECV</font> and the completion of  
<font face="sans-serif"> MPI_WAIT</font>.  But the compiler cannot see any possibility that  
<font face="sans-serif"> buf</font> can be changed after <font face="sans-serif"> MPI_IRECV</font> has returned,   
and may schedule the load of <font face="sans-serif"> buf</font> earlier than  
typed in the source. The compiler has no reason to avoid using a register to  
hold <font face="sans-serif"> buf</font> across the call to <font face="sans-serif"> MPI_WAIT</font>.  It also  
may reorder the instructions as illustrated in the rightmost column.   
<P> 
<br><b> Example</b>  
Similar example with <font face="sans-serif"> MPI_ISEND</font>  
   
  
<br>   
Source compiled as with a possible <font face="sans-serif"> MPI</font>-internal <br>  
execution sequence  
  
<br> 
<pre><tt>REAL :: buf, copy          REAL :: buf, copy          REAL :: buf, copy 
buf = val                  buf = val                  buf = val 
call MPI_ISEND(buf,..req)  call MPI_ISEND(buf,..req)  addr = &amp;buf 
copy = buf                 copy= buf                  copy = buf 
                           buf = val_overwrite        buf = val_overwrite 
call MPI_WAIT(req,..)      call MPI_WAIT(req,..)      call send(*addr) ! within 
                                                                       ! MPI_WAIT 
buf = val_overwrite 
</tt></pre> 
  
Due to valid compiler code movement optimizations in Example <a href="node426.htm#Equation20">0 
</a>,   
the content of <font face="sans-serif"> buf</font> may already have been overwritten by the compiler  
when the content of <font face="sans-serif"> buf</font> is sent.  
The code movement is permitted because the compiler cannot detect a possible access  
to <font face="sans-serif"> buf</font> in <font face="sans-serif"> MPI_WAIT</font> (or in a second thread between   
the start of <font face="sans-serif"> MPI_ISEND</font> and the end of <font face="sans-serif"> MPI_WAIT</font>).  
<P> 
Such register optimization is based on moving code; here, the access to <font face="sans-serif"> buf</font>  
was moved from after <font face="sans-serif"> MPI_WAIT</font> to before <font face="sans-serif"> MPI_WAIT</font>.   
Note that code movement may also occur across subroutine boundaries when  
subroutines or functions are inlined.  
<P> 
This register optimization/code movement problem for nonblocking operations does not occur  
with <font face="sans-serif"> MPI</font> parallel file I/O split collective operations,  
because in the <font face="sans-serif"> ..._BEGIN</font> and <font face="sans-serif"> ..._END</font> calls,  
the same buffer has to be provided as an actual argument.  
The register optimization / code movement problem for <font face="sans-serif">  MPI_BOTTOM</font>  
and derived <font face="sans-serif"> MPI</font> datatypes may occur in each blocking and nonblocking   
communication call, as well as in each parallel file I/O operation.  
<P> 

<P>
<hr>
<a href="node427.htm#Node427"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node429"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node429"> Persistent Operations</a>
<b>Previous: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<p>
<hr><h3><span id="Node429">371.2. Persistent Operations</span></h3>
<a href="node427.htm#Node428"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node430"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node430"> One-sided Communication</a>
<b>Previous: </b><a href="node427.htm#Node428"> Nonblocking Operations</a>
<p>
  
<P> 
With persistent requests, the buffer argument is hidden from the  
<font face="sans-serif"> MPI_START</font> and <font face="sans-serif"> MPI_STARTALL</font> calls, i.e., the  
Fortran compiler may move buffer accesses across the  
<font face="sans-serif"> MPI_START</font> or <font face="sans-serif"> MPI_STARTALL</font> call, similar to the  
<font face="sans-serif"> MPI_WAIT</font> call as described in the Nonblocking Operations  
subsection in Section <a href="node427.htm#Node427">Problems with Code Movement and Register Optimization 
</a>.  
 <P> 

<P>
<hr>
<a href="node427.htm#Node428"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node430"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node430"> One-sided Communication</a>
<b>Previous: </b><a href="node427.htm#Node428"> Nonblocking Operations</a>
<p>
<hr><h3><span id="Node430">371.3. One-sided Communication</span></h3>
<a href="node427.htm#Node429"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node431"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node431"> MPI_BOTTOM and Combining Independent Variables in Datatypes</a>
<b>Previous: </b><a href="node427.htm#Node429"> Persistent Operations</a>
<p>
  
<P> 
An example with instruction reordering due to register optimization can be found  
in Section <a href="node293.htm#Node293">Registers and Compiler Optimizations 
</a>.  
 <P> 

<P>
<hr>
<a href="node427.htm#Node429"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node431"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node431"> MPI_BOTTOM and Combining Independent Variables in Datatypes</a>
<b>Previous: </b><a href="node427.htm#Node429"> Persistent Operations</a>
<p>
<hr><h3><span id="Node431">371.4. MPI_BOTTOM and Combining Independent Variables in Datatypes</span></h3>
<a href="node427.htm#Node430"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node432"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node432"> Solutions</a>
<b>Previous: </b><a href="node427.htm#Node430"> One-sided Communication</a>
<p>
This section is only relevant if the <font face="sans-serif"> MPI</font> program uses    
a buffer argument to an <font face="sans-serif"> MPI_SEND</font>, <font face="sans-serif"> MPI_RECV</font>,  
etc., that hides the actual  
variables involved in the communication.  
<font face="sans-serif">  MPI_BOTTOM</font> with an  
<font face="sans-serif"> MPI_Datatype</font> containing <em> absolute addresses</em> is one example.  Creating  
a datatype which uses one variable as an anchor and brings along  
others by using <font face="sans-serif"> MPI_GET_ADDRESS</font> to determine their offsets from  
the anchor is another. The anchor variable would be the only one  
referenced in the call. Also attention must be paid if <font face="sans-serif"> MPI</font> operations  
are used that run in parallel with the user's application.  
<P> 
Example <a href="node426.htm#Equation20">0 
</a>   
shows what Fortran compilers are allowed to do.  
<P> 
<br><b> Example</b>  
Fortran 90 register optimization.  
   
  
<br>   
This source <i>...</i> can be compiled as:  
<br> 
<pre><tt>call MPI_GET_ADDRESS(buf,bufaddr,       call MPI_GET_ADDRESS(buf,...) 
               ierror) 
call MPI_TYPE_CREATE_STRUCT(1,1,        call MPI_TYPE_CREATE_STRUCT(...) 
               bufaddr, 
               MPI_REAL,type,ierror) 
call MPI_TYPE_COMMIT(type,ierror)       call MPI_TYPE_COMMIT(...) 
val_old = buf                           register = buf 
                                        val_old = register 
call MPI_RECV(MPI_BOTTOM,1,type,...)    call MPI_RECV(MPI_BOTTOM,...) 
val_new = buf                           val_new = register 
</tt></pre> 
  
In Example <a href="node426.htm#Equation20">0 
</a>, the  
compiler does not invalidate the register because it cannot  
see that <font face="sans-serif"> MPI_RECV</font> changes the value of <font face="sans-serif"> buf</font>.  
The access to <font face="sans-serif"> buf</font> is hidden by the use of  
<font face="sans-serif"> MPI_GET_ADDRESS</font> and <font face="sans-serif">  MPI_BOTTOM</font>.  
 <P> 
<br><b> Example</b>  
Similar example with <font face="sans-serif"> MPI_SEND</font>  
   
  
<br>   
This source <i>...</i> can be compiled as:  
<br> 
<pre><tt>! buf contains val_old                  ! buf contains val_old 
buf = val_new                            
call MPI_SEND(MPI_BOTTOM,1,type,...)    call MPI_SEND(...) 
! with buf as a displacement in type    ! i.e. val_old is sent 
                                        ! 
                                        ! buf=val_new  is moved to here 
                                        ! and detected as dead code 
                                        ! and therefore removed 
                                        ! 
buf = val_overwrite                     buf = val_overwrite 
</tt></pre> 
  
In Example <a href="node427.htm#Equation0">0 
</a>,   
several successive assignments to the same variable <font face="sans-serif"> buf</font> can be combined in a way  
such that only the last assignment is executed.  
``Successive'' means that no interfering load access to this variable occurs between the assignments.  
The compiler cannot detect that the call to <font face="sans-serif"> MPI_SEND</font> statement is interfering  
because the load access to <font face="sans-serif"> buf</font> is hidden by the usage of <font face="sans-serif">  MPI_BOTTOM</font>.  
<P> 

<P>
<hr>
<a href="node427.htm#Node430"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node432"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node432"> Solutions</a>
<b>Previous: </b><a href="node427.htm#Node430"> One-sided Communication</a>
<p>
<hr><h3><span id="Node432">371.5. Solutions</span></h3>
<a href="node427.htm#Node431"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node433"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node433"> The Fortran ASYNCHRONOUS Attribute</a>
<b>Previous: </b><a href="node427.htm#Node431"> MPI_BOTTOM and Combining Independent Variables in Datatypes</a>
<p>
    
 <P> 
The following sections show in detail how the problems   
with code movement and register optimization can be  
portably solved.  
Application writers can partially or fully avoid these compiler optimization problems  
by using one or more of the special Fortran declarations with  
the send and receive buffers used in nonblocking operations, or in operations  
in which <font face="sans-serif">  MPI_BOTTOM</font> is used, or if datatype handles that combine several variables are used:  
<ul> 
 
<li>Use of the Fortran <tt> ASYNCHRONOUS</tt> attribute.  
 
<li>Use of the helper routine <font face="sans-serif"> MPI_F_SYNC_REG</font>,  
      or an equivalent user-written dummy routine.  
 
<li>Declare the buffer as a Fortran module variable or within a Fortran common block.  
 
<li>Use of the Fortran <tt> VOLATILE</tt> attribute.  
</ul> 
<br> 
<br><b> Example</b>  
Protecting nonblocking communication with the <tt> ASYNCHRONOUS</tt> attribute.  
  
  
<br> 
<pre><tt>USE mpi_f08  
REAL, ASYNCHRONOUS :: b(0:101) ! elements 0 and 101 are halo cells 
REAL :: bnew(0:101)            ! elements 1 and 100 are newly computed 
TYPE(MPI_Request) :: req(4) 
INTEGER :: left, right, i 
CALL MPI_Cart_shift(...,left,right,...) 
CALL MPI_Irecv(b(  0), ..., left,  ..., req(1), ...) 
CALL MPI_Irecv(b(101), ..., right, ..., req(2), ...) 
CALL MPI_Isend(b(  1), ..., left,  ..., req(3), ...) 
CALL MPI_Isend(b(100), ..., right, ..., req(4), ...) 
  
#ifdef WITHOUT_OVERLAPPING_COMMUNICATION_AND_COMPUTATION 
! Case (a) 
  CALL MPI_Waitall(4,req,...) 
  DO i=1,100 ! compute all new local data 
    bnew(i) = function(b(i-1), b(i), b(i+1))  
  END DO 
#endif  
  
#ifdef WITH_OVERLAPPING_COMMUNICATION_AND_COMPUTATION 
! Case (b) 
  DO i=2,99  ! compute  only elements for which halo data is not needed 
    bnew(i) = function(b(i-1), b(i), b(i+1))  
  END DO 
  CALL MPI_Waitall(4,req,...) 
  i=1 ! compute leftmost element  
    bnew(i) = function(b(i-1), b(i), b(i+1))  
  i=100 ! compute rightmost element  
    bnew(i) = function(b(i-1), b(i), b(i+1))  
#endif  
</tt></pre> 
  
Each of these methods solves the problems of code movement and register optimization,   
but may incur various degrees of performance impact,   
and may not be usable in every application context.  
These methods may not be guaranteed by the Fortran standard,  
but they must be guaranteed by a <font face="sans-serif"> MPI-3.0</font> (and later) compliant   
<font face="sans-serif"> MPI</font> library and associated compiler   
suite according to the requirements  
listed in Section <a href="node414.htm#Node414">Requirements on Fortran Compilers 
</a>.  
The performance impact of using <font face="sans-serif"> MPI_F_SYNC_REG</font> is  
expected to be low, that of using module variables or the  
<tt> ASYNCHRONOUS</tt> attribute is expected to be low to medium, and  
that of using the <tt> VOLATILE</tt> attribute is expected to be high or  
very high.  
Note that there is one attribute that cannot be used for this purpose:   
the Fortran <tt> TARGET</tt> attribute does not solve   
code movement problems in <font face="sans-serif"> MPI</font> applications.  
<P> 

<P>
<hr>
<a href="node427.htm#Node431"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node433"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node433"> The Fortran ASYNCHRONOUS Attribute</a>
<b>Previous: </b><a href="node427.htm#Node431"> MPI_BOTTOM and Combining Independent Variables in Datatypes</a>
<p>
<hr><h3><span id="Node433">371.6. The Fortran ASYNCHRONOUS Attribute</span></h3>
<a href="node427.htm#Node432"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node434"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node434"> Calling MPI_F_SYNC_REG</a>
<b>Previous: </b><a href="node427.htm#Node432"> Solutions</a>
<p>
  
  
<P> 
Declaring an actual buffer argument with the <tt> ASYNCHRONOUS</tt>   
Fortran attribute in a scoping unit (or <tt> BLOCK</tt>)  
informs the compiler that any statement in the scoping unit may be executed while the buffer  
is affected by a pending asynchronous Fortran input/output operation (since Fortran 2003)   
or by an asynchronous communication (TS 29113 extension).  
Without the extensions specified in TS 29113, a Fortran compiler may totally ignore this  
attribute if the Fortran compiler implements asynchronous Fortran input/output operations  
with blocking I/O.  
The <tt> ASYNCHRONOUS</tt> attribute protects the buffer accesses  
from optimizations through code movements across routine calls,   
and the buffer itself from temporary and permanent data movements.  
If the choice buffer dummy argument of a nonblocking <font face="sans-serif"> MPI</font> routine is declared  
with <tt> ASYNCHRONOUS</tt>   
(which is mandatory for the <tt>mpi_f08</tt> module, with allowable exceptions listed in   
Section <a href="node413.htm#Node413"><font face="sans-serif"> MPI</font> for Different Fortran Standard Versions 
</a>),  
then the compiler has to guarantee call by reference  
and should report a compile-time error if call by reference is  
impossible, e.g., if vector subscripts are used.  
The <font face="sans-serif">  MPI_ASYNC_PROTECTS_NONBLOCKING</font> is set to <tt> .TRUE.</tt>  
if both the protection of the actual buffer argument through   
<tt> ASYNCHRONOUS</tt> according to the TS 29113 extension  
and the declaration of the dummy argument with <tt> ASYNCHRONOUS</tt>  
in the Fortran support method is guaranteed for all nonblocking routines,  
otherwise it is set to <tt> .FALSE.</tt>.  
<P> 
The <tt> ASYNCHRONOUS</tt> attribute has some restrictions.   
Section 5.4.2 of the TS 29113 specifies:  
<QUOTE>   
``Asynchronous communication for a Fortran variable occurs through the action of procedures defined by means  
other than Fortran. It is initiated by execution of an asynchronous communication initiation procedure and  
completed by execution of an asynchronous communication completion procedure. Between the execution of the  
initiation and completion procedures, any variable of which any part is associated with any part of the   
asynchronous communication variable is a pending communication affector. Whether a procedure is an asynchronous  
communication initiation or completion procedure is processor dependent.  
<P> 
Asynchronous communication is either input communication or output communication. For input communication,  
a pending communication affector shall not be referenced, become defined, become undefined, become associated  
with a dummy argument that has the VALUE attribute, or have its pointer association status changed. For  
output communication, a pending communication affector shall not be redefined, become undefined, or have its  
pointer association status changed.''  
</QUOTE>  
 <P> 
In Example <a href="node427.htm#Equation0">0 
</a> Case (a) on page <a href="node427.htm#Equation0">0 
</a>,  
the read accesses to <tt>b</tt> within <tt>function(b(i-1), b(i), b(i+1))</tt>  
cannot be moved by compiler optimizations to before the wait call   
because <tt>b</tt> was declared as <tt> ASYNCHRONOUS</tt>.  
Note that only the elements 0, 1, 100, and 101 of <tt>b</tt> are  
involved in asynchronous communication but by definition,  
the total variable <tt>b</tt> is the pending communication affector  
and is usable for input and output asynchronous communication  
between the <tt> MPI_I...</tt> routines and <tt> MPI_Waitall</tt>.  
Case (a) works fine because the read accesses to <tt>b</tt>  
occur after the communication has completed.  
<P> 
In Case (b), the read accesses to <tt>b(1:100)</tt> in the loop <tt>i=2,99</tt>  
are read accesses to a pending communication affector while   
input communication (i.e., the two <tt>MPI_Irecv</tt> calls)  
is pending.  
This is a contradiction to the rule that   
<em> for input communication,  
a pending communication affector shall not be referenced</em>.  
The problem can be solved by using separate variables for the halos  
and the inner array,   
or by splitting a common array into disjoint subarrays which are  
passed through different dummy arguments into a subroutine, as shown   
in Example <a href="node427.htm#Equation0">0 
</a>.  
<P> 
If one does not overlap communication and computation on the same  
variable, then all optimization problems can be solved  
through the <tt> ASYNCHRONOUS</tt> attribute.  
<P> 
The problems with <font face="sans-serif">  MPI_BOTTOM</font>, as shown in   
Example <a href="node426.htm#Equation20">0 
</a> and Example <a href="node427.htm#Equation0">0 
</a>,  
can also be solved by declaring the buffer <tt>buf</tt> with the   
<tt> ASYNCHRONOUS</tt> attribute.  
 <P> 
In some <font face="sans-serif"> MPI</font> routines, a buffer dummy argument is defined as <tt> ASYNCHRONOUS</tt> to  
guarantee passing by reference, provided that the actual argument is also defined as  
<tt> ASYNCHRONOUS</tt>.   
<P> 

<P>
<hr>
<a href="node427.htm#Node432"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node434"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node434"> Calling MPI_F_SYNC_REG</a>
<b>Previous: </b><a href="node427.htm#Node432"> Solutions</a>
<p>
<hr><h3><span id="Node434">371.7. Calling MPI_F_SYNC_REG</span></h3>
<a href="node427.htm#Node433"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node435"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node435"> A User Defined Routine Instead of MPI_F_SYNC_REG</a>
<b>Previous: </b><a href="node427.htm#Node433"> The Fortran ASYNCHRONOUS Attribute</a>
<p>
    
<P> 
The compiler may be prevented from moving a reference to a buffer  
across a call to an <font face="sans-serif"> MPI</font> subroutine by surrounding the call by calls to  
an external subroutine with the buffer as an actual argument.   
The <font face="sans-serif"> MPI</font> library provides the <font face="sans-serif"> MPI_F_SYNC_REG</font> routine for this purpose;   
see Section <a href="node415.htm#Node415">Additional Support for Fortran Register-Memory-Synchronization 
</a>.   
<P> 
<ul> 
 
<li>The problems illustrated by the   
   Examples <a href="node426.htm#Equation20">0 
</a> and <a href="node426.htm#Equation20">0 
</a>  
   can be solved by calling <font face="sans-serif"> MPI_F_SYNC_REG(buf)</font>   
   once immediately after <font face="sans-serif"> MPI_WAIT</font>.  
<P> 
<P><img width=361 height=103 src="img219.gif" alt="Image file"><P>
The call to <font face="sans-serif"> MPI_F_SYNC_REG(buf)</font> prevents moving the last line  
  before the <font face="sans-serif"> MPI_WAIT</font> call.  
  Further calls to <font face="sans-serif"> MPI_F_SYNC_REG(buf)</font> are not needed  
  because it is still correct if the additional read access <tt>copy=buf</tt>  
  is moved below <font face="sans-serif"> MPI_WAIT</font> and before <tt>buf=val_overwrite</tt>.  
<P> 
 
<li>The problems illustrated by the   
   Examples <a href="node426.htm#Equation20">0 
</a> and <a href="node427.htm#Equation0">0 
</a>   
   can be solved with two additional <font face="sans-serif"> MPI_F_SYNC_REG(buf)</font>   
   statements;  
   one directly before <font face="sans-serif"> MPI_RECV</font>/<font face="sans-serif"> MPI_SEND</font>,  
   and one directly after this communication operation.  
<P> 
<P><img width=384 height=63 src="img220.gif" alt="Image file"><P>
The first call to <font face="sans-serif"> MPI_F_SYNC_REG(buf)</font>   
  is needed to finish all load and store  
  references to <font face="sans-serif"> buf</font> prior to  <font face="sans-serif"> MPI_RECV</font>/<font face="sans-serif"> MPI_SEND</font>;  
  the second call is needed to assure that any subsequent  
  access to <font face="sans-serif"> buf</font> is not moved before <font face="sans-serif"> MPI_RECV</font>/<font face="sans-serif"> SEND</font>.  
<P> 
 
<li>In the example in Section <a href="node293.htm#Node293">Registers and Compiler Optimizations 
</a>,  
   two asynchronous accesses must be protected:  
   in Process 1, the access to <font face="sans-serif"> bbbb</font> must be protected   
   similar to Example <a href="node426.htm#Equation20">0 
</a>, i.e.,  
   a call to <font face="sans-serif"> MPI_F_SYNC_REG(bbbb)</font> is needed   
   after the second <font face="sans-serif"> MPI_WIN_FENCE</font> to guarantee that  
   further accesses to <font face="sans-serif"> bbbb</font> are not moved  
   ahead of the call to <font face="sans-serif"> MPI_WIN_FENCE</font>.  
   In Process 2, both calls to <font face="sans-serif"> MPI_WIN_FENCE</font> together  
   act as a communication call with <font face="sans-serif">  MPI_BOTTOM</font> as the buffer.  
   That is, before the first fence and after the second fence,  
   a call to <font face="sans-serif"> MPI_F_SYNC_REG(buff)</font> is needed  
   to guarantee that accesses to <font face="sans-serif"> buff</font> are not moved  
   after or ahead of the calls to <font face="sans-serif"> MPI_WIN_FENCE</font>.  
   Using <font face="sans-serif"> MPI_GET</font> instead of <font face="sans-serif"> MPI_PUT</font>,   
   the same calls to <font face="sans-serif"> MPI_F_SYNC_REG</font> are necessary.  
<P> 
<tt><P><img width=317 height=132 src="img221.gif" alt="Image file"><P>
</tt>  
<P> 
 
<li>The temporary memory modification problem, i.e.,   
      Example <a href="node427.htm#Equation0">0 
</a>,  
      can <b> not</b> be solved with this method.  
</ul> 
<br> 

<P>
<hr>
<a href="node427.htm#Node433"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node435"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node435"> A User Defined Routine Instead of MPI_F_SYNC_REG</a>
<b>Previous: </b><a href="node427.htm#Node433"> The Fortran ASYNCHRONOUS Attribute</a>
<p>
<hr><h3><span id="Node435">371.8. A User Defined Routine Instead of MPI_F_SYNC_REG</span></h3>
<a href="node427.htm#Node434"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node436"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node436"> Module Variables and COMMON Blocks</a>
<b>Previous: </b><a href="node427.htm#Node434"> Calling MPI_F_SYNC_REG</a>
<p>
    
<P> 
Instead of <font face="sans-serif"> MPI_F_SYNC_REG</font>, one can also use a   
user defined external subroutine, which is separately compiled:  
 <P> 
<br> 
<pre><tt>        subroutine DD(buf) 
          integer buf 
        end 
</tt></pre> 
Note that if the intent is declared in an explicit interface for the external subroutine, it  
must be <tt> OUT</tt> or <tt> INOUT</tt>. The subroutine itself may have an empty body, but  
the compiler does not know this and has to assume that the buffer may  
be altered.  For example, a call to   
<font face="sans-serif"> MPI_RECV</font> with <font face="sans-serif">  MPI_BOTTOM</font> as buffer might be replaced by  
<br> 
<pre><tt>        call DD(buf) 
        call MPI_RECV(MPI_BOTTOM,...) 
        call DD(buf) 
</tt></pre> 
Such a user-defined routine was introduced in <font face="sans-serif"> MPI-2.0</font> and is still included here   
to document such usage in existing application programs although   
new applications should prefer <font face="sans-serif"> MPI_F_SYNC_REG</font> or one of the  
other possibilities.   
In an existing application, calls to such a user-written routine should  
be substituted by a call to <font face="sans-serif"> MPI_F_SYNC_REG</font> because the  
user-written routine may not be implemented in accordance with the  
rules specified in Section <a href="node414.htm#Node414">Requirements on Fortran Compilers 
</a>.  
 <P> 

<P>
<hr>
<a href="node427.htm#Node434"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node436"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node436"> Module Variables and COMMON Blocks</a>
<b>Previous: </b><a href="node427.htm#Node434"> Calling MPI_F_SYNC_REG</a>
<p>
<hr><h3><span id="Node436">371.9. Module Variables and COMMON Blocks</span></h3>
<a href="node427.htm#Node435"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node437"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node437"> The (Poorly Performing) Fortran VOLATILE Attribute</a>
<b>Previous: </b><a href="node427.htm#Node435"> A User Defined Routine Instead of MPI_F_SYNC_REG</a>
<p>
  
  
<P> 
An alternative to the previously mentioned methods is to put the buffer or variable into a module or a  
common block and access it through a <tt>USE</tt> or <tt>COMMON</tt> statement in each  
scope where it is referenced, defined or appears as an actual argument  
in a call to an <font face="sans-serif"> MPI</font> routine. The compiler will then have to assume that  
the <font face="sans-serif"> MPI</font> procedure may alter the buffer  
or variable, provided that the compiler cannot infer that the <font face="sans-serif"> MPI</font>  
procedure does not reference the module or common block.  
<ul> 
 
<li>This method solves problems of instruction reordering, code movement,   
   and register optimization  
   related to nonblocking and one-sided communication,  
   or related to the usage of <font face="sans-serif">  MPI_BOTTOM</font> and derived datatype handles.  
 
<li>Unfortunately, this method does <b> not</b> solve problems  
   caused by asynchronous accesses between the start and  
   end of a nonblocking or one-sided communication. Specifically,  
   problems caused by temporary memory modifications are not solved.  
</ul> 
<br> 

<P>
<hr>
<a href="node427.htm#Node435"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node437"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node437"> The (Poorly Performing) Fortran VOLATILE Attribute</a>
<b>Previous: </b><a href="node427.htm#Node435"> A User Defined Routine Instead of MPI_F_SYNC_REG</a>
<p>
<hr><h3><span id="Node437">371.10. The (Poorly Performing) Fortran VOLATILE Attribute</span></h3>
<a href="node427.htm#Node436"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node438"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node438"> The Fortran TARGET Attribute</a>
<b>Previous: </b><a href="node427.htm#Node436"> Module Variables and COMMON Blocks</a>
<p>
  
<P> 
The <tt> VOLATILE</tt> attribute  
gives the buffer or variable the properties needed to avoid register  
optimization or code movement problems, but it may inhibit  
optimization of any code containing references or definitions of the buffer or variable.   
On many modern systems, the performance impact will be large because  
not only register, but also cache optimizations will not be  
applied. Therefore, use of the <tt> VOLATILE</tt> attribute to enforce  
correct execution of <font face="sans-serif"> MPI</font> programs is discouraged.  
 <P> 

<P>
<hr>
<a href="node427.htm#Node436"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node427.htm#Node438"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node427.htm#Node438"> The Fortran TARGET Attribute</a>
<b>Previous: </b><a href="node427.htm#Node436"> Module Variables and COMMON Blocks</a>
<p>
<hr><h3><span id="Node438">371.11. The Fortran TARGET Attribute</span></h3>
<a href="node427.htm#Node437"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node439.htm#Node439"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node439.htm#Node439"> Temporary Data Movement and Temporary Memory Modification</a>
<b>Previous: </b><a href="node427.htm#Node437"> The (Poorly Performing) Fortran VOLATILE Attribute</a>
<p>
    
 <P> 
The <tt> TARGET</tt> attribute does not solve the code movement problem  
because it is not specified for the choice buffer dummy arguments  
of nonblocking routines.  
If the compiler detects that the application program specifies the  
<tt> TARGET</tt> attribute for an actual buffer argument used  
in the call to a nonblocking routine,  
the compiler may ignore this attribute if  
no pointer reference to this buffer exists.  
 
<br> 
<em> Rationale.</em>  
 <P> 
The Fortran standardization body decided to extend the <tt> ASYNCHRONOUS</tt> attribute  
within the TS 29113 to protect buffers in nonblocking calls   
from all kinds of optimization, instead of extending the <tt> TARGET</tt> attribute.  
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node427.htm#Node437"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node427.htm#Node427"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node439.htm#Node439"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node427.htm#Node427"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node439.htm#Node439"> Temporary Data Movement and Temporary Memory Modification</a>
<b>Previous: </b><a href="node427.htm#Node437"> The (Poorly Performing) Fortran VOLATILE Attribute</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
