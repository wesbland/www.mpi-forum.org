<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Address and Size Functions</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node82">77. Address and Size Functions</span></h2>
<a href="node81.htm#Node81"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node77.htm#Node77"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node83.htm#Node83"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node77.htm#Node77"> Derived Datatypes</a>
<b>Next: </b><a href="node83.htm#Node83"> Lower-Bound and Upper-Bound Markers</a>
<b>Previous: </b><a href="node81.htm#Node81"> Distributed Array Datatype Constructor</a>
<p>
  
<P> 
The displacements in a general datatype are relative to some initial buffer  
address.  
<b> Absolute addresses</b>  
can be substituted for these  
displacements: we treat them as displacements relative to ``address  
zero,'' the start of the address space.  This initial address zero is  
indicated by the constant <font face="sans-serif">  MPI_BOTTOM</font>.  Thus, a datatype can  
specify the absolute address of the entries in the communication  
buffer, in which case the <font face="sans-serif"> buf</font> argument is passed the value  
<font face="sans-serif">  MPI_BOTTOM</font>.  
Note that in Fortran <font face="sans-serif">  MPI_BOTTOM</font> is not usable for initialization or  
assignment, see Section <a href="node28.htm#Node28">Named Constants 
</a>.  
<P> 
The address of a location in memory can be found by invoking the  
function  
<font face="sans-serif"> MPI_GET_ADDRESS</font>.  
The <b> relative displacement</b>  
between two absolute addresses  
can be calculated with the function <font face="sans-serif"> MPI_AINT_DIFF</font>. A new absolute  
address as sum of an absolute base address and a relative displacement can be  
calculated with the function <font face="sans-serif"> MPI_AINT_ADD</font>. To ensure portability,  
arithmetic on absolute addresses should not be performed with the intrinsic  
operators ``-'' and ``+''. See also Sections <a href="node30.htm#Node30">Absolute Addresses and Relative Address Displacements 
</a>  
and <a href="node89.htm#Node89">Correct Use of Addresses 
</a> on pages <a href="node30.htm#Node30">Absolute Addresses and Relative Address Displacements 
</a> and  
<a href="node89.htm#Node89">Correct Use of Addresses 
</a>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
Address sized integer values, i.e., <font face="sans-serif"> MPI_Aint</font> or  
<tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt> values, are signed integers, while  
absolute addresses are unsigned quantities. Direct arithmetic on addresses  
stored in address sized signed variables can cause overflows, resulting in  
undefined behavior.  
 (<em> End of rationale.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_GET_ADDRESS(location, address)</TD></TR>  
<TR><TD> IN location</TD><TD>location in caller memory (choice)</TD></TR>  
<TR><TD> OUT address</TD><TD>address of location (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Get_address(const void *location, MPI_Aint *address) <br></tt>  
<P> 
 <tt> MPI_Get_address(location, address, ierror) <br> TYPE(*), DIMENSION(..), ASYNCHRONOUS :: location <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: address <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GET_ADDRESS(LOCATION, ADDRESS, IERROR)<br> &lt;type&gt; LOCATION(*) <br>INTEGER IERROR<br>INTEGER(KIND=MPI_ADDRESS_KIND) ADDRESS <br></tt>  
<P> 
  
<P> 
Returns the (byte) address of <font face="sans-serif"> location</font>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
In the <tt>mpi_f08</tt> module, the <font face="sans-serif"> location</font> argument is not defined   
with <tt> INTENT(IN)</tt> because existing applications may use   
<font face="sans-serif"> MPI_GET_ADDRESS</font> as a   
substitute for <font face="sans-serif"> MPI_F_SYNC_REG</font> that was not defined before <font face="sans-serif"> MPI-3.0</font>.   
 (<em> End of rationale.</em>) <br> 
<br><b> Example</b>  
  
Using <font face="sans-serif"> MPI_GET_ADDRESS</font> for an array.  
<P> 
<br> 
<pre><tt>   REAL A(100,100) 
   INTEGER(KIND=MPI_ADDRESS_KIND) I1, I2, DIFF 
   CALL MPI_GET_ADDRESS(A(1,1), I1, IERROR) 
   CALL MPI_GET_ADDRESS(A(10,10), I2, IERROR) 
   DIFF = MPI_AINT_DIFF(I2, I1) 
! The value of DIFF is 909*sizeofreal; the values of I1 and I2 are 
! implementation dependent. 
</tt></pre> 
  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
C users may be tempted to avoid the usage of   
<font face="sans-serif"> MPI_GET_ADDRESS</font>   
and rely on  
the availability of the address operator &amp;.  Note, however, that  
<font face="sans-serif">  &amp;</font> <em> cast-expression</em> is a pointer, not an  
address.  
ISO C   
does not require that the value of a pointer  
(or the pointer cast to <font face="sans-serif">  int</font>) be  
the absolute address of the object pointed at --- although this is  
commonly the case.  
Furthermore, referencing may not have a unique  
definition on machines with a segmented address space.  
The use of   
<font face="sans-serif"> MPI_GET_ADDRESS</font>   
to ``reference'' C  
variables guarantees portability to such machines as well.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
To prevent problems with the argument copying and register optimization done  
  by Fortran compilers, please note the hints in   
Sections <a href="node420.htm#Node420">Problems With Fortran Bindings for <font face="sans-serif"> MPI</font> 
</a>--<a href="node441.htm#Node441">Comparison with C 
</a>.  
 (<em> End of advice to users.</em>) <br> 
To ensure portability, arithmetic on <font face="sans-serif"> MPI</font> addresses must be  
performed using the <font face="sans-serif"> MPI_AINT_ADD</font>  
and <font face="sans-serif"> MPI_AINT_DIFF</font> functions.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_AINT_ADD(base, disp)</TD></TR>  
<TR><TD> IN base</TD><TD>base address (integer)</TD></TR>  
<TR><TD> IN disp</TD><TD>displacement (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> MPI_Aint MPI_Aint_add(MPI_Aint base, MPI_Aint disp) <br></tt>  
<P> 
 <tt> INTEGER(KIND=MPI_ADDRESS_KIND) MPI_Aint_add(base, disp) <br> INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: base, disp <br></tt>  
 <tt> INTEGER(KIND=MPI_ADDRESS_KIND) MPI_AINT_ADD(BASE, DISP) <br> INTEGER(KIND=MPI_ADDRESS_KIND) BASE, DISP <br></tt>  
<P> 
<font face="sans-serif"> MPI_AINT_ADD</font> produces a new <font face="sans-serif">  MPI_Aint</font> value that is  
equivalent to the sum of the <font face="sans-serif"> base</font> and <font face="sans-serif"> disp</font> arguments, where  
<font face="sans-serif"> base</font> represents a base address returned by a call to  
<font face="sans-serif"> MPI_GET_ADDRESS</font> and <font face="sans-serif"> disp</font> represents a signed integer  
displacement. The resulting address is valid only at the process that generated  
<font face="sans-serif"> base</font>, and it must correspond to a location in the same object  
referenced by <font face="sans-serif"> base</font>, as described in  
Section <a href="node89.htm#Node89">Correct Use of Addresses 
</a>. The addition is performed in a manner  
that results in the correct <font face="sans-serif">  MPI_Aint</font> representation of the output  
address, as if the process that originally produced <font face="sans-serif"> base</font> had called:  
<br> 
<pre><tt>MPI_Get_address((char *) base + disp, &amp;result); 
</tt></pre> 
<TABLE><TR><TD COLSPAN=2>MPI_AINT_DIFF(addr1, addr2)</TD></TR>  
<TR><TD> IN addr1</TD><TD>minuend address (integer)</TD></TR>  
<TR><TD> IN addr2</TD><TD>subtrahend address (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> MPI_Aint MPI_Aint_diff(MPI_Aint addr1, MPI_Aint addr2) <br></tt>  
<P> 
 <tt> INTEGER(KIND=MPI_ADDRESS_KIND) MPI_Aint_diff(addr1, addr2) <br> INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: addr1, addr2 <br></tt>  
 <tt> INTEGER(KIND=MPI_ADDRESS_KIND) MPI_AINT_DIFF(ADDR1, ADDR2) <br> INTEGER(KIND=MPI_ADDRESS_KIND) ADDR1, ADDR2 <br></tt>  
<P> 
<font face="sans-serif"> MPI_AINT_DIFF</font> produces a new <font face="sans-serif">  MPI_Aint</font> value that is  
equivalent to the difference between <font face="sans-serif"> addr1</font> and <font face="sans-serif"> addr2</font>  
arguments, where <font face="sans-serif"> addr1</font> and <font face="sans-serif"> addr2</font> represent addresses returned  
by calls to <font face="sans-serif"> MPI_GET_ADDRESS</font>.  The resulting address is valid only  
at the process that generated <font face="sans-serif"> addr1</font> and <font face="sans-serif"> addr2</font>, and  
<font face="sans-serif"> addr1</font> and <font face="sans-serif"> addr2</font> must correspond to locations in the same  
object in the same process, as described in  
Section <a href="node89.htm#Node89">Correct Use of Addresses 
</a>. The difference is calculated in a manner  
that results in  
the signed difference from <font face="sans-serif"> addr1</font> to <font face="sans-serif"> addr2</font>, as if  
the process that originally produced the addresses had called  
<tt>(char *) addr1 - (char *) addr2</tt>  
on the addresses initially passed to <font face="sans-serif"> MPI_GET_ADDRESS</font>.  
<P> 
The following auxiliary functions provide useful information on  
derived datatypes.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_SIZE(datatype, size)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype (handle)</TD></TR>  
<TR><TD> OUT size</TD><TD>datatype size (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_size(MPI_Datatype datatype, int *size) <br></tt>  
<P> 
 <tt> MPI_Type_size(datatype, size, ierror) <br> TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>INTEGER, INTENT(OUT) :: size <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_SIZE(DATATYPE, SIZE, IERROR)<br> INTEGER DATATYPE, SIZE, IERROR <br></tt>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_SIZE_X(datatype, size)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype (handle)</TD></TR>  
<TR><TD> OUT size</TD><TD>datatype size (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_size_x(MPI_Datatype datatype, MPI_Count *size) <br></tt>  
<P> 
 <tt> MPI_Type_size_x(datatype, size, ierror) <br> TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: size <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_SIZE_X(DATATYPE, SIZE, IERROR)<br> INTEGER DATATYPE, IERROR<br>INTEGER(KIND=MPI_COUNT_KIND) SIZE <br></tt>  
<P> 
<font face="sans-serif"> MPI_TYPE_SIZE</font> and <font face="sans-serif"> MPI_TYPE_SIZE_X</font> set the value of <font face="sans-serif"> size</font> to the total size, in bytes, of the entries in  
the type signature  
associated with <font face="sans-serif"> datatype</font>; i.e., the total size of  
the data in a message that would be created with this datatype.  Entries that  
occur multiple times in the datatype are counted with their multiplicity.  
For both functions, if the  OUT parameter cannot express the value to  
be returned (e.g., if the parameter is too small to hold the output  
value), it is set to <font face="sans-serif">  MPI_UNDEFINED</font>.  
<P> 

<P>
<hr>
<a href="node81.htm#Node81"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node77.htm#Node77"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node83.htm#Node83"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node77.htm#Node77"> Derived Datatypes</a>
<b>Next: </b><a href="node83.htm#Node83"> Lower-Bound and Upper-Bound Markers</a>
<b>Previous: </b><a href="node81.htm#Node81"> Distributed Array Datatype Constructor</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
