<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Pack and Unpack</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node92">87. Pack and Unpack</span></h1>
<a href="node91.htm#Node91"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node93.htm#Node93"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node93.htm#Node93"> Canonical <font face="sans-serif"> MPI_PACK</font> and <font face="sans-serif"> MPI_UNPACK</font></a>
<b>Previous: </b><a href="node91.htm#Node91"> Examples</a>
<p>
  
  
  
<P> 
Some existing communication libraries provide pack/unpack functions for sending  
noncontiguous data. In these, the user explicitly packs  
data into a contiguous buffer  
before sending it, and unpacks it from a contiguous buffer after receiving it.  
Derived datatypes, which are described in  
Section <a href="node77.htm#Node77">Derived Datatypes 
</a>, allow one, in most cases, to avoid  
explicit packing and unpacking.  The user specifies the layout of  
the data to be sent or received, and the communication library directly  
accesses a noncontiguous buffer.  The pack/unpack routines are provided for  
compatibility with previous libraries.   Also, they provide some functionality  
that is not otherwise available in <font face="sans-serif"> MPI</font>.  
For instance, a message can be received in several  
parts, where the receive operation done on  
a later part may depend on the content of a former part.  
Another use is that outgoing messages  
may be explicitly buffered in user supplied space, thus overriding the system  
buffering policy.   Finally, the availability of pack and unpack operations  
facilitates the development of additional communication libraries layered on top  
of <font face="sans-serif"> MPI</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_PACK(inbuf, incount, datatype, outbuf, outsize,  
position, comm)</TD></TR>  
<TR><TD> IN inbuf</TD><TD>input buffer start (choice)</TD></TR>  
<TR><TD> IN incount</TD><TD>number of input data items (non-negative  
        integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each input data item (handle)</TD></TR>  
<TR><TD> OUT outbuf</TD><TD>output buffer start (choice)</TD></TR>  
<TR><TD> IN outsize</TD><TD>output buffer size, in bytes (non-negative  
integer)</TD></TR>  
<TR><TD> INOUT position</TD><TD>current position in buffer, in bytes (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator for packed message (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Pack(const void* inbuf, int incount, MPI_Datatype datatype, void *outbuf, int outsize, int *position, MPI_Comm comm) <br></tt>  
<P> 
 <tt> MPI_Pack(inbuf, incount, datatype, outbuf, outsize, position, comm, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: inbuf <br>TYPE(*), DIMENSION(..) :: outbuf <br>INTEGER, INTENT(IN) :: incount, outsize <br>TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>INTEGER, INTENT(INOUT) :: position <br>TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_PACK(INBUF, INCOUNT, DATATYPE, OUTBUF, OUTSIZE, POSITION, COMM, IERROR)<br> &lt;type&gt; INBUF(*), OUTBUF(*)<br>INTEGER INCOUNT, DATATYPE, OUTSIZE, POSITION,  COMM, IERROR <br></tt>  
  
<P> 
Packs the message in the send buffer specified by <font face="sans-serif"> inbuf, incount,  
datatype</font> into the buffer  
space specified by <font face="sans-serif"> outbuf</font> and  
<font face="sans-serif"> outsize</font>.  The  
input buffer can  
be any communication buffer allowed in <font face="sans-serif"> MPI_SEND</font>.  The output buffer  
is a contiguous storage area containing <font face="sans-serif"> outsize</font> bytes, starting at  
the address <font face="sans-serif"> outbuf</font> (length is counted in <em> bytes</em>, not elements,  
as if it were a communication buffer for a message of type <font face="sans-serif"> MPI_PACKED</font>).  
<P> 
The input value of <font face="sans-serif"> position</font> is the first  
location in the output buffer to be used for packing.  <font face="sans-serif"> position</font> is  
incremented by the size of the packed message, and the output value of  
<font face="sans-serif"> position</font> is the first location in the output buffer  
following the locations occupied by the packed message.  
The <font face="sans-serif"> comm</font> argument  
is the communicator that will be subsequently used for sending the packed  
message.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_UNPACK(inbuf, insize, position, outbuf, outcount,  
datatype, comm)</TD></TR>  
<TR><TD> IN inbuf</TD><TD>input buffer start (choice)</TD></TR>  
<TR><TD> IN insize</TD><TD>size of input buffer, in bytes (non-negative  
        integer)</TD></TR>  
<TR><TD> INOUT position</TD><TD>current position in bytes (integer)</TD></TR>  
<TR><TD> OUT outbuf</TD><TD>output buffer start (choice)</TD></TR>  
<TR><TD> IN outcount</TD><TD>number of items to be unpacked (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each output data item (handle)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator for packed message (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Unpack(const void* inbuf, int insize, int *position, void *outbuf, int outcount, MPI_Datatype datatype, MPI_Comm comm) <br></tt>  
<P> 
 <tt> MPI_Unpack(inbuf, insize, position, outbuf, outcount, datatype, comm, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: inbuf <br>TYPE(*), DIMENSION(..) :: outbuf <br>INTEGER, INTENT(IN) :: insize, outcount <br>INTEGER, INTENT(INOUT) :: position <br>TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_UNPACK(INBUF, INSIZE, POSITION, OUTBUF, OUTCOUNT, DATATYPE, COMM, IERROR)<br>  &lt;type&gt; INBUF(*), OUTBUF(*) <br>INTEGER INSIZE, POSITION, OUTCOUNT, DATATYPE, COMM, IERROR <br></tt>  
  
<P> 
Unpacks a message into the receive buffer specified by <font face="sans-serif"> outbuf,  
outcount,  
datatype</font> from the buffer  
space specified by <font face="sans-serif"> inbuf</font> and <font face="sans-serif"> insize</font>.  The output buffer can  
be any communication buffer allowed in <font face="sans-serif"> MPI_RECV</font>.  The input  
buffer is a contiguous storage area containing <font face="sans-serif"> insize</font> bytes,  
starting at address <font face="sans-serif"> inbuf</font>.  
The input value of <font face="sans-serif"> position</font> is the first location in  
the input buffer occupied by the packed message.  
<font face="sans-serif"> position</font> is incremented  
by the size of the packed message, so that the output value of  
<font face="sans-serif"> position</font> is the first location in the input buffer  
after the locations occupied by the message that was unpacked.  
<font face="sans-serif"> comm</font> is the communicator used to receive the packed message.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Note the difference between <font face="sans-serif"> MPI_RECV</font> and <font face="sans-serif"> MPI_UNPACK</font>:  in  
<font face="sans-serif"> MPI_RECV</font>, the <font face="sans-serif"> count</font> argument specifies the maximum  
number of  
items that can be received.  The actual number of items received is determined  
by the length of the incoming message.  In <font face="sans-serif"> MPI_UNPACK</font>, the  
<font face="sans-serif"> count</font> argument specifies the actual number  
of items that are unpacked;  
the ``size'' of the corresponding message is the increment in  
<font face="sans-serif"> position</font>.  
The reason for this change is that the ``incoming message size'' is not  
predetermined since the user decides how much to unpack; nor is it easy to  
determine  
the ``message size'' from the number of items to be unpacked.  In fact, in a  
heterogeneous system, this number may not be determined <em> a priori</em>.  
 (<em> End of advice to users.</em>) <br> 
To understand the behavior of pack and unpack, it is convenient to think of the  
data part of a message as being the sequence obtained by concatenating the  
successive values sent in that message.   The pack operation stores this  
sequence in the buffer space, as if sending the message to that buffer.  The  
unpack operation retrieves this sequence from buffer space, as if receiving a  
message from that buffer.  (It is helpful to think of internal Fortran files or  
<tt>sscanf</tt> in C, for a similar function.)  
<P> 
Several messages can be successively packed into one <b> packing unit</b>.   
This  
is effected by several successive <b> related</b> calls to <font face="sans-serif"> MPI_PACK</font>,  
where the first  
call provides <font face="sans-serif"> position = 0</font>, and each successive call inputs the value  
of <font face="sans-serif"> position</font> that was output by the previous call, and the same values  
for <font face="sans-serif"> outbuf, outcount</font> and <font face="sans-serif"> comm</font>.   This packing unit  
now contains  
the equivalent information that would have been stored in a message by one send  
call with a send buffer that is the ``concatenation'' of the individual send  
buffers.  
<P> 
A  packing unit can  
be sent using type <font face="sans-serif"> MPI_PACKED</font>.  Any point to point  
or collective communication function can be used to move the sequence of bytes  
that forms the packing unit from one process to another.  This packing unit  
can now be  
received using any receive operation, with any datatype:  the  
type matching rules are relaxed for messages sent with type <font face="sans-serif"> MPI_PACKED</font>.  
<P> 
A message sent with any type (including <font face="sans-serif"> MPI_PACKED</font>) can be  
received using the type <font face="sans-serif"> MPI_PACKED</font>.  Such a message can then be  
unpacked by calls to <font face="sans-serif"> MPI_UNPACK</font>.  
<P> 
A packing unit (or a message created by a regular, ``typed'' send)  
can be unpacked into several successive messages.  This is  
effected by several successive related calls to <font face="sans-serif"> MPI_UNPACK</font>, where  
the first  
call provides <font face="sans-serif"> position = 0</font>, and each successive call inputs the value  
of <font face="sans-serif"> position</font> that was output by the previous call, and the same values  
for <font face="sans-serif"> inbuf, insize</font> and <font face="sans-serif"> comm</font>.  
<P> 
The concatenation of two packing units is not necessarily a packing unit; nor is  
a substring of a packing unit necessarily a packing unit.  Thus, one cannot  
concatenate two packing units and then unpack the result as one packing  
unit; nor can one unpack a substring of a packing unit as a separate  
packing unit.  Each packing unit, that was created by a related  
sequence of pack  
calls, or by a regular send,  
must be unpacked as a unit, by a sequence of related unpack calls.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The restriction on ``atomic'' packing and unpacking of packing units allows  
the implementation to add at the head of packing units additional  
information, such as  
a description of the sender architecture (to be used for type conversion, in a  
heterogeneous environment)  
 (<em> End of rationale.</em>) <br> 
The following call allows the user to find out how much space is  
needed to pack a message and, thus, manage space allocation for  
buffers.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_PACK_SIZE(incount, datatype, comm, size)</TD></TR>  
<TR><TD> IN incount</TD><TD>count argument to packing call (non-negative  
        integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype argument to packing call (handle)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator argument to packing call (handle)</TD></TR>  
<TR><TD> OUT size</TD><TD>upper bound on size of packed message, in bytes (non-negative  
integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Pack_size(int incount, MPI_Datatype datatype, MPI_Comm comm, int *size) <br></tt>  
<P> 
 <tt> MPI_Pack_size(incount, datatype, comm, size, ierror) <br> INTEGER, INTENT(IN) :: incount <br>TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(OUT) :: size <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_PACK_SIZE(INCOUNT, DATATYPE, COMM, SIZE, IERROR)<br> INTEGER INCOUNT, DATATYPE, COMM, SIZE, IERROR <br></tt>  
  
<P> 
A call to <font face="sans-serif"> MPI_PACK_SIZE(incount, datatype, comm, size)</font>  
returns in <font face="sans-serif"> size</font> an upper bound on the increment in <font face="sans-serif"> position</font>  
that is effected by a call to <font face="sans-serif"> MPI_PACK(inbuf, incount, datatype,  
outbuf, outcount, position, comm)</font>.  
If the packed size of the datatype cannot be expressed by the <font face="sans-serif"> size</font>   
parameter, then <font face="sans-serif"> MPI_PACK_SIZE</font> sets the value of <font face="sans-serif"> size</font> to  
<font face="sans-serif">  MPI_UNDEFINED</font>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The call returns an upper bound, rather than an exact bound, since the  
exact amount of space needed to pack the message may depend on the  
context (e.g., first message packed in a packing unit may take more  
space).  
 (<em> End of rationale.</em>) <br> 
<br><b> Example</b>  
  
An example using <font face="sans-serif"> MPI_PACK</font>.  
<br> 
<pre><tt>int        position, i, j, a[2]; 
char       buff[1000]; 
 
MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank); 
if (myrank == 0) 
{ 
    /* SENDER CODE */ 
 
    position = 0; 
    MPI_Pack(&amp;i, 1, MPI_INT, buff, 1000, &amp;position, MPI_COMM_WORLD); 
    MPI_Pack(&amp;j, 1, MPI_INT, buff, 1000, &amp;position, MPI_COMM_WORLD); 
    MPI_Send(buff, position, MPI_PACKED, 1, 0, MPI_COMM_WORLD); 
} 
else  /* RECEIVER CODE */ 
    MPI_Recv(a, 2, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE); 
</tt></pre> 
  
<P> 
<br><b> Example</b>  
  
An elaborate example.  
<br> 
<pre><tt>int   position, i; 
float a[1000]; 
char  buff[1000]; 
 
MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank); 
if (myrank == 0) 
{ 
    /* SENDER CODE */ 
 
    int len[2]; 
    MPI_Aint disp[2]; 
    MPI_Datatype type[2], newtype; 
 
    /* build datatype for i followed by a[0]...a[i-1] */ 
 
    len[0] = 1; 
    len[1] = i; 
    MPI_Get_address(&amp;i, disp); 
    MPI_Get_address(a, disp+1); 
    type[0] = MPI_INT; 
    type[1] = MPI_FLOAT; 
    MPI_Type_create_struct(2, len, disp, type, &amp;newtype); 
    MPI_Type_commit(&amp;newtype); 
 
    /* Pack i followed by a[0]...a[i-1]*/ 
 
    position = 0; 
    MPI_Pack(MPI_BOTTOM, 1, newtype, buff, 1000, &amp;position, MPI_COMM_WORLD); 
 
    /* Send */ 
 
    MPI_Send(buff, position, MPI_PACKED, 1, 0, 
             MPI_COMM_WORLD); 
 
/* ***** 
   One can replace the last three lines with 
   MPI_Send(MPI_BOTTOM, 1, newtype, 1, 0, MPI_COMM_WORLD); 
   ***** */ 
} 
else if (myrank == 1) 
{ 
    /* RECEIVER CODE */ 
 
    MPI_Status status; 
 
    /* Receive */ 
 
    MPI_Recv(buff, 1000, MPI_PACKED, 0, 0, MPI_COMM_WORLD, &amp;status); 
 
    /* Unpack i */ 
 
    position = 0; 
    MPI_Unpack(buff, 1000, &amp;position, &amp;i, 1, MPI_INT, MPI_COMM_WORLD); 
 
    /* Unpack a[0]...a[i-1] */ 
    MPI_Unpack(buff, 1000, &amp;position, a, i, MPI_FLOAT, MPI_COMM_WORLD); 
} 
</tt></pre> 
  
<P> 
<br><b> Example</b>  
  
Each process sends a count, followed by count characters to the root;  
the root   
concatenates   
all characters into one string.  
<br> 
<pre><tt>int  count, gsize, counts[64], totalcount, k1, k2, k, 
     displs[64], position, concat_pos; 
char chr[100], *lbuf, *rbuf, *cbuf; 
 
MPI_Comm_size(comm, &amp;gsize); 
MPI_Comm_rank(comm, &amp;myrank); 
 
      /* allocate local pack buffer */ 
MPI_Pack_size(1, MPI_INT, comm, &amp;k1); 
MPI_Pack_size(count, MPI_CHAR, comm, &amp;k2); 
k = k1+k2; 
lbuf = (char *)malloc(k); 
 
      /* pack count, followed by count characters */ 
position = 0; 
MPI_Pack(&amp;count, 1, MPI_INT, lbuf, k, &amp;position, comm); 
MPI_Pack(chr, count, MPI_CHAR, lbuf, k, &amp;position, comm); 
 
if (myrank != root) { 
    /* gather at root sizes of all packed messages */ 
    MPI_Gather(&amp;position, 1, MPI_INT, NULL, 0, 
               MPI_DATATYPE_NULL, root, comm); 
 
    /* gather at root packed messages */ 
    MPI_Gatherv(lbuf, position, MPI_PACKED, NULL, 
                NULL, NULL, MPI_DATATYPE_NULL, root, comm); 
 
} else {   /* root code */ 
    /* gather sizes of all packed messages */ 
    MPI_Gather(&amp;position, 1, MPI_INT, counts, 1, 
               MPI_INT, root, comm); 
 
    /* gather all packed messages */ 
    displs[0] = 0; 
    for (i=1; i &lt; gsize; i++) 
        displs[i] = displs[i-1] + counts[i-1]; 
    totalcount = displs[gsize-1] + counts[gsize-1]; 
    rbuf = (char *)malloc(totalcount); 
    cbuf = (char *)malloc(totalcount); 
    MPI_Gatherv(lbuf, position, MPI_PACKED, rbuf, 
                counts, displs, MPI_PACKED, root, comm); 
  
    /* unpack all messages and concatenate strings */ 
    concat_pos = 0; 
    for (i=0; i &lt; gsize; i++) { 
        position = 0; 
        MPI_Unpack(rbuf+displs[i], totalcount-displs[i], 
                   &amp;position, &amp;count, 1, MPI_INT, comm); 
        MPI_Unpack(rbuf+displs[i], totalcount-displs[i], 
                   &amp;position, cbuf+concat_pos, count, MPI_CHAR, comm); 
        concat_pos += count; 
    } 
    cbuf[concat_pos] = '\0'; 
} 
</tt></pre> 
  
<P> 

<P>
<hr>
<a href="node91.htm#Node91"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node93.htm#Node93"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node93.htm#Node93"> Canonical <font face="sans-serif"> MPI_PACK</font> and <font face="sans-serif"> MPI_UNPACK</font></a>
<b>Previous: </b><a href="node91.htm#Node91"> Examples</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
