<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Accumulate Functions</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node272">251. Accumulate Functions</span></h2>
<a href="node271.htm#Node271"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node268.htm#Node268"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node272.htm#Node273"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node268.htm#Node268"> Communication Calls</a>
<b>Next: </b><a href="node272.htm#Node273"> Accumulate Function</a>
<b>Previous: </b><a href="node271.htm#Node271"> Examples for Communication Calls</a>
<p>
  
<P> 
It is often useful in a put operation to combine the data moved to the  
target process with the data that resides at that process, rather  
than replacing it.  
This will allow, for example, the  
accumulation of  
a sum by having all involved processes add their  
contributions to the  
sum variable in the memory of one process.  
The accumulate functions have slightly different  
semantics with respect to overlapping data accesses than  
the put and get functions; see Section <a href="node289.htm#Node289">Semantics and Correctness 
</a>  
for details.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node271.htm#Node271"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node268.htm#Node268"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node272.htm#Node273"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node268.htm#Node268"> Communication Calls</a>
<b>Next: </b><a href="node272.htm#Node273"> Accumulate Function</a>
<b>Previous: </b><a href="node271.htm#Node271"> Examples for Communication Calls</a>
<p>
<hr><h3><span id="Node273">251.1. Accumulate Function</span></h3>
<a href="node272.htm#Node272"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node272.htm#Node272"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node272.htm#Node274"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<b>Next: </b><a href="node272.htm#Node274"> Get Accumulate Function</a>
<b>Previous: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<p>
<P><img width=371 height=267 src="img195.gif" alt="Image file"><P>
 <tt> int MPI_Accumulate(const void *origin_addr, int origin_count, MPI_Datatype origin_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype, MPI_Op op, MPI_Win win) <br></tt>  
<P> 
 <tt> MPI_Accumulate(origin_addr, origin_count, origin_datatype, target_rank, target_disp, target_count, target_datatype, op, win, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: origin_addr <br>INTEGER, INTENT(IN) :: origin_count, target_rank, target_count <br>TYPE(MPI_Datatype), INTENT(IN) :: origin_datatype, target_datatype <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp <br>TYPE(MPI_Op), INTENT(IN) :: op <br>TYPE(MPI_Win), INTENT(IN) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_ACCUMULATE(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE,  OP, WIN, IERROR) <br> &lt;type&gt; ORIGIN_ADDR(*) <br>INTEGER(KIND=MPI_ADDRESS_KIND) TARGET_DISP <br>INTEGER ORIGIN_COUNT, ORIGIN_DATATYPE,TARGET_RANK, TARGET_COUNT, TARGET_DATATYPE,  OP, WIN, IERROR <br></tt>  
<P> 
  
<P> 
Accumulate the contents of the origin buffer  
(as defined by <font face="sans-serif"> origin_addr</font>,  
<font face="sans-serif"> origin_count</font>, and   
<font face="sans-serif"> origin_datatype</font>)  
to the buffer specified by arguments <font face="sans-serif"> target_count</font> and  
<font face="sans-serif"> target_datatype</font>,  
at offset <font face="sans-serif"> target_disp</font>, in  
the target window specified by <font face="sans-serif"> target_rank</font> and <font face="sans-serif"> win</font>,  
using the operation   
<font face="sans-serif"> op</font>.  
This is like <font face="sans-serif"> MPI_PUT</font> except that data is combined into  
the target area instead of overwriting it.  
<P> 
Any of the predefined operations for <font face="sans-serif"> MPI_REDUCE</font> can be  
used.  User-defined functions cannot be used.  
For example, if <font face="sans-serif"> op</font> is <font face="sans-serif"> MPI_SUM</font>,  
each element of the origin buffer is added to the corresponding element  
in the target, replacing the former value in the target.  
<P> 
Each datatype argument must be a predefined datatype or a derived  
datatype, where all basic components are of the same predefined  
datatype.  Both datatype arguments must be constructed from the same  
predefined datatype.  
The operation <font face="sans-serif"> op</font> applies to elements of that predefined  
type. The parameter <font face="sans-serif"> target_datatype</font> must not specify overlapping   
entries, and the target buffer must fit in the target window.  
<P> 
A new predefined operation, <font face="sans-serif">  MPI_REPLACE</font>, is defined.    
It corresponds to the associative function <i>f(a,b) = b</i>; i.e., the current  
value in the target memory is replaced by the value supplied by the  
origin.  
<P> 
<font face="sans-serif">  MPI_REPLACE</font> can be used only in <font face="sans-serif"> MPI_ACCUMULATE</font>,  
<font face="sans-serif"> MPI_RACCUMULATE</font>,  
  <font face="sans-serif"> MPI_GET_ACCUMULATE</font>, <font face="sans-serif"> MPI_FETCH_AND_OP</font>, and  
  <font face="sans-serif"> MPI_RGET_ACCUMULATE</font>, but not in collective  
reduction operations such as <font face="sans-serif"> MPI_REDUCE</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_PUT</font> is a special case of <font face="sans-serif"> MPI_ACCUMULATE</font>,  
with the  operation <font face="sans-serif">  MPI_REPLACE</font>.  
Note, however, that <font face="sans-serif"> MPI_PUT</font> and <font face="sans-serif"> MPI_ACCUMULATE</font>  
have different constraints on concurrent updates.  
 (<em> End of advice to users.</em>) <br> 
<br><b> Example</b>  
  
We want to compute <img width=118 height=13 src="img196.gif" alt="Image file">
.    
The arrays  
<tt>A</tt>, <tt>B</tt>, and <tt>map</tt> are  
distributed in the same manner.  We write   
the simple version.  
<P> 
<br> 
<pre><tt>SUBROUTINE SUM(A, B, map, m, comm, p) 
USE MPI 
INTEGER m, map(m), comm, p, win, ierr, disp_int 
REAL A(m), B(m) 
INTEGER (KIND=MPI_ADDRESS_KIND) lowerbound, size, realextent, disp_aint 
 
CALL MPI_TYPE_GET_EXTENT(MPI_REAL, lowerbound, realextent, ierr) 
size = m * realextent 
disp_int = realextent 
CALL MPI_WIN_CREATE(B, size, disp_int, MPI_INFO_NULL,  &amp; 
                    comm, win, ierr) 
 
CALL MPI_WIN_FENCE(0, win, ierr) 
DO i=1,m 
  j = map(i)/m 
  disp_aint = MOD(map(i),m) 
  CALL MPI_ACCUMULATE(A(i), 1, MPI_REAL, j, disp_aint, 1, MPI_REAL,   &amp; 
                      MPI_SUM, win, ierr) 
END DO 
CALL MPI_WIN_FENCE(0, win, ierr) 
 
CALL MPI_WIN_FREE(win, ierr) 
RETURN 
END 
</tt></pre> 
This code is identical to the code in  
Example <a href="node271.htm#Node271">Examples for Communication Calls 
</a>,  
except that a call to get has been  
replaced by a call to accumulate.  (Note that, if <tt>map</tt> is  
one-to-one, the code computes <img width=64 height=12 src="img197.gif" alt="Image file">
, which is the   
reverse assignment to the one computed in that previous example.)  
In a similar manner, we can replace  
in Example <a href="node271.htm#Node271">Examples for Communication Calls 
</a>,  
the call to get by a call to accumulate,  
thus  
performing the computation with only one communication between any  
two processes.  
  
<P> 

<P>
<hr>
<a href="node272.htm#Node272"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node272.htm#Node272"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node272.htm#Node274"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<b>Next: </b><a href="node272.htm#Node274"> Get Accumulate Function</a>
<b>Previous: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<p>
<hr><h3><span id="Node274">251.2. Get Accumulate Function</span></h3>
<a href="node272.htm#Node273"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node272.htm#Node272"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node272.htm#Node275"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<b>Next: </b><a href="node272.htm#Node275"> Fetch and Op Function</a>
<b>Previous: </b><a href="node272.htm#Node273"> Accumulate Function</a>
<p>
  
<P> 
It is often useful to have fetch-and-accumulate semantics such that  
the remote data is returned to the caller before the sent data is  
accumulated into the remote data.  The get and accumulate  
steps are executed atomically for each basic element in the datatype  
(see Section <a href="node289.htm#Node289">Semantics and Correctness 
</a> for details).  
The predefined operation <font face="sans-serif">  MPI_REPLACE</font> provides fetch-and-set  
behavior.  
<P> 
<P><img width=375 height=376 src="img198.gif" alt="Image file"><P>
 <tt> int MPI_Get_accumulate(const void *origin_addr, int origin_count, MPI_Datatype origin_datatype, void *result_addr, int result_count, MPI_Datatype result_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype, MPI_Op op, MPI_Win win) <br></tt>  
<P> 
 <tt> MPI_Get_accumulate(origin_addr, origin_count, origin_datatype, result_addr, result_count, result_datatype, target_rank, target_disp, target_count, target_datatype, op, win, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: origin_addr <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: result_addr <br>INTEGER, INTENT(IN) :: origin_count, result_count, target_rank, target_count <br>TYPE(MPI_Datatype), INTENT(IN) :: origin_datatype, target_datatype, result_datatype <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp <br>TYPE(MPI_Op), INTENT(IN) :: op <br>TYPE(MPI_Win), INTENT(IN) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GET_ACCUMULATE(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, RESULT_ADDR, RESULT_COUNT, RESULT_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE, OP, WIN, IERROR) <br> &lt;type&gt; ORIGIN_ADDR(*), RESULT_ADDR(*) <br>INTEGER(KIND=MPI_ADDRESS_KIND) TARGET_DISP <br>INTEGER ORIGIN_COUNT, ORIGIN_DATATYPE, RESULT_COUNT, RESULT_DATATYPE, TARGET_RANK, TARGET_COUNT, TARGET_DATATYPE, OP, WIN, IERROR <br></tt>  
<P> 
<P> 
Accumulate <font face="sans-serif"> origin_count</font> elements of type <font face="sans-serif"> origin_datatype</font> from   
the origin buffer (<font face="sans-serif"> origin_addr</font>) to the buffer at offset  
<font face="sans-serif"> target_disp</font>, in the target window specified by  
<font face="sans-serif"> target_rank</font> and <font face="sans-serif"> win</font>, using the operation <font face="sans-serif"> op</font>  
and return in the result buffer <font face="sans-serif"> result_addr</font> the content  
of the target buffer before the accumulation, specified by  
<font face="sans-serif"> target_disp</font>, <font face="sans-serif"> target_count</font>, and  
<font face="sans-serif"> target_datatype</font>.  
The data transferred from origin to target must fit, without  
truncation, in the target buffer.  Likewise, the data copied from target to  
origin must fit, without truncation, in the result buffer.  
<P> 
The origin and result buffers (<font face="sans-serif"> origin_addr</font> and  
<font face="sans-serif"> result_addr</font>) must be disjoint.   
Each datatype argument must be a predefined datatype or a derived  
datatype where all basic components are of the same predefined  
datatype.  All datatype arguments must be constructed from the same  
predefined datatype.  
The operation <font face="sans-serif"> op</font> applies to elements of that predefined  
type. <font face="sans-serif"> target_datatype</font> must not specify overlapping   
entries, and the target buffer must fit in the target window or in  
attached memory in a dynamic window.  
The operation is executed atomically for each basic datatype; see  
Section <a href="node289.htm#Node289">Semantics and Correctness 
</a> for details.  
<P> 
Any of the predefined operations for <font face="sans-serif"> MPI_REDUCE</font>,  
as well as  
<font face="sans-serif">  MPI_NO_OP</font> or <font face="sans-serif">  MPI_REPLACE</font> can be specified as  
<font face="sans-serif"> op</font>.  User-defined functions cannot be used.   
A new predefined operation, <font face="sans-serif">  MPI_NO_OP</font>, is defined.    
It corresponds to the associative function <i>f(a,b) = a</i>; i.e., the current  
value in the target memory is returned in the result buffer at the  
origin and no operation is performed on the target buffer.  
When <font face="sans-serif">  MPI_NO_OP</font> is specified as the operation, the  
<font face="sans-serif"> origin_addr</font>,  
<font face="sans-serif"> origin_count</font>, and <font face="sans-serif"> origin_datatype</font> arguments are ignored.  
<font face="sans-serif">  MPI_NO_OP</font> can be used only in <font face="sans-serif"> MPI_GET_ACCUMULATE</font>,  
<font face="sans-serif"> MPI_RGET_ACCUMULATE</font>, and <font face="sans-serif"> MPI_FETCH_AND_OP</font>.  
<font face="sans-serif">  MPI_NO_OP</font> cannot be used  
in <font face="sans-serif"> MPI_ACCUMULATE</font>, <font face="sans-serif"> MPI_RACCUMULATE</font>, or collective  
reduction operations, such as <font face="sans-serif"> MPI_REDUCE</font> and others.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_GET</font> is similar to   
<font face="sans-serif"> MPI_GET_ACCUMULATE</font>,  
with the  operation <font face="sans-serif">  MPI_NO_OP</font>.  
Note, however, that <font face="sans-serif"> MPI_GET</font> and  
<font face="sans-serif"> MPI_GET_ACCUMULATE</font>  
have different constraints on concurrent updates.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node272.htm#Node273"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node272.htm#Node272"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node272.htm#Node275"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<b>Next: </b><a href="node272.htm#Node275"> Fetch and Op Function</a>
<b>Previous: </b><a href="node272.htm#Node273"> Accumulate Function</a>
<p>
<hr><h3><span id="Node275">251.3. Fetch and Op Function</span></h3>
<a href="node272.htm#Node274"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node272.htm#Node272"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node272.htm#Node276"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<b>Next: </b><a href="node272.htm#Node276"> Compare and Swap Function</a>
<b>Previous: </b><a href="node272.htm#Node274"> Get Accumulate Function</a>
<p>
  
<P> 
The generic functionality of <font face="sans-serif"> MPI_GET_ACCUMULATE</font> might  
limit the performance of fetch-and-increment or fetch-and-add  
calls that might be supported by special hardware operations.  
<font face="sans-serif"> MPI_FETCH_AND_OP</font> thus allows for a fast implementation of  
a commonly used subset of the functionality of  
<font face="sans-serif"> MPI_GET_ACCUMULATE</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FETCH_AND_OP(origin_addr, result_addr, datatype, target_rank, target_disp, op, win)</TD></TR>  
<TR><TD> IN origin_addr</TD><TD>initial address of buffer (choice)</TD></TR>   
<TR><TD> OUT result_addr</TD><TD>initial address of result buffer (choice)</TD></TR>   
<TR><TD> IN datatype</TD><TD>datatype of the entry in origin, result, and target buffers (handle)</TD></TR>   
<TR><TD> IN target_rank</TD><TD>rank of target (non-negative integer)</TD></TR>   
<TR><TD> IN target_disp</TD><TD>displacement from start of window to beginning of target buffer (non-negative integer)</TD></TR>  
<TR><TD> IN op</TD><TD>reduce operation (handle)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Fetch_and_op(const void *origin_addr, void *result_addr, MPI_Datatype datatype, int target_rank, MPI_Aint target_disp, MPI_Op op, MPI_Win win) <br></tt>  
<P> 
 <tt> MPI_Fetch_and_op(origin_addr, result_addr, datatype, target_rank, target_disp, op, win, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: origin_addr <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: result_addr <br>TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>INTEGER, INTENT(IN) :: target_rank <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp <br>TYPE(MPI_Op), INTENT(IN) :: op <br>TYPE(MPI_Win), INTENT(IN) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_FETCH_AND_OP(ORIGIN_ADDR, RESULT_ADDR, DATATYPE, TARGET_RANK, TARGET_DISP, OP, WIN, IERROR) <br> &lt;type&gt; ORIGIN_ADDR(*), RESULT_ADDR(*) <br>INTEGER(KIND=MPI_ADDRESS_KIND) TARGET_DISP <br>INTEGER DATATYPE, TARGET_RANK, OP, WIN, IERROR <br></tt>  
<P> 
<P> 
Accumulate one element of type <font face="sans-serif"> datatype</font> from the origin buffer  
(<font face="sans-serif"> origin_addr</font>) to the buffer at offset <font face="sans-serif"> target_disp</font>,  
in the target window specified by <font face="sans-serif"> target_rank</font> and  
<font face="sans-serif"> win</font>, using the operation <font face="sans-serif"> op</font> and return in the result  
buffer <font face="sans-serif"> result_addr</font> the content of the target buffer before the  
accumulation.  
<P> 
The origin and result buffers (<font face="sans-serif"> origin_addr</font> and  
<font face="sans-serif"> result_addr</font>) must be disjoint.   
Any of the predefined operations for <font face="sans-serif"> MPI_REDUCE</font>, as well as   
<font face="sans-serif">  MPI_NO_OP</font> or <font face="sans-serif">  MPI_REPLACE</font>, can be specified as  
<font face="sans-serif"> op</font>; user-defined functions cannot be used.   
The <font face="sans-serif"> datatype</font> argument must be a predefined datatype.  
The operation is executed atomically.  
<P> 

<P>
<hr>
<a href="node272.htm#Node274"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node272.htm#Node272"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node272.htm#Node276"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<b>Next: </b><a href="node272.htm#Node276"> Compare and Swap Function</a>
<b>Previous: </b><a href="node272.htm#Node274"> Get Accumulate Function</a>
<p>
<hr><h3><span id="Node276">251.4. Compare and Swap Function</span></h3>
<a href="node272.htm#Node275"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node272.htm#Node272"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node277.htm#Node277"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<b>Next: </b><a href="node277.htm#Node277"> Request-based RMA Communication Operations</a>
<b>Previous: </b><a href="node272.htm#Node275"> Fetch and Op Function</a>
<p>
  
<P> 
Another useful operation is an atomic compare and swap where the  
value at the origin is compared to the value at the target,  
which is atomically replaced by a third value only  
if the values at origin and target are equal.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMPARE_AND_SWAP(origin_addr, compare_addr, result_addr, datatype, target_rank, target_disp, win)</TD></TR>  
<TR><TD> IN origin_addr</TD><TD>initial address of buffer (choice)</TD></TR>   
<TR><TD> IN compare_addr</TD><TD>initial address of compare buffer (choice)</TD></TR>   
<TR><TD> OUT result_addr</TD><TD>initial address of result buffer (choice)</TD></TR>   
<TR><TD> IN datatype</TD><TD>datatype of the element in all buffers (handle)</TD></TR>   
<TR><TD> IN target_rank</TD><TD>rank of target (non-negative integer)</TD></TR>   
<TR><TD> IN target_disp</TD><TD>displacement from start of window to beginning of target buffer (non-negative integer)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
  
 <tt> int MPI_Compare_and_swap(const void *origin_addr, const void *compare_addr, void *result_addr, MPI_Datatype datatype, int target_rank, MPI_Aint target_disp, MPI_Win win) <br></tt>  
<P> 
 <tt> MPI_Compare_and_swap(origin_addr, compare_addr, result_addr, datatype, target_rank, target_disp, win, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: origin_addr <br>TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: compare_addr <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: result_addr <br>TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>INTEGER, INTENT(IN) :: target_rank <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp <br>TYPE(MPI_Win), INTENT(IN) :: win <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_COMPARE_AND_SWAP(ORIGIN_ADDR, COMPARE_ADDR, RESULT_ADDR, DATATYPE, TARGET_RANK, TARGET_DISP, WIN, IERROR) <br> &lt;type&gt; ORIGIN_ADDR(*), COMPARE_ADDR(*), RESULT_ADDR(*) <br>INTEGER(KIND=MPI_ADDRESS_KIND) TARGET_DISP <br>INTEGER DATATYPE, TARGET_RANK, WIN, IERROR <br></tt>  
<P> 
<P> 
This function compares one element of type <font face="sans-serif"> datatype</font> in the  
compare buffer <font face="sans-serif"> compare_addr</font> with the buffer at offset  
<font face="sans-serif"> target_disp</font> in the target window specified by  
<font face="sans-serif"> target_rank</font> and <font face="sans-serif"> win</font> and replaces the  
value at the target with the value in the origin buffer  
<font face="sans-serif"> origin_addr</font> if the compare buffer and the   
target buffer are identical.  
The original value at the target is returned  
in the buffer <font face="sans-serif"> result_addr</font>. The parameter <font face="sans-serif"> datatype</font>  
must belong to one of the following categories of predefined datatypes: C integer, Fortran  
integer, Logical, Multi-language types, or Byte as specified in  
Section <a href="node112.htm#Node112">Predefined Reduction Operations 
</a>.  
The origin and result buffers (<font face="sans-serif"> origin_addr</font> and  
<font face="sans-serif"> result_addr</font>) must be disjoint.   
<P> 

<P>
<hr>
<a href="node272.htm#Node275"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node272.htm#Node272"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node277.htm#Node277"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node272.htm#Node272"> Accumulate Functions</a>
<b>Next: </b><a href="node277.htm#Node277"> Request-based RMA Communication Operations</a>
<b>Previous: </b><a href="node272.htm#Node275"> Fetch and Op Function</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
