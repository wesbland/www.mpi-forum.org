<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title><font face="sans-serif"> MPI</font> Opaque Objects</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node448">381.  MPI Opaque Objects</span></h2>
<a href="node447.htm#Node447"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node442.htm#Node442"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node448.htm#Node449"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node442.htm#Node442"> Language Interoperability</a>
<b>Next: </b><a href="node448.htm#Node449"> Datatypes</a>
<b>Previous: </b><a href="node447.htm#Node447"> Status</a>
<p>
  
  
<P> 
Unless said otherwise, opaque objects are ``the same'' in all languages:  
they carry the same information, and have the same meaning in both  
languages.  The mechanism described in the previous section can be  
used to pass references to <font face="sans-serif"> MPI</font> objects from language to language.  
An object created in one language can be accessed, modified or freed  
in another language.  
<P> 
We examine below in more detail issues that arise for each type of  
<font face="sans-serif"> MPI</font> object.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node447.htm#Node447"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node442.htm#Node442"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node448.htm#Node449"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node442.htm#Node442"> Language Interoperability</a>
<b>Next: </b><a href="node448.htm#Node449"> Datatypes</a>
<b>Previous: </b><a href="node447.htm#Node447"> Status</a>
<p>
<hr><h3><span id="Node449">381.1. Datatypes</span></h3>
<a href="node448.htm#Node448"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node448.htm#Node448"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node448.htm#Node450"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<b>Next: </b><a href="node448.htm#Node450"> Callback Functions</a>
<b>Previous: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<p>
  
  
<P> 
Datatypes encode the same information in all languages.  E.g., a  
datatype accessor like <font face="sans-serif"> MPI_TYPE_GET_EXTENT</font> will return the  
same information in all languages.  
If a datatype defined in  
one language is used for a communication call in another language, then the  
message sent will  
be identical to the message that would be sent from the first language: the  
same  
communication buffer is accessed, and the same representation  
conversion is performed, if needed.  
All predefined  
datatypes can be used in datatype constructors in any language. If  
a datatype is committed, it can be used for  
communication in any language.  
<P> 
The function <font face="sans-serif"> MPI_GET_ADDRESS</font> returns the same value in  
all languages.  Note that we do not require that the  
constant <font face="sans-serif">  MPI_BOTTOM</font> have the same value in all languages (see  
Section <a href="node455.htm#Node455">Constants 
</a>).  
<P> 
  
<br><b> Example</b>  
  
<br> 
<pre><tt>! FORTRAN CODE 
REAL :: R(5) 
INTEGER :: TYPE, IERR, AOBLEN(1), AOTYPE(1) 
INTEGER (KIND=MPI_ADDRESS_KIND) :: AODISP(1) 
 
! create an absolute datatype for array R 
AOBLEN(1) = 5 
CALL MPI_GET_ADDRESS( R, AODISP(1), IERR) 
AOTYPE(1) = MPI_REAL 
CALL MPI_TYPE_CREATE_STRUCT(1, AOBLEN,AODISP,AOTYPE, TYPE, IERR) 
CALL C_ROUTINE(TYPE) 
</tt></pre> 
<br> 
<pre><tt>/* C code */ 
 
void C_ROUTINE(MPI_Fint *ftype) 
{ 
   int count = 5; 
   int lens[2] = {1,1}; 
   MPI_Aint displs[2]; 
   MPI_Datatype types[2], newtype; 
    
   /* create an absolute datatype for buffer that consists   */ 
   /*  of count, followed by R(5)                            */ 
    
   MPI_Get_address(&amp;count, &amp;displs[0]); 
   displs[1] = 0; 
   types[0] = MPI_INT; 
   types[1] = MPI_Type_f2c(*ftype); 
   MPI_Type_create_struct(2, lens, displs, types, &amp;newtype); 
   MPI_Type_commit(&amp;newtype); 
    
   MPI_Send(MPI_BOTTOM, 1, newtype, 1, 0, MPI_COMM_WORLD); 
   /* the message sent contains an int count of 5, followed  */ 
   /* by the 5 REAL entries of the Fortran array R.          */ 
} 
</tt></pre> 
  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The following implementation can be used:  <font face="sans-serif"> MPI</font> addresses, as  
returned by <font face="sans-serif"> MPI_GET_ADDRESS</font>, will have  
the same value in all languages.  
One obvious choice is that  
<font face="sans-serif"> MPI</font> addresses be identical to regular addresses.  
The address is stored in the  
datatype, when datatypes with absolute addresses are constructed.  
When a send or receive operation is performed, then addresses stored in  
a datatype are interpreted as displacements that are all augmented by  
a base address.  This base address is (the address of) <font face="sans-serif"> buf</font>,  
or zero, if <font face="sans-serif"> buf = MPI_BOTTOM</font>.  Thus, if  
<font face="sans-serif">  MPI_BOTTOM</font> is zero then a send or  
receive call with <font face="sans-serif"> buf = MPI_BOTTOM</font> is implemented  
exactly as a call with a regular buffer argument:  in both cases the  
base address is <font face="sans-serif"> buf</font>.  
On the other  
hand, if <font face="sans-serif">  MPI_BOTTOM</font> is not zero, then the  
implementation has to be slightly different.  A test is performed  
to check whether <font face="sans-serif"> buf = MPI_BOTTOM</font>.  If true, then  
the base address is zero, otherwise it is <font face="sans-serif"> buf</font>.  
In particular, if <font face="sans-serif">  MPI_BOTTOM</font> does not have the same value in  
Fortran and C,   
then an additional test for <font face="sans-serif"> buf = MPI_BOTTOM</font>  
is needed in at least one of the languages.  
<P> 
It may be desirable to use a value other than zero for  
<font face="sans-serif">  MPI_BOTTOM</font> even in C,   
so as to distinguish it from a NULL  
pointer.  
If <font face="sans-serif">  MPI_BOTTOM</font> = c then one can still avoid the test  
<font face="sans-serif"> buf = MPI_BOTTOM</font>, by using the displacement from  
<font face="sans-serif">  MPI_BOTTOM</font>, i.e., the regular address - c, as the <font face="sans-serif"> MPI</font> address  
returned by <font face="sans-serif"> MPI_GET_ADDRESS</font> and stored in absolute datatypes.  
 (<em> End of advice to implementors.</em>) <br> 
  
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 

<P>
<hr>
<a href="node448.htm#Node448"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node448.htm#Node448"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node448.htm#Node450"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<b>Next: </b><a href="node448.htm#Node450"> Callback Functions</a>
<b>Previous: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<p>
<hr><h3><span id="Node450">381.2. Callback Functions</span></h3>
<a href="node448.htm#Node449"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node448.htm#Node448"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node448.htm#Node451"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<b>Next: </b><a href="node448.htm#Node451"> Error Handlers</a>
<b>Previous: </b><a href="node448.htm#Node449"> Datatypes</a>
<p>
  
<P> 
<font face="sans-serif"> MPI</font> calls may associate callback functions with <font face="sans-serif"> MPI</font>  
objects: error handlers are associated with communicators and files, attribute copy  
and  
delete functions are associated with attribute keys, reduce operations  
are   
associated  
with operation objects, etc.  In a multilanguage  
environment, a function passed in an <font face="sans-serif"> MPI</font> call in one language may be  
invoked by an <font face="sans-serif"> MPI</font> call in another language.  <font face="sans-serif"> MPI</font> implementations  
must make sure that such invocation will use the calling convention of  
the language the function is bound to.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Callback functions need to have a language tag.  This tag is set  
when the callback function is passed in by the library function (which  
is presumably different for each language and language support method),   
and is used to generate  
the right calling sequence when the callback function is invoked.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
If a subroutine written in one language or Fortran support method wants to  
pass a callback routine including the predefined Fortran functions (e.g.,  
<font face="sans-serif"> MPI_COMM_NULL_COPY_FN</font>) to another application routine written in another language  
or Fortran support method, then it must be guaranteed that both routines use the callback  
interface definition that is defined for the argument when passing the callback to an <font face="sans-serif"> MPI</font>  
routine (e.g., <font face="sans-serif"> MPI_COMM_CREATE_KEYVAL</font>);   
see also the advice to users on page <a href="node174.htm#Node174">Communicators 
</a>.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node448.htm#Node449"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node448.htm#Node448"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node448.htm#Node451"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<b>Next: </b><a href="node448.htm#Node451"> Error Handlers</a>
<b>Previous: </b><a href="node448.htm#Node449"> Datatypes</a>
<p>
<hr><h3><span id="Node451">381.3. Error Handlers</span></h3>
<a href="node448.htm#Node450"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node448.htm#Node448"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node448.htm#Node452"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<b>Next: </b><a href="node448.htm#Node452"> Reduce Operations</a>
<b>Previous: </b><a href="node448.htm#Node450"> Callback Functions</a>
<p>
  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Error handlers, have,  
in C, a variable length argument list.  
It might be useful to  
provide to the handler information on the language environment where  
the error occurred.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node448.htm#Node450"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node448.htm#Node448"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node448.htm#Node452"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<b>Next: </b><a href="node448.htm#Node452"> Reduce Operations</a>
<b>Previous: </b><a href="node448.htm#Node450"> Callback Functions</a>
<p>
<hr><h3><span id="Node452">381.4. Reduce Operations</span></h3>
<a href="node448.htm#Node451"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node448.htm#Node448"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node453.htm#Node453"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<b>Next: </b><a href="node453.htm#Node453"> Attributes</a>
<b>Previous: </b><a href="node448.htm#Node451"> Error Handlers</a>
<p>
  
<P> 
All predefined named and unnamed datatypes as  
listed in Section <a href="node112.htm#Node112">Predefined Reduction Operations 
</a> can be used in the listed  
predefined operations independent of the programming language from  
which the <font face="sans-serif"> MPI</font> routine is called.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Reduce operations receive as one of their arguments the datatype of the  
operands.  
Thus, one can define ``polymorphic'' reduce  
operations that work for C and Fortran datatypes.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node448.htm#Node451"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node448.htm#Node448"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node453.htm#Node453"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node448.htm#Node448"> <font face="sans-serif"> MPI</font> Opaque Objects</a>
<b>Next: </b><a href="node453.htm#Node453"> Attributes</a>
<b>Previous: </b><a href="node448.htm#Node451"> Error Handlers</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
