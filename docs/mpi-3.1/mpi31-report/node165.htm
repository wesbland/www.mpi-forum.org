<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-context/context.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Library Example #2</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node165">158. Library Example #2</span></h2>
<a href="node164.htm#Node164"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node159.htm#Node159"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node166.htm#Node166"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node159.htm#Node159"> Motivating Examples</a>
<b>Next: </b><a href="node166.htm#Node166"> Inter-Communication</a>
<b>Previous: </b><a href="node164.htm#Node164"> Library Example #1</a>
<p>
  
The main program:  
<br> 
<pre><tt>   int main(int argc, char *argv[]) 
   { 
     int ma, mb; 
     MPI_Group group_world, group_a, group_b; 
     MPI_Comm comm_a, comm_b; 
 
     static int list_a[] = {0, 1}; 
#if  defined(EXAMPLE_2B) || defined(EXAMPLE_2C) 
     static int list_b[] = {0, 2 ,3}; 
#else/* EXAMPLE_2A */ 
     static int list_b[] = {0, 2}; 
#endif 
     int size_list_a = sizeof(list_a)/sizeof(int); 
     int size_list_b = sizeof(list_b)/sizeof(int); 
 
     ... 
     MPI_Init(&amp;argc, &amp;argv); 
     MPI_Comm_group(MPI_COMM_WORLD, &amp;group_world); 
 
     MPI_Group_incl(group_world, size_list_a, list_a, &amp;group_a); 
     MPI_Group_incl(group_world, size_list_b, list_b, &amp;group_b); 
 
     MPI_Comm_create(MPI_COMM_WORLD, group_a, &amp;comm_a); 
     MPI_Comm_create(MPI_COMM_WORLD, group_b, &amp;comm_b); 
 
     if(comm_a != MPI_COMM_NULL) 
        MPI_Comm_rank(comm_a, &amp;ma); 
     if(comm_b != MPI_COMM_NULL) 
        MPI_Comm_rank(comm_b, &amp;mb); 
 
     if(comm_a != MPI_COMM_NULL) 
        lib_call(comm_a); 
 
     if(comm_b != MPI_COMM_NULL) 
     { 
       lib_call(comm_b); 
       lib_call(comm_b); 
     } 
 
     if(comm_a != MPI_COMM_NULL) 
       MPI_Comm_free(&amp;comm_a); 
     if(comm_b != MPI_COMM_NULL) 
       MPI_Comm_free(&amp;comm_b); 
     MPI_Group_free(&amp;group_a); 
     MPI_Group_free(&amp;group_b); 
     MPI_Group_free(&amp;group_world); 
     MPI_Finalize(); 
     return 0;  
   } 
</tt></pre> 
 The library:  
<br> 
<pre><tt>   void lib_call(MPI_Comm comm) 
   { 
     int me, done = 0; 
     MPI_Status status;  
     MPI_Comm_rank(comm, &amp;me); 
     if(me == 0) 
        while(!done) 
        { 
           MPI_Recv(..., MPI_ANY_SOURCE, MPI_ANY_TAG, comm, &amp;status); 
           ... 
        } 
     else 
     { 
       /* work */ 
       MPI_Send(..., 0, ARBITRARY_TAG, comm); 
       .... 
     } 
#ifdef EXAMPLE_2C 
     /* include (resp, exclude) for safety (resp, no safety): */ 
     MPI_Barrier(comm); 
#endif 
   } 
</tt></pre> 
The above example is really three examples, depending on whether or  
not one includes rank 3 in <font face="sans-serif"> list_b</font>, and whether or not a  
synchronize is included in <font face="sans-serif"> lib_call</font>.  This example illustrates  
that, despite contexts, subsequent calls to <font face="sans-serif"> lib_call</font> with the  
same context need not be safe from one another (colloquially,  
``back-masking'').  Safety is realized if the <font face="sans-serif"> MPI_Barrier</font> is  
added.  What this demonstrates is that libraries have to be written  
carefully, even with contexts.  When rank 3 is excluded, then  
the synchronize is not needed to get safety from  
back-masking.   
<P> 
Algorithms like ``reduce'' and ``allreduce'' have strong enough source  
selectivity properties so that they are inherently okay (no  
back-masking),   
provided that <font face="sans-serif"> MPI</font> provides basic guarantees.  So are multiple calls to a  
typical tree-broadcast algorithm with the same root or different roots  
(see [<a href="node522.htm#-Bib57">57</a>]).    
Here we rely on two guarantees of <font face="sans-serif"> MPI</font>: pairwise ordering of  
messages between processes in the same context, and source selectivity ---  
deleting either feature removes the guarantee that  
back-masking cannot   
be required.  
<P> 
Algorithms that try to do non-deterministic broadcasts or other calls that  
include wildcard operations will not generally have the good properties of the  
deterministic implementations of ``reduce,'' ``allreduce,'' and ``broadcast.''  
Such algorithms would have to utilize the monotonically increasing tags  
(within a communicator scope) to keep things straight.  
<P> 
All of the foregoing is a supposition of ``collective calls'' implemented with  
point-to-point operations.  <font face="sans-serif"> MPI</font> implementations may or may not implement  
collective calls using point-to-point operations.  These algorithms are used  
to illustrate the issues of correctness and safety, independent of how <font face="sans-serif"> MPI</font>  
implements its collective calls.  See also Section <a href="node180.htm#Node180">Formalizing the Loosely Synchronous Model 
</a>.  
<P> 

<P>
<hr>
<a href="node164.htm#Node164"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node159.htm#Node159"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node166.htm#Node166"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node159.htm#Node159"> Motivating Examples</a>
<b>Next: </b><a href="node166.htm#Node166"> Inter-Communication</a>
<b>Previous: </b><a href="node164.htm#Node164"> Library Example #1</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
