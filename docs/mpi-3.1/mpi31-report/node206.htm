<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-topol/topol.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>An Application Example</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node206">194. An Application Example</span></h1>
<a href="node205.htm#Node205"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node207.htm#Node207"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node207.htm#Node207"> <font face="sans-serif"> MPI</font> Environmental Management</a>
<b>Previous: </b><a href="node205.htm#Node205"> Nonblocking Neighborhood Alltoall</a>
<p>
  
<P> 
<br><b> Example</b>  
  
The example in   
Figures <a href="node206.htm#Figure18">18 
</a>-<a href="node206.htm#Node206">An Application Example 
</a>   
shows how the grid definition and  
inquiry functions can be used in an application program. A partial  
differential equation, for instance the Poisson equation, is to be  
solved on a rectangular domain.  
First, the processes organize themselves in a two-dimensional  
structure. Each process then inquires about the ranks of its  
neighbors in the four directions (up, down, right, left).  
The numerical problem is solved by an iterative method, the details  
of which are hidden in the subroutine <tt>relax</tt>.  
<P> 
In each relaxation step each process computes new values for the solution grid  
function at the points <tt>u(1:100,1:100)</tt>  
owned by the process. Then the values at inter-process  
boundaries have to be exchanged with neighboring processes.  
For example, the  
newly calculated values in <tt>u(1,1:100)</tt>  
must be sent into the halo cells <tt>u(101,1:100)</tt>  
of the left-hand neighbor with coordinates <tt>(own_coord(1)-1,own_coord(2))</tt>.  
  
<P> 
<br> 
<pre><tt>INTEGER ndims, num_neigh 
LOGICAL reorder 
PARAMETER (ndims=2, num_neigh=4, reorder=.true.) 
INTEGER comm, comm_cart, dims(ndims), ierr 
INTEGER neigh_rank(num_neigh), own_coords(ndims), i, j, it 
LOGICAL periods(ndims) 
REAL u(0:101,0:101), f(0:101,0:101) 
DATA dims / ndims * 0 / 
comm = MPI_COMM_WORLD 
!   Set process grid size and periodicity 
CALL MPI_DIMS_CREATE(comm, ndims, dims, ierr) 
periods(1) = .TRUE. 
periods(2) = .TRUE. 
!   Create a grid structure in WORLD group and inquire about own position 
CALL MPI_CART_CREATE (comm, ndims, dims, periods, reorder, &amp; 
                      comm_cart, ierr) 
CALL MPI_CART_GET (comm_cart, ndims, dims, periods, own_coords, ierr) 
i = own_coords(1) 
j = own_coords(2) 
! Look up the ranks for the neighbors.  Own process coordinates are (i,j). 
! Neighbors are (i-1,j), (i+1,j), (i,j-1), (i,j+1) modulo (dims(1),dims(2)) 
CALL MPI_CART_SHIFT (comm_cart, 0,1,  neigh_rank(1),neigh_rank(2), ierr) 
CALL MPI_CART_SHIFT (comm_cart, 1,1,  neigh_rank(3),neigh_rank(4), ierr) 
! Initialize the grid functions and start the iteration 
CALL init (u, f) 
DO it=1,100 
   CALL relax (u, f) 
!      Exchange data with neighbor processes 
   CALL exchange (u, comm_cart, neigh_rank, num_neigh) 
END DO 
CALL output (u) 
</tt></pre> 
<br> 
<b>Figure 18: </b><span id="Figure18">Set-up of process structure for two-dimensional
parallel Poisson solver.</span><P> 
  
  
<br> 
<pre><tt>SUBROUTINE exchange (u, comm_cart, neigh_rank, num_neigh) 
REAL u(0:101,0:101) 
INTEGER comm_cart, num_neigh, neigh_rank(num_neigh) 
REAL sndbuf(100,num_neigh), rcvbuf(100,num_neigh) 
INTEGER ierr  
sndbuf(1:100,1) = u(  1,1:100) 
sndbuf(1:100,2) = u(100,1:100) 
sndbuf(1:100,3) = u(1:100,  1) 
sndbuf(1:100,4) = u(1:100,100) 
CALL MPI_NEIGHBOR_ALLTOALL (sndbuf, 100, MPI_REAL, rcvbuf, 100, MPI_REAL, &amp; 
                            comm_cart, ierr)  
! instead of  
! DO i=1,num_neigh 
!   CALL MPI_IRECV(rcvbuf(1,i),100,MPI_REAL,neigh_rank(i),...,rq(2*i-1),&amp; 
!                  ierr) 
!   CALL MPI_ISEND(sndbuf(1,i),100,MPI_REAL,neigh_rank(i),...,rq(2*i  ),&amp; 
!                  ierr) 
! END DO  
! CALL MPI_WAITALL (2*num_neigh, rq, statuses, ierr) 
  
u(  0,1:100) = rcvbuf(1:100,1)  
u(101,1:100) = rcvbuf(1:100,2)  
u(1:100,  0) = rcvbuf(1:100,3)  
u(1:100,101) = rcvbuf(1:100,4)  
END 
</tt></pre> 
<br> 
<b>Figure 19: </b><span id="Figure19">Communication routine with local data copying and sparse neighborhood all-to-all.</span><P> 
  
<P><span id="node206.htm#Figure19"><img width=451 height=495 src="img180.gif" alt="Image file"></span><P>
<br> 
Communication routine with sparse neighborhood all-to-all-w and without local data copying.<P> 
  
  
  
<P> 
<P> 
  

<P>
<hr>
<a href="node205.htm#Node205"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node207.htm#Node207"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node207.htm#Node207"> <font face="sans-serif"> MPI</font> Environmental Management</a>
<b>Previous: </b><a href="node205.htm#Node205"> Nonblocking Neighborhood Alltoall</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
