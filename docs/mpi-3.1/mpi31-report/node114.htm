<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-coll/coll.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>MINLOC and MAXLOC</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node114">109. MINLOC and MAXLOC</span></h2>
<a href="node113.htm#Node113"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node110.htm#Node110"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node115.htm#Node115"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node110.htm#Node110"> Global Reduction Operations</a>
<b>Next: </b><a href="node115.htm#Node115"> User-Defined Reduction Operations</a>
<b>Previous: </b><a href="node113.htm#Node113"> Signed Characters and Reductions</a>
<p>
  
<P> 
The operator <font face="sans-serif">  MPI_MINLOC</font> is used to compute  
a global minimum and also  
an index attached to the minimum value.  
<font face="sans-serif">  MPI_MAXLOC</font> similarly computes a global maximum and index.  
One application of these is to compute a global minimum (maximum) and the  
rank of the process containing this value.  
<P> 
The operation that defines <font face="sans-serif">  MPI_MAXLOC</font> is:  
<P> 
<P><img width=118 height=29 src="img117.gif" alt="Image file"><P>
  
where  
<P><img width=67 height=10 src="img118.gif" alt="Image file"><P>
  
and  
<P><img width=120 height=42 src="img119.gif" alt="Image file"><P>
  
<P> 
<font face="sans-serif">  MPI_MINLOC</font> is defined similarly:  
<P> 
<P><img width=118 height=29 src="img120.gif" alt="Image file"><P>
  
where  
<P><img width=65 height=10 src="img121.gif" alt="Image file"><P>
  
and  
<P><img width=120 height=42 src="img122.gif" alt="Image file"><P>
  
<P> 
Both operations are associative and commutative.  
Note that if <font face="sans-serif">  MPI_MAXLOC</font>  
is applied to reduce a sequence of pairs  
<i>(u<SUB>0</SUB>, 0), (u<SUB>1</SUB>, 1) , ..., (u<SUB>n-1</SUB> , n-1)</i>, then the value  
returned is <i>(u , r)</i>, where <img width=54 height=6 src="img123.gif" alt="Image file">
 and <i>r</i> is the index of  
the first global maximum in the sequence.  Thus, if each process  
supplies a value and its rank within the group, then a reduce  
operation with <font face="sans-serif"> op</font> = <font face="sans-serif">  MPI_MAXLOC</font> will return the  
maximum value and the rank of the first process with that value.  
Similarly, <font face="sans-serif">  MPI_MINLOC</font> can be used to return a minimum and its  
index.  
More generally, <font face="sans-serif">  MPI_MINLOC</font> computes a <em> lexicographic  
minimum</em>, where elements are ordered according to the first component  
of each pair, and ties are resolved according to the second component.  
<P> 
The reduce operation is defined to operate on arguments that  
consist of a pair: value and index.  
For both Fortran and C, types are provided to describe the pair.  
The potentially mixed-type nature of such arguments  
is a problem in Fortran.  The problem is circumvented, for Fortran, by  
having the <font face="sans-serif"> MPI</font>-provided type consist of a pair of the same type as  
value, and coercing the index to this type also.  In C, the <font face="sans-serif"> MPI</font>-provided  
pair type has distinct types and the index is an <tt>int</tt>.  
<P> 
In order to use <font face="sans-serif">  MPI_MINLOC</font> and <font face="sans-serif">  MPI_MAXLOC</font> in a  
reduce operation, one must provide a <font face="sans-serif"> datatype</font> argument  
that represents a pair (value and index).  <font face="sans-serif"> MPI</font> provides  
nine  
such predefined datatypes.  The operations <font face="sans-serif">  MPI_MAXLOC</font> and  
<font face="sans-serif">  MPI_MINLOC</font> can be used with each of the following datatypes.  
<P><img width=347 height=75 src="img124.gif" alt="Image file"><P>
<P><img width=302 height=101 src="img125.gif" alt="Image file"><P>
The datatype <font face="sans-serif">  MPI_2REAL</font> is <em> as if</em> defined by the following  
(see Section <a href="node77.htm#Node77">Derived Datatypes 
</a>).  
<P> 
<br> 
<pre><tt>MPI_TYPE_CONTIGUOUS(2, MPI_REAL, MPI_2REAL) 
</tt></pre> 
Similar statements apply for <font face="sans-serif">  MPI_2INTEGER</font>,  
<font face="sans-serif">  MPI_2DOUBLE_PRECISION</font>, and <font face="sans-serif">  MPI_2INT</font>.  
<P> 
The datatype <font face="sans-serif">  MPI_FLOAT_INT</font> is <em> as if</em> defined by the  
following sequence of instructions.  
<br> 
<pre><tt>type[0] = MPI_FLOAT 
type[1] = MPI_INT 
disp[0] = 0 
disp[1] = sizeof(float) 
block[0] = 1 
block[1] = 1 
MPI_TYPE_CREATE_STRUCT(2, block, disp, type, MPI_FLOAT_INT) 
</tt></pre> 
Similar statements apply for <font face="sans-serif">  MPI_LONG_INT</font>  
and <font face="sans-serif">  MPI_DOUBLE_INT</font>.  
<P> 
The following examples use intracommunicators.  
 <P> 
<br><b> Example</b>  
  
  
Each process has an array of 30 <tt> double</tt>s, in C.  For each  
of the 30 locations, compute the value and rank of the process containing  
the largest value.  
<P> 
<br> 
<pre><tt>    ... 
    /* each process has an array of 30 double: ain[30] 
     */ 
    double ain[30], aout[30]; 
    int  ind[30]; 
    struct { 
        double val; 
        int   rank; 
    } in[30], out[30]; 
    int i, myrank, root; 
 
    MPI_Comm_rank(comm, &amp;myrank); 
    for (i=0; i&lt;30; ++i) { 
        in[i].val = ain[i]; 
        in[i].rank = myrank; 
    } 
    MPI_Reduce(in, out, 30, MPI_DOUBLE_INT, MPI_MAXLOC, root, comm); 
    /* At this point, the answer resides on process root 
     */ 
    if (myrank == root) { 
        /* read ranks out 
         */ 
        for (i=0; i&lt;30; ++i) { 
            aout[i] = out[i].val; 
            ind[i] = out[i].rank; 
        } 
    } 
</tt></pre> 
  
<P> 
<br><b> Example</b>  
  
  
Same example, in Fortran.  
<P> 
<br> 
<pre><tt>    ... 
    ! each process has an array of 30 double: ain(30) 
 
    DOUBLE PRECISION ain(30), aout(30) 
    INTEGER ind(30) 
    DOUBLE PRECISION in(2,30), out(2,30) 
    INTEGER i, myrank, root, ierr 
 
    CALL MPI_COMM_RANK(comm, myrank, ierr) 
    DO I=1, 30 
        in(1,i) = ain(i) 
        in(2,i) = myrank    ! myrank is coerced to a double 
    END DO 
 
    CALL MPI_REDUCE(in, out, 30, MPI_2DOUBLE_PRECISION, MPI_MAXLOC, root, 
                                                               comm, ierr) 
    ! At this point, the answer resides on process root 
 
    IF (myrank .EQ. root) THEN 
        ! read ranks out 
        DO I= 1, 30 
            aout(i) = out(1,i) 
            ind(i) = out(2,i)  ! rank is coerced back to an integer 
        END DO 
    END IF 
</tt></pre> 
  
<P> 
<br><b> Example</b>  
  
  
Each process has a non-empty array of values.  
Find the minimum global value, the rank of the process that holds it  
and its index on this process.  
<P> 
<br> 
<pre><tt>#define  LEN   1000 
 
float val[LEN];        /* local array of values */ 
int count;             /* local number of values */ 
int myrank, minrank, minindex; 
float minval; 
 
struct { 
    float value; 
    int   index; 
} in, out; 
 
    /* local minloc */ 
in.value = val[0]; 
in.index = 0; 
for (i=1; i &lt; count; i++) 
    if (in.value &gt; val[i]) { 
        in.value = val[i]; 
        in.index = i; 
    } 
 
    /* global minloc */ 
MPI_Comm_rank(comm, &amp;myrank); 
in.index = myrank*LEN + in.index; 
MPI_Reduce( &amp;in, &amp;out, 1, MPI_FLOAT_INT, MPI_MINLOC, root, comm ); 
    /* At this point, the answer resides on process root 
     */ 
if (myrank == root) { 
    /* read answer out 
     */ 
    minval = out.value; 
    minrank = out.index / LEN; 
    minindex = out.index % LEN; 
} 
</tt></pre> 
  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The definition of <font face="sans-serif">  MPI_MINLOC</font> and <font face="sans-serif">  MPI_MAXLOC</font> given  
here has the advantage that it does not require any special-case  
handling of these two operations: they are handled like any other  
reduce operation.  A programmer can provide his or her own definition  
of <font face="sans-serif">  MPI_MAXLOC</font> and <font face="sans-serif">  MPI_MINLOC</font>, if so desired.  
The disadvantage is that values and indices have to be first  
interleaved, and that indices and values have to be coerced to the  
same type, in Fortran.  
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node113.htm#Node113"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node110.htm#Node110"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node115.htm#Node115"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node110.htm#Node110"> Global Reduction Operations</a>
<b>Next: </b><a href="node115.htm#Node115"> User-Defined Reduction Operations</a>
<b>Previous: </b><a href="node113.htm#Node113"> Signed Characters and Reductions</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
