<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-io/io-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Data Access Routines</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node319">293. Data Access Routines</span></h2>
<a href="node318.htm#Node318"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node318.htm#Node318"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node319.htm#Node320"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node318.htm#Node318"> Data Access</a>
<b>Next: </b><a href="node319.htm#Node320"> Positioning</a>
<b>Previous: </b><a href="node318.htm#Node318"> Data Access</a>
<p>
  
Data is moved between files and processes by issuing read and write calls.  
There are three orthogonal aspects to data access:  
positioning (explicit offset <em> vs.</em> implicit file pointer),  
synchronism (blocking <em> vs.</em> nonblocking and split collective),  
and coordination (noncollective <em> vs.</em> collective).  
The following combinations of these data access routines,  
including two types of file pointers (individual and shared)  
are provided in Table <a href="node319.htm#Table10">10 
</a>.  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="LEFT">  
<b> positioning</b></TD><TD ALIGN="LEFT"> <b> synchronism</b></TD><TD ALIGN="LEFT"> <TD ALIGN="CENTER" COLSPAN=2><b> coordination</b> </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <em> noncollective</em></TD><TD ALIGN="LEFT"> <em> collective</em> </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
<em> explicit</em></TD><TD ALIGN="LEFT"> <em> blocking</em>  
</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_AT</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_AT_ALL</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
<em> offsets</em></TD><TD ALIGN="LEFT">   
</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_AT</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_AT_ALL</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD><TD ALIGN="LEFT"> <em> nonblocking</em>   
</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IREAD_AT</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IREAD_AT_ALL</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IWRITE_AT</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IWRITE_AT_ALL</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD><TD ALIGN="LEFT"> <em> split collective</em></TD><TD ALIGN="LEFT"> N/A</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_AT_ALL_BEGIN</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_AT_ALL_END</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_AT_ALL_BEGIN</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_AT_ALL_END</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
<em> individual</em></TD><TD ALIGN="LEFT"> <em> blocking</em>  
</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_ALL</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
<em> file pointers</em></TD><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_ALL</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD><TD ALIGN="LEFT"> <em> nonblocking</em>  
</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IREAD</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IREAD_ALL</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IWRITE</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IWRITE_ALL</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD><TD ALIGN="LEFT"> <em> split collective</em></TD><TD ALIGN="LEFT"> N/A</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_ALL_BEGIN</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_ALL_END</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_ALL_BEGIN</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_ALL_END</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
<em> shared</em></TD><TD ALIGN="LEFT"> <em> blocking</em>  
</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_SHARED</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_ORDERED</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
<em> file pointer</em></TD><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_SHARED</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_ORDERED</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD><TD ALIGN="LEFT"> <em> nonblocking</em>  
</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IREAD_SHARED</font></TD><TD ALIGN="LEFT"> N/A </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_IWRITE_SHARED</font></TD><TD ALIGN="LEFT"> </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD><TD ALIGN="LEFT"> <em> split collective</em></TD><TD ALIGN="LEFT"> N/A</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_ORDERED_BEGIN</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_READ_ORDERED_END</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_ORDERED_BEGIN</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_FILE_WRITE_ORDERED_END</font> </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</div>  
<br> 
<b>Table 10: </b><span id="Table10">Data access routines</span><P> 
   
  
POSIX <tt>read()</tt>/<tt>fread()</tt> and <tt>write()</tt>/<tt>fwrite()</tt> are blocking,  
noncollective operations and use individual file pointers.  
The <font face="sans-serif"> MPI</font> equivalents are <font face="sans-serif"> MPI_FILE_READ</font> and <font face="sans-serif"> MPI_FILE_WRITE</font>.  
<P> 
Implementations of data access routines may buffer data to improve  
performance.  This does not affect reads, as the data is always  
available in the user's buffer after a read operation completes.  
For writes, however, the <font face="sans-serif"> MPI_FILE_SYNC</font> routine provides the only  
guarantee that data has been transferred to the storage device.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node318.htm#Node318"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node318.htm#Node318"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node319.htm#Node320"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node318.htm#Node318"> Data Access</a>
<b>Next: </b><a href="node319.htm#Node320"> Positioning</a>
<b>Previous: </b><a href="node318.htm#Node318"> Data Access</a>
<p>
<hr><h3><span id="Node320">293.1. Positioning</span></h3>
<a href="node319.htm#Node319"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node319.htm#Node319"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node319.htm#Node321"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<b>Next: </b><a href="node319.htm#Node321"> Synchronism</a>
<b>Previous: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<p>
  
<font face="sans-serif"> MPI</font> provides three types of positioning for data access routines:  
<b> explicit offsets</b>, <b> individual file pointers</b>, and <b> shared file pointers</b>.  
The different positioning methods may be mixed within the same program  
and do not affect each other.  
<P> 
The data access routines that accept explicit offsets  
contain <font face="sans-serif"> _AT</font>  
in their name (e.g., <font face="sans-serif"> MPI_FILE_WRITE_AT</font>).  
Explicit offset operations perform data access at  
the file position given directly as an argument --- no  
file pointer is used nor updated.  
Note that this is not equivalent to an atomic seek-and-read  
or seek-and-write operation,  
as no ``seek'' is issued.  
Operations with explicit offsets are described in  
Section <a href="node324.htm#Node324">Data Access with Explicit Offsets 
</a>.  
<P> 
The names of the individual file pointer routines contain no  
positional qualifier (e.g., <font face="sans-serif"> MPI_FILE_WRITE</font>).  
Operations with individual file pointers are described in  
Section <a href="node325.htm#Node325">Data Access with Individual File Pointers 
</a>.  
The data access routines that use shared file pointers contain  
<font face="sans-serif"> _SHARED</font>   
or <font face="sans-serif"> _ORDERED</font>   
in their name (e.g., <font face="sans-serif"> MPI_FILE_WRITE_SHARED</font>).  
Operations with shared file pointers are described in  
Section <a href="node326.htm#Node326">Data Access with Shared File Pointers 
</a>.  
<P> 
The main semantic issues with <font face="sans-serif"> MPI</font>-maintained file pointers  
are how and when they are updated by I/O operations.  
In general, each I/O operation leaves the file pointer pointing to the  
next data item after the last one that  
is accessed by the operation.  
In a nonblocking or split collective operation,  
the pointer is updated by the call that initiates the I/O,  
possibly before the access completes.  
<P> 
More formally,  
<p><i> 
    textitnew_file_offset = textitold_file_offset + 
                fracelements(datatype)elements(etype) &#215; count 
</i><p>  
where <i>count</i> is the number of <i>datatype</i> items to be accessed,  
<i>elements(X)</i> is the number of predefined datatypes in the typemap of <i>X</i>,  
and <em> old_file_offset</em> is  
the value of the implicit offset before the call.  
The file position, <em> new_file_offset</em>, is in terms  
of a count of etypes relative to the current view.  
<P> 

<P>
<hr>
<a href="node319.htm#Node319"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node319.htm#Node319"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node319.htm#Node321"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<b>Next: </b><a href="node319.htm#Node321"> Synchronism</a>
<b>Previous: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<p>
<hr><h3><span id="Node321">293.2. Synchronism</span></h3>
<a href="node319.htm#Node320"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node319.htm#Node319"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node319.htm#Node322"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<b>Next: </b><a href="node319.htm#Node322"> Coordination</a>
<b>Previous: </b><a href="node319.htm#Node320"> Positioning</a>
<p>
  
<font face="sans-serif"> MPI</font> supports blocking and nonblocking I/O routines.  
<P> 
A <em> blocking</em> I/O call will  
not return  
until the I/O request is completed.  
<P> 
A <em> nonblocking</em> I/O call initiates an I/O operation, but does not  
wait for it to complete.  Given suitable hardware, this allows the  
transfer of data out of and into the user's buffer to proceed concurrently with  
computation.  A separate <em> request complete</em> call  
(<font face="sans-serif"> MPI_WAIT</font>, <font face="sans-serif"> MPI_TEST</font>, or any of their variants) is  
needed to complete the I/O request,  
i.e., to confirm that the data has been read or written and that  
it is safe for the user to reuse the buffer.  
The nonblocking versions of the routines are named  
<font face="sans-serif"> MPI_FILE_I</font><font face="sans-serif"> XXX</font></font>, where the <font face="sans-serif"> I</font> stands for immediate.  
<P> 
It is erroneous to access the local buffer of a nonblocking  
data access operation, or to use that buffer as the source or  
target of other communications, between the initiation and  
completion of the operation.   
<P> 
The split collective routines  
support a restricted form of ``nonblocking'' operations  
for collective data access  
(see Section <a href="node330.htm#Node330">Split Collective Data Access Routines 
</a>).  
<P> 

<P>
<hr>
<a href="node319.htm#Node320"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node319.htm#Node319"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node319.htm#Node322"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<b>Next: </b><a href="node319.htm#Node322"> Coordination</a>
<b>Previous: </b><a href="node319.htm#Node320"> Positioning</a>
<p>
<hr><h3><span id="Node322">293.3. Coordination</span></h3>
<a href="node319.htm#Node321"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node319.htm#Node319"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node319.htm#Node323"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<b>Next: </b><a href="node319.htm#Node323"> Data Access Conventions</a>
<b>Previous: </b><a href="node319.htm#Node321"> Synchronism</a>
<p>
  
Every noncollective data access routine <font face="sans-serif"> MPI_FILE_</font><font face="sans-serif"> XXX</font></font>  
has a collective counterpart.  For most routines, this counterpart  
is <font face="sans-serif"> MPI_FILE_</font><font face="sans-serif"> XXX</font>_ALL</font> or a pair of   
<font face="sans-serif"> MPI_FILE_</font><font face="sans-serif"> XXX</font>_BEGIN</font> and   
<font face="sans-serif"> MPI_FILE_</font><font face="sans-serif"> XXX</font>_END</font>.  
The counterparts to the <font face="sans-serif"> MPI_FILE_</font><font face="sans-serif"> XXX</font>_SHARED</font> routines are   
<font face="sans-serif"> MPI_FILE_</font><font face="sans-serif"> XXX</font>_ORDERED</font>.  
<P> 
The completion of a noncollective call only depends on the activity of  
the calling process.  
However, the completion of a collective call  
(which must be called by all members of the process group)  
may depend on the activity  
of the other processes participating in the collective call.  
See Section <a href="node342.htm#Node342">Collective File Operations 
</a>  
for rules on semantics of collective calls.  
<P> 
Collective operations  
may perform much better than their noncollective counterparts,  
as global data accesses have significant potential for automatic optimization.  
<P> 

<P>
<hr>
<a href="node319.htm#Node321"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node319.htm#Node319"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node319.htm#Node323"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<b>Next: </b><a href="node319.htm#Node323"> Data Access Conventions</a>
<b>Previous: </b><a href="node319.htm#Node321"> Synchronism</a>
<p>
<hr><h3><span id="Node323">293.4. Data Access Conventions</span></h3>
<a href="node319.htm#Node322"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node319.htm#Node319"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node324.htm#Node324"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<b>Next: </b><a href="node324.htm#Node324"> Data Access with Explicit Offsets</a>
<b>Previous: </b><a href="node319.htm#Node322"> Coordination</a>
<p>
  
<P> 
Data is moved between files and processes  
by calling read and write routines.  
Read routines move data from a file into memory.  
Write routines move data from memory into a file.  
The file is designated by a file handle, <font face="sans-serif"> fh</font>.  
The location of the file data is specified by an offset  
into the current view.  
The data in memory is specified by a triple:  
<font face="sans-serif"> buf</font>, <font face="sans-serif"> count</font>, and <font face="sans-serif"> datatype</font>.  
Upon completion, the amount of data accessed  
by the calling process is returned in a <font face="sans-serif"> status</font>.  
<P> 
An offset designates the starting position in the file for an access.  
The offset is always in etype units relative to the current view.  
Explicit offset routines pass <font face="sans-serif"> offset</font> as an argument  
(negative values are erroneous).  
The file pointer routines use implicit offsets maintained by <font face="sans-serif"> MPI</font>.  
<P> 
A data access routine attempts to transfer (read or write)  
<font face="sans-serif"> count</font> data items  
of type <font face="sans-serif"> datatype</font> between the user's buffer <font face="sans-serif"> buf</font>  
and the file.  
The <font face="sans-serif"> datatype</font> passed to the routine must be   
a committed datatype.  
The layout of data in memory corresponding to  
<font face="sans-serif"> buf</font>, <font face="sans-serif"> count</font>, <font face="sans-serif"> datatype</font> is  
interpreted the same way as in   
<font face="sans-serif"> MPI</font>   
communication functions;  
see Section <a href="node48.htm#Node48">Message Data 
</a> and   
Section <a href="node88.htm#Node88">Use of General Datatypes in Communication 
</a>.   
The data is accessed  
from those parts of the file specified by the current view  
(Section <a href="node317.htm#Node317">File Views 
</a>).  
The type signature of <font face="sans-serif"> datatype</font> must match  
the type signature of some number of contiguous copies of the <font face="sans-serif"> etype</font>  
of the current view.  
As in a receive,  
it is erroneous to specify a <font face="sans-serif"> datatype</font>  
for reading that contains overlapping regions  
(areas of memory which would be stored into more than once).  
<P> 
The nonblocking data access routines  
indicate that <font face="sans-serif"> MPI</font> can start a data access  
and associate a request handle, <font face="sans-serif"> request</font>,  
with the I/O   
operation.  
Nonblocking operations are completed via  
<font face="sans-serif"> MPI_TEST</font>, <font face="sans-serif"> MPI_WAIT</font>, or any of their variants.  
<P> 
Data access operations, when completed,  
return the amount of data accessed in <font face="sans-serif"> status</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
To prevent problems with the argument copying and register  
optimization done by Fortran compilers, please note the hints in  
Sections <a href="node420.htm#Node420">Problems With Fortran Bindings for <font face="sans-serif"> MPI</font> 
</a>--<a href="node441.htm#Node441">Comparison with C 
</a>.  
 (<em> End of advice to users.</em>) <br> 
For blocking routines, <font face="sans-serif"> status</font> is returned directly.  
For nonblocking routines and split collective routines,  
<font face="sans-serif"> status</font> is returned when the operation is completed.  
The number of <font face="sans-serif"> datatype</font> entries and predefined elements accessed  
by the calling process  
can be extracted from <font face="sans-serif"> status</font> by using  
<font face="sans-serif"> MPI_GET_COUNT</font> and  
<font face="sans-serif"> MPI_GET_ELEMENTS</font> (or  
  <font face="sans-serif"> MPI_GET_ELEMENTS_X</font>), respectively.  
The interpretation of the <font face="sans-serif"> MPI_ERROR</font> field is the same as for other  
operations --- normally undefined, but meaningful if an <font face="sans-serif"> MPI</font> routine returns   
<font face="sans-serif">  MPI_ERR_IN_STATUS</font>.  
The user can pass (in C and  
Fortran)  
<font face="sans-serif">  MPI_STATUS_IGNORE</font>  
in the <font face="sans-serif"> status</font> argument  
if the return value of this argument is not needed.  
The <font face="sans-serif"> status</font> can be passed to <font face="sans-serif"> MPI_TEST_CANCELLED</font>  
to determine if the operation was cancelled.  
All other fields of <font face="sans-serif"> status</font> are undefined.  
<P> 
When reading, a program can detect the end of file  
by noting that the amount of data read is less than the amount requested.  
Writing past the end of file increases the file size.  
The amount of data accessed will be the amount requested,  
unless an error is raised (or a read reaches the end of file).  
<P> 

<P>
<hr>
<a href="node319.htm#Node322"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node319.htm#Node319"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node324.htm#Node324"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node319.htm#Node319"> Data Access Routines</a>
<b>Next: </b><a href="node324.htm#Node324"> Data Access with Explicit Offsets</a>
<b>Previous: </b><a href="node319.htm#Node322"> Coordination</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
