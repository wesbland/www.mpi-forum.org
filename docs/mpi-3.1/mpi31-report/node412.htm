<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Interface Specifications, Procedure Names, and the Profiling Interface</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node412">359. Interface Specifications, Procedure Names, and the Profiling Interface</span></h2>
<a href="node411.htm#Node411"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node413.htm#Node413"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node413.htm#Node413"> <font face="sans-serif"> MPI</font> for Different Fortran Standard Versions</a>
<b>Previous: </b><a href="node411.htm#Node411"> Fortran Support Through the <tt>mpif.h</tt> Include File</a>
<p>
  
<P> 
The Fortran interface specification of each <font face="sans-serif"> MPI</font> routine  
specifies the routine name that must be called by the application program,  
and the names and types of the dummy arguments together with  
additional attributes.  
The Fortran standard allows  
a given Fortran interface to be implemented  
with several methods, e.g., within or outside of a module,  
with or without <tt> BIND(C)</tt>, or the buffers with or without TS 29113.  
Such implementation decisions imply different binary interfaces  
and different specific procedure names.  
The requirements for  
several implementation schemes together with the  
rules for the specific procedure names and  
its implications for the profiling interface are specified   
within this section, but not the implementation details.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
This section was introduced in <font face="sans-serif"> MPI-3.0</font> on Sep. 21, 2012.  
The major goals for implementing the three  
Fortran support methods have been:  
<ul> 
   
<li>Portable implementation of the wrappers  
  from the <font face="sans-serif"> MPI</font> Fortran interfaces to the <font face="sans-serif"> MPI</font> routines in C.  
   
<li>Binary backward compatible implementation path when switching  
  <font face="sans-serif">  MPI_SUBARRAYS_SUPPORTED</font> from <tt> .FALSE.</tt> to <tt> .TRUE.</tt>.  
   
<li>The Fortran <font face="sans-serif"> PMPI</font> interface need not be backward compatible,  
  but a method must be included that a tools layer can use to examine the  
  <font face="sans-serif"> MPI</font> library about the specific procedure names and interfaces used.  
   
<li>No performance drawbacks.  
   
<li>Consistency between all three Fortran support methods.  
   
<li>Consistent with Fortran 2008 + TS 29113.  
</ul> 
<br> 
The design expected that all dummy arguments in the  
<font face="sans-serif"> MPI</font> Fortran interfaces are interoperable with C according  
to Fortran 2008 + TS 29113.  
This expectation was not fulfilled.  
The <tt> LOGICAL</tt> arguments are not interoperable with C,  
mainly because the internal representations for <tt> .FALSE.</tt> and  
<tt> .TRUE.</tt> are compiler dependent.  
The provided interface was mainly based on <tt> BIND(C)</tt> interfaces  
and therefore inconsistent with Fortran.  
To be consistent with Fortran, the <tt> BIND(C)</tt> had to be  
removed from the callback procedure interfaces and the predefined callbacks,  
e.g., <font face="sans-serif"> MPI_COMM_DUP_FN</font>.  
Non-<tt> BIND(C)</tt> procedures are also not interoperable with C,  
and therefore the <tt> BIND(C)</tt> had to be removed from all routines  
with <tt> PROCEDURE</tt> arguments,  
e.g., from <font face="sans-serif"> MPI_OP_CREATE</font>.  
<P> 
Therefore, this section was rewritten as an erratum to <font face="sans-serif"> MPI-3.0</font>.  
 (<em> End of rationale.</em>) <br> 
A Fortran call to an <font face="sans-serif"> MPI</font> routine shall result in a call to a procedure  
with one of the specific procedure names and calling conventions, as described in   
Table <a href="node412.htm#Table20">20 
</a>.  
Case is not significant in the names.  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="LEFT">  
No.</TD><TD ALIGN="LEFT"> Specific pro-</TD><TD ALIGN="CENTER"> Calling convention </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"> cedure name</TD><TD ALIGN="CENTER">                    </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
1A</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_Isend_f08</font>  
</TD><TD ALIGN="CENTER"> Fortran interface and arguments, as in Annex <a href="node484.htm#Node484">Fortran 2008 Bindings with the mpi_f08 Module 
</a>, except that  
                              in routines with a choice buffer dummy argument, this   
                              dummy argument is implemented with non-standard  
                              extensions like <tt> !$PRAGMA IGNORE_TKR</tt>, which  
                              provides a call-by-reference argument without type, kind,  
                              and dimension checking.  
</TD></TR> 
<TR><TD ALIGN="LEFT">  
1B</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_Isend_f08ts</font>  
</TD><TD ALIGN="CENTER"> Fortran interface and arguments, as in Annex <a href="node484.htm#Node484">Fortran 2008 Bindings with the mpi_f08 Module 
</a>,  
                              but only for routines with one or more choice buffer dummy arguments;  
                              these dummy arguments are implemented  
                              with <tt> TYPE(*), DIMENSION(..)</tt>.  
</TD></TR> 
<TR><TD ALIGN="LEFT">  
2A</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_ISEND</font>  
</TD><TD ALIGN="CENTER"> Fortran interface and arguments, as in Annex <a href="node498.htm#Node498">Fortran Bindings with mpif.h or the mpi Module 
</a>, except that  
                              in routines with a choice buffer dummy argument, this   
                              dummy argument is implemented with non-standard  
                              extensions like <tt> !$PRAGMA IGNORE_TKR</tt>, which  
                              provides a call-by-reference argument without type, kind,  
                              and dimension checking.  
</TD></TR> 
<TR><TD ALIGN="LEFT">  
2B</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_ISEND_FTS</font>  
</TD><TD ALIGN="CENTER"> Fortran interface and arguments, as in Annex <a href="node498.htm#Node498">Fortran Bindings with mpif.h or the mpi Module 
</a>,  
                              but only for routines with one or more choice buffer dummy arguments;  
                              these dummy arguments are implemented  
                              with <tt> TYPE(*), DIMENSION(..)</tt>.  
</TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</div>  
<br> 
<b>Table 20: </b><span id="Table20"></span><P> 
Specific Fortran procedure names and related calling conventions.  
<font face="sans-serif"> MPI_ISEND</font> is used as an example.  
For routines without choice buffers, only 1A and 2A apply.  
  
Note that for the deprecated routines in  
Section <a href="node396.htm#Node396">Deprecated since <font face="sans-serif"> MPI-2.0</font> 
</a>,  
which are reported only in  
Annex <a href="node498.htm#Node498">Fortran Bindings with mpif.h or the mpi Module 
</a>,  
scheme 2A is utilized in the <tt> mpi</tt> module and <tt> mpif.h</tt>,  
and also in the <tt> mpi_f08</tt> module.  
<P> 
To set <font face="sans-serif">  MPI_SUBARRAYS_SUPPORTED</font> to <tt> .TRUE.</tt>  
within a Fortran support method, it is required that  
all non-blocking and split-collective routines with buffer arguments  
are implemented according to 1B and 2B, i.e.,  
with <font face="sans-serif"> MPI_Xxxx_f08ts</font> in the <tt> mpi_f08</tt> module,  
and with <font face="sans-serif"> MPI_XXXX_FTS</font> in the <tt> mpi</tt> module  
and the <tt> mpif.h</tt> include file.  
 <P> 
The <tt> mpi</tt> and <tt> mpi_f08</tt> modules and the <tt> mpif.h</tt>  
include file  
will each correspond to exactly one implementation scheme from  
Table <a href="node412.htm#Table20">20 
</a>.  
However, the <font face="sans-serif"> MPI</font> library may contain multiple implementation schemes from  
Table <a href="node412.htm#Table20">20 
</a>.  
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
This may be desirable for backwards binary compatibility  
in the scope of a single <font face="sans-serif"> MPI</font> implementation, for example.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
 <P> 
After a compiler provides the facilities from TS 29113, i.e.,  
<tt> TYPE(*), DIMENSION(..)</tt>,  
it is possible to change the bindings within a Fortran support method  
to support subarrays  
without recompiling the complete application  
provided that the previous interfaces  
with their specific procedure names are still included in the library.  
Of course, only recompiled routines can benefit from the    
added facilities.  
There is no binary compatibility conflict   
because each interface uses its own  
specific procedure names and  
all interfaces use the same constants  
(except the value of <font face="sans-serif">  MPI_SUBARRAYS_SUPPORTED</font> and <font face="sans-serif">  MPI_ASYNC_PROTECTS_NONBLOCKING</font>)  
and type definitions.  
After a compiler also ensures that buffer arguments of nonblocking <font face="sans-serif"> MPI</font> operations  
can be protected through the <tt> ASYNCHRONOUS</tt> attribute,  
and the procedure declarations in the <tt> mpi_f08</tt> and <tt> mpi</tt> module   
and the <tt> mpif.h</tt> include file declare choice buffers  
with the <tt> ASYNCHRONOUS</tt> attribute, then  
the value of <font face="sans-serif">  MPI_ASYNC_PROTECTS_NONBLOCKING</font> can be switched to <tt> .TRUE.</tt>  
in the module definition and include file.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Partial recompilation of user applications when upgrading <font face="sans-serif"> MPI</font> implementations  
is a highly complex and subtle topic.  
Users are strongly advised to consult their <font face="sans-serif"> MPI</font> implementation's documentation  
to see exactly what is --- and what is not --- supported.  
 (<em> End of advice to users.</em>) <br> 
Within the <tt> mpi_f08</tt> and <tt> mpi</tt> modules and <tt> mpif.h</tt>,  
for all <font face="sans-serif"> MPI</font> procedures, a second  
procedure with the same calling conventions shall be  
supplied, except that the name is modified by prefixing with the  
letter ``P'', e.g., <font face="sans-serif"> PMPI_Isend</font>.  
The specific procedure names  
for these <font face="sans-serif"> PMPI_</font><font face="sans-serif"> Xxxx</font> procedures must be different from the  
specific procedure names for the <font face="sans-serif"> MPI_Xxxx</font> procedures  
and are not specified by this standard.  
<P> 
A user-written or middleware profiling routine  
should provide the same specific Fortran  
procedure names and calling conventions, and therefore  
can interpose itself as the <font face="sans-serif"> MPI</font> library routine.  
The profiling routine can internally call the matching <font face="sans-serif"> PMPI</font>  
routine with any of its existing bindings,  
except for routines that have callback routine dummy arguments,  
choice buffer arguments, or that are attribute caching routines  
(<font face="sans-serif"> MPI_ {COMM<i>|</i>WIN<i>|</i>TYPE }_ {SET<i>|</i>GET }_ATTR</font>).  
In this case, the profiling software  
should  
invoke the corresponding <font face="sans-serif"> PMPI</font> routine using  
the same Fortran  
support method as used in the calling application program,  
because the C, <tt> mpi_f08</tt> and <tt> mpi</tt> callback  
prototypes are different or the meaning of the choice buffer  
or <font face="sans-serif"> attribute_val</font> arguments are different.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Although for each support method and <font face="sans-serif"> MPI</font> routine  
(e.g., <font face="sans-serif"> MPI_ISEND</font> in <tt> mpi_f08</tt>),  
multiple routines may need to be provided to intercept the  
specific procedures in the <font face="sans-serif"> MPI</font> library  
(e.g., <font face="sans-serif"> MPI_Isend_f08</font> and <font face="sans-serif"> MPI_Isend_f08ts</font>),  
each profiling routine itself uses only one support method  
(e.g., <tt> mpi_f08</tt>)  
and calls the real <font face="sans-serif"> MPI</font> routine through the one  
<font face="sans-serif"> PMPI</font> routine defined in this support method  
(i.e., <font face="sans-serif"> PMPI_Isend</font> in this example).  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
If all of the following conditions are fulfilled:  
<ul> 
 
<li>the handles in the <tt> mpi_f08</tt> module occupy one Fortran  
   numerical storage unit (same as an <tt> INTEGER</tt> handle),   
 
<li>the internal argument passing mechanism used to pass an actual <font face="sans-serif"> ierror</font>  
   argument to a non-optional <font face="sans-serif"> ierror</font> dummy argument is binary  
   compatible to passing an actual <font face="sans-serif"> ierror</font> argument to an <font face="sans-serif"> ierror</font>   
   dummy argument that is declared as <tt> OPTIONAL</tt>,   
 
<li>the internal argument passing mechanism for <tt> ASYNCHRONOUS</tt> and   
   non-<tt> ASYNCHRONOUS</tt> arguments is the same,   
 
<li>the internal routine call mechanism is the same for   
   the Fortran and the C compilers for which the <font face="sans-serif"> MPI</font> library is compiled,  
 
<li>the compiler does not provide TS 29113,  
</ul> 
<br> 
then the implementor may use the same  
internal routine implementations for all Fortran support   
methods but with several different specific procedure names.  
If the accompanying Fortran compiler supports TS 29113,  
then the new routines are needed only for routines with  
choice buffer arguments. (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
In the Fortran support method <tt> mpif.h</tt>,  
compile-time argument checking  
can be also implemented for all routines.  
For <tt> mpif.h</tt>, the argument names are not specified through the <font face="sans-serif"> MPI</font> standard,  
i.e., only positional argument lists are defined, and not key-word based lists.  
Due to the rule that <tt> mpif.h</tt>  
must be valid for fixed and free source form,  
the subroutine declaration is restricted to one line with 72 characters.  
To keep the argument lists short, each argument name can be shortened  
to a minimum of one character. With this, the two longest subroutine  
declaration statements are  
<br> 
<pre><tt>      SUBROUTINE PMPI_Dist_graph_create_adjacent(a,b,c,d,e,f,g,h,i,j,k) 
      SUBROUTINE PMPI_Rget_accumulate(a,b,c,d,e,f,g,h,i,j,k,l,m,n) 
</tt></pre> 
with 71 and 66 characters.  
With buffers implemented with TS 29113, the specific procedure names have an  
additional postfix. The longest of such interface definitions is  
<br> 
<pre><tt>      INTERFACE  PMPI_Rget_accumulate 
      SUBROUTINE PMPI_Rget_accumulate_fts(a,b,c,d,e,f,g,h,i,j,k,l,m,n) 
</tt></pre> 
with 70 characters.  
In principle, continuation lines would be possible in <tt> mpif.h</tt>  
(spaces in columns 73--131, &amp; in column 132, and in column 6 of the  
continuation line) but this would not be valid if the source line  
length is extended with a compiler flag to 132 characters.  
Column 133 is also not available for the continuation character because  
lines longer than 132 characters are invalid with some compilers by default.  
<P> 
The longest specific procedure names are  
<font face="sans-serif"> PMPI_Dist_graph_create_adjacent_f08</font>  
and  
<font face="sans-serif"> PMPI_File_write_ordered_begin_f08ts</font>  
both with 35 characters in the <tt> mpi_f08</tt> module.  
<P> 
For example, the interface specifications together with the specific procedure names   
can be implemented with  
  
<br> 
<pre><tt>MODULE mpi_f08 
  TYPE, BIND(C) :: MPI_Comm 
    INTEGER :: MPI_VAL 
  END TYPE MPI_Comm 
  ... 
  INTERFACE MPI_Comm_rank  ! (as defined in Chapter 6) 
    SUBROUTINE MPI_Comm_rank_f08(comm, rank, ierror) 
      IMPORT :: MPI_Comm 
      TYPE(MPI_Comm),      INTENT(IN)  :: comm 
      INTEGER,             INTENT(OUT) :: rank 
      INTEGER, OPTIONAL,   INTENT(OUT) :: ierror 
    END SUBROUTINE 
  END INTERFACE 
END MODULE mpi_f08 
 
MODULE mpi 
  INTERFACE MPI_Comm_rank  ! (as defined in Chapter 6) 
    SUBROUTINE MPI_Comm_rank(comm, rank, ierror) 
      INTEGER, INTENT(IN)  :: comm   ! The INTENT may be added although 
      INTEGER, INTENT(OUT) :: rank   ! it is not defined in the 
      INTEGER, INTENT(OUT) :: ierror ! official routine definition. 
    END SUBROUTINE 
  END INTERFACE 
END MODULE mpi 
</tt></pre> 
And if interfaces are provided in <tt> mpif.h</tt>, they might look like this  
(outside of any module and in fixed source format):  
  
<br> 
<pre><tt>!23456789012345678901234567890123456789012345678901234567890123456789012 
      INTERFACE MPI_Comm_rank  ! (as defined in Chapter 6) 
       SUBROUTINE MPI_Comm_rank(comm, rank, ierror) 
        INTEGER, INTENT(IN)  :: comm   ! The argument names may be 
        INTEGER, INTENT(OUT) :: rank   ! shortened so that the 
        INTEGER, INTENT(OUT) :: ierror ! subroutine line fits to the 
       END SUBROUTINE                  ! maximum of 72 characters. 
      END INTERFACE 
</tt></pre> 
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The following is an example of how  
a user-written or middleware profiling routine  
can be implemented:  
  
<br> 
<pre><tt>SUBROUTINE MPI_Isend_f08ts(buf,count,datatype,dest,tag,comm,request,ierror) 
  USE :: mpi_f08, my_noname =&gt; MPI_Isend_f08ts 
  TYPE(*), DIMENSION(..), ASYNCHRONOUS :: buf 
  INTEGER,            INTENT(IN)       :: count, dest, tag 
  TYPE(MPI_Datatype), INTENT(IN)       :: datatype 
  TYPE(MPI_Comm),     INTENT(IN)       :: comm 
  TYPE(MPI_Request),  INTENT(OUT)      :: request 
  INTEGER, OPTIONAL,  INTENT(OUT)      :: ierror 
    ! ... some code for the begin of profiling 
  call PMPI_Isend (buf, count, datatype, dest, tag, comm, request, ierror) 
    ! ... some code for the end of profiling 
END SUBROUTINE MPI_Isend_f08ts 
</tt></pre> 
Note that this routine is used to intercept the existing specific  
procedure name <font face="sans-serif"> MPI_Isend_f08ts</font> in the <font face="sans-serif"> MPI</font> library.  
This routine must not be part of a module.  
This routine itself calls <font face="sans-serif"> PMPI_Isend</font>.  
The <tt> USE</tt> of the <tt> mpi_f08</tt> module is needed for  
definitions of handle types and the interface for <font face="sans-serif"> PMPI_Isend</font>.  
However, this module also contains an interface definition for  
the specific procedure name <font face="sans-serif"> MPI_Isend_f08ts</font> that conflicts  
with the definition of this profiling routine (i.e., the name is  
doubly defined).  
Therefore, the <tt> USE</tt> here specifically excludes the interface  
from the module by renaming the unused routine name in the  
<tt> mpi_f08</tt> module into ``<tt> my_noname</tt>'' in the scope of this routine.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The <font face="sans-serif"> PMPI</font> interface allows intercepting <font face="sans-serif"> MPI</font> routines.  
For example, an additional <font face="sans-serif"> MPI_ISEND</font> profiling wrapper  
can be provided that is called by the  
application and internally calls <font face="sans-serif"> PMPI_ISEND</font>.  
There are two typical use cases: a profiling layer that is developed  
independently from the application and the <font face="sans-serif"> MPI</font> library,  
and profiling routines that are part of the application  
and have access to the application data.  
With <font face="sans-serif"> MPI-3.0</font>, new Fortran interfaces and implementation schemes  
were introduced that have several implications on how Fortran  
<font face="sans-serif"> MPI</font> routines are internally implemented and optimized.  
For profiling layers, these schemes imply that several  
internal interfaces with different specific procedure names  
may need to be intercepted,  
as shown in the example code above.  
Therefore, for wrapper routines that  
are part of a Fortran application,  
it may be more convenient to make the name shift within  
the application, i.e., to substitute the call to the  
<font face="sans-serif"> MPI</font> routine (e.g., <font face="sans-serif"> MPI_ISEND</font>) by a call to a user-written  
profiling wrapper with a new name (e.g., <font face="sans-serif"> X_MPI_ISEND</font>)  
and to call the Fortran <font face="sans-serif"> MPI_ISEND</font> from this wrapper,  
instead of using the <font face="sans-serif"> PMPI</font> interface.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
An implementation that provides a Fortran interface must provide a  
  combination of <font face="sans-serif"> MPI</font> library and module or include file that uses  
  the specific procedure names as described in  
  Table <a href="node412.htm#Table20">20 
</a>  
  so that the <font face="sans-serif"> MPI</font>  
  Fortran routines are interceptable as described above.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node411.htm#Node411"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node413.htm#Node413"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node413.htm#Node413"> <font face="sans-serif"> MPI</font> for Different Fortran Standard Versions</a>
<b>Previous: </b><a href="node411.htm#Node411"> Fortran Support Through the <tt>mpif.h</tt> Include File</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
