<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Problems Due to Data Copying and Sequence Association with Subscript Triplets</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node422">366. Problems Due to Data Copying and Sequence Association with Subscript Triplets</span></h2>
<a href="node421.htm#Node421"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node423.htm#Node423"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node423.htm#Node423"> Problems Due to Data Copying and Sequence Association with Vector Subscripts</a>
<b>Previous: </b><a href="node421.htm#Node421"> Problems Due to Strong Typing</a>
<p>
  
<P> 
Arrays with subscript <b> triplets</b> describe Fortran subarrays with or without strides, e.g.,   
<P> 
<br> 
<pre><tt>   REAL a(100,100,100) 
   CALL MPI_Send( a(11:17, 12:99:3, 1:100), 7*30*100, MPI_REAL, ...) 
</tt></pre> 
The handling of subscript triplets depends on the value of the constant <font face="sans-serif">  MPI_SUBARRAYS_SUPPORTED</font>:  
<ul> 
 
<li>If <font face="sans-serif">  MPI_SUBARRAYS_SUPPORTED</font> equals <tt> .TRUE.</tt>:  
<P> 
Choice buffer arguments are declared as <tt>TYPE(*)</tt>, <tt>DIMENSION(..)</tt>.  
 For example, consider the following code fragment:  
<P> 
<br> 
<pre><tt>    REAL s(100), r(100) 
    CALL MPI_Isend(s(1:100:5), 3, MPI_REAL, ..., rq, ierror) 
    CALL MPI_Wait(rq, status, ierror) 
    CALL MPI_Irecv(r(1:100:5), 3, MPI_REAL, ..., rq, ierror) 
    CALL MPI_Wait(rq, status, ierror) 
</tt></pre> 
In this case, the individual elements <tt>s(1)</tt>, <tt>s(6)</tt>, and <tt>s(11)</tt> are sent  
 between the start of <font face="sans-serif"> MPI_ISEND</font> and   
 the end of <font face="sans-serif"> MPI_WAIT</font> even though the  
 compiled code will not copy <tt>s(1:100:5)</tt> to a real contiguous temporary  
 scratch buffer.  Instead, the compiled code will pass a descriptor to  
 <font face="sans-serif"> MPI_ISEND</font> that allows <font face="sans-serif"> MPI</font> to operate directly   
 on <tt>s(1)</tt>, <tt>s(6)</tt>, <tt>s(11)</tt>, <i>...</i>, <tt>s(96)</tt>.  
 The called <font face="sans-serif"> MPI_ISEND</font> routine will take only the first three  
 of these elements due to the type signature ``<tt> 3, MPI_REAL</tt>''.    
<P> 
All nonblocking <font face="sans-serif"> MPI</font> functions (e.g., <font face="sans-serif"> MPI_ISEND</font>,  
 <font face="sans-serif"> MPI_PUT</font>, <font face="sans-serif"> MPI_FILE_WRITE_ALL_BEGIN</font>) behave as if   
 <em> the user-specified elements of choice buffers are copied to a contiguous  
 scratch buffer in the </em><font face="sans-serif"> MPI</font> runtime environment</em>.    
 All datatype descriptions (in the example above, ``<tt>3, MPI_REAL</tt>'') read and   
 store data from and to this virtual contiguous scratch buffer.  Displacements in  
 <font face="sans-serif"> MPI</font> derived datatypes are relative to the beginning of this virtual  
 contiguous scratch buffer.  Upon completion of a nonblocking receive  
 operation (e.g., when <font face="sans-serif"> MPI_WAIT</font> on a corresponding <font face="sans-serif">  MPI_Request</font>  
 returns), it is as if the received data has been copied from the  
 virtual contiguous scratch buffer back to the non-contiguous  
 application buffer.  In the example above, <tt>r(1)</tt>, <tt>r(6)</tt>, and <tt>r(11)</tt>  
 are guaranteed to be defined with the received data when <font face="sans-serif"> MPI_WAIT</font> returns.  
<P> 
Note that the above definition does not supercede restrictions about  
 buffers used with non-blocking operations (e.g., those specified in  
 Section <a href="node63.htm#Node63">Communication Initiation 
</a>).  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The Fortran descriptor for <tt>TYPE(*),</tt> <tt>DIMENSION(..)</tt> arguments contains enough  
 information that, if desired, the <font face="sans-serif"> MPI</font> library can make a real contiguous copy of  
 non-contiguous user buffers when the nonblocking operation is started,   
 and release this buffer not before the nonblocking communication   
 has completed (e.g., the <font face="sans-serif"> MPI_WAIT</font> routine).   
 Efficient implementations may avoid such additional  
 memory-to-memory data copying.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
If <font face="sans-serif">  MPI_SUBARRAYS_SUPPORTED</font> equals <tt> .TRUE.</tt>,  
 non-contiguous buffers are handled inside the <font face="sans-serif"> MPI</font> library  
 instead of by the compiler through argument association conventions.  
 Therefore, the scope of <font face="sans-serif"> MPI</font> library scratch buffers can  
 be from the beginning of a nonblocking operation until the completion of the  
 operation although beginning and completion are implemented in different routines.  
 (<em> End of rationale.</em>) <br> 
 
<li>If <font face="sans-serif">  MPI_SUBARRAYS_SUPPORTED</font> equals <tt> .FALSE.</tt>:  
<P> 
In this case, the use of Fortran arrays with subscript triplets as  
actual choice buffer arguments in any nonblocking <font face="sans-serif"> MPI</font> operation  
(which also includes persistent request, and split collectives) may  
cause undefined behavior. They may, however, be used in blocking <font face="sans-serif"> MPI</font>  
operations.  
 <P> 
Implicit in <font face="sans-serif"> MPI</font> is the idea of a contiguous chunk of memory accessible  
through a linear address space.  <font face="sans-serif"> MPI</font> copies data to and from this  
memory. An <font face="sans-serif"> MPI</font> program specifies the location of data by providing  
memory addresses and offsets. In the C language, sequence association  
rules plus pointers provide all the necessary low-level structure.  
<P> 
In Fortran, array   
data is not necessarily stored contiguously. For  
example, the array section <tt>A(1:N:2)</tt> involves only the elements of   
<tt>A</tt> with   
indices 1, 3, 5, .... The same is true for a pointer array whose  
target is such a section. Most compilers ensure that an array that is a  
dummy argument is held in contiguous memory if it is declared with an  
explicit shape (e.g., <tt>B(N)</tt>) or is of assumed size (e.g., <tt>B(*)</tt>). If  
necessary, they do this by making a copy of the array into contiguous  
memory.<A HREF="JavaScript: alert('Technically, the Fortran standard is worded to allow  
non-contiguous storage of any array  
data, unless the dummy argument has the \ftype{CONTIGUOUS} attribute.')">*</A>  
<P> 
Because <font face="sans-serif"> MPI</font> dummy buffer arguments are assumed-size arrays  
if <font face="sans-serif">  MPI_SUBARRAYS_SUPPORTED</font> equals <tt> .FALSE.</tt>,   
this leads  
to a serious problem for a nonblocking call: the compiler copies the  
temporary array back on return but <font face="sans-serif"> MPI</font> continues to copy data to the  
memory that held it. For example, consider the following code fragment:  
  
<br> 
<pre><tt>    real a(100) 
    call MPI_IRECV(a(1:100:2), MPI_REAL, 50, ...) 
</tt></pre> 
Since the first dummy argument to <font face="sans-serif"> MPI_IRECV</font> is an assumed-size  
array (<tt>&lt;type&gt; buf(*)</tt>), the array section <tt>a(1:100:2)</tt> is copied to  
a temporary before being passed to <font face="sans-serif"> MPI_IRECV</font>, so that it is  
contiguous in memory. <font face="sans-serif"> MPI_IRECV</font> returns immediately, and data is  
copied from the temporary back into the array <tt>a</tt>. Sometime later, <font face="sans-serif"> MPI</font>  
may write to the address of the deallocated temporary.  
Copying is also a problem for <font face="sans-serif"> MPI_ISEND</font> since the temporary  
array may be deallocated before the data has all been sent from it.  
<P> 
Most Fortran 90 compilers do not make a copy if the actual argument is  
the whole of an explicit-shape or assumed-size array or is a ``simply contiguous''  
section such as <tt>A(1:N)</tt> of such an array.   
(``Simply contiguous'' is defined in the next paragraph.)   
Also, many compilers treat allocatable arrays  
the same as they treat explicit-shape arrays in this regard (though we know of one that  
does not). However, the same is not true for assumed-shape and pointer  
arrays; since they may be discontiguous, copying is often done. It is  
this copying that causes problems for <font face="sans-serif"> MPI</font> as described in the previous  
paragraph.  
<P> 
According to the Fortran 2008 Standard, Section 6.5.4, a ``simply contiguous'' array section is   
<br> 
<pre><tt>   name ( [:,]... [&lt;subscript&gt;]:[&lt;subscript&gt;] [,&lt;subscript&gt;]... ) 
</tt></pre> 
That is, there are zero or more dimensions that are selected in full,  
then one dimension selected without a stride, then zero or more  
dimensions that are selected with a simple subscript.   
The compiler can detect from analyzing the source code that the array is contiguous.  
Examples are  
<br> 
<pre><tt>   A(1:N), A(:,N), A(:,1:N,1), A(1:6,N), A(:,:,1:N) 
</tt></pre> 
Because of Fortran's column-major ordering, where the first index  
varies fastest, a ``simply contiguous'' section of a contiguous array will also be  
contiguous.  
<P> 
The same problem can occur with a scalar argument.   
A compiler may   
make a copy of scalar dummy arguments within  
a called procedure when passed as an actual argument to a choice buffer routine.   
That this can cause a problem is illustrated by the  
example  
<br> 
<pre><tt>      real :: a  
      call user1(a,rq)  
      call MPI_WAIT(rq,status,ierr)  
      write (*,*) a  
 
      subroutine user1(buf,request) 
      call MPI_IRECV(buf,...,request,...)  
      end  
</tt></pre> 
If <tt>a</tt> is copied, <font face="sans-serif"> MPI_IRECV</font> will alter the copy when it completes the  
communication and will not alter <tt>a</tt> itself.   
<P> 
Note that copying will almost certainly occur for an argument that is a  
non-trivial expression (one with at least one operator or function  
call), a section that does not select a contiguous part of its parent  
(e.g., <tt>A(1:n:2)</tt>), a pointer whose target is such a section, or an  
assumed-shape array that is (directly or indirectly) associated with  
such a section.  
<P> 
If a compiler option exists that inhibits copying of arguments,  
in either the calling or called procedure, this must be employed.  
<P> 
If a compiler makes copies in the calling procedure of arguments that  
are explicit-shape or assumed-size arrays, ``simply contiguous'' array sections of  
such arrays, or scalars, and if no compiler option exists to inhibit such copying,   
then the compiler cannot be used for applications that use   
<font face="sans-serif"> MPI_GET_ADDRESS</font>, or any nonblocking <font face="sans-serif"> MPI</font> routine.  If a  
compiler copies scalar arguments in the called procedure and there is no  
compiler option to inhibit this, then this compiler cannot be used for  
applications that use memory references across subroutine calls as  
in the example above.  
</ul> 
<br> 

<P>
<hr>
<a href="node421.htm#Node421"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node423.htm#Node423"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node423.htm#Node423"> Problems Due to Data Copying and Sequence Association with Vector Subscripts</a>
<b>Previous: </b><a href="node421.htm#Node421"> Problems Due to Strong Typing</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
