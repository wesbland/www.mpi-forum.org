<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-tools/mpit.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Performance Variables</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node384">338. Performance Variables</span></h2>
<a href="node378.htm#Node383"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node372.htm#Node372"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node385"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node372.htm#Node372"> The <font face="sans-serif"> MPI</font> Tool Information Interface</a>
<b>Next: </b><a href="node384.htm#Node385"> Performance Variable Classes</a>
<b>Previous: </b><a href="node378.htm#Node383"> Example: Reading the Value of a Control Variable</a>
<p>
  
  
<P> 
The following section focuses on the ability to list and to query  
performance variables provided by the <font face="sans-serif"> MPI</font>  
implementation. Performance variables provide insight into <font face="sans-serif"> MPI</font>  
implementation specific internals and can represent information such  
as the state of the <font face="sans-serif"> MPI</font> implementation (e.g., waiting blocked,  
receiving, not active), aggregated timing data for submodules, or  
queue sizes and lengths.   
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The interface for performance variables is separate from the interface  
for control variables, since performance variables have different  
requirements and parameters. By keeping them separate, the interface  
provides cleaner semantics and allows for more performance optimization  
opportunities.  
 (<em> End of rationale.</em>) <br> 
<ul> 
</ul> 

<P>
<hr>
<a href="node378.htm#Node383"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node372.htm#Node372"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node385"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node372.htm#Node372"> The <font face="sans-serif"> MPI</font> Tool Information Interface</a>
<b>Next: </b><a href="node384.htm#Node385"> Performance Variable Classes</a>
<b>Previous: </b><a href="node378.htm#Node383"> Example: Reading the Value of a Control Variable</a>
<p>
<hr><h3><span id="Node385">338.1. Performance Variable Classes</span></h3>
<a href="node384.htm#Node384"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node386"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node386"> Performance Variable Query Functions</a>
<b>Previous: </b><a href="node384.htm#Node384"> Performance Variables</a>
<p>
  
<P> 
Each performance variable is associated with a class that describes   
its basic semantics, possible datatypes, basic behavior, its starting value, whether it can  
overflow, and when and   
how an <font face="sans-serif"> MPI</font> implementation can change the variable's value.  The starting value is   
the value that is assigned to the variable the first time that it is used or   
whenever it is reset.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
If a performance variable belongs to a class that can overflow, it is  
up to the user to protect against this overflow, e.g., by  
frequently reading and resetting the variable value.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
<font face="sans-serif"> MPI</font> implementations should use large enough datatypes for each  
performance variable to avoid overflows under normal circumstances.  
 (<em> End of advice to implementors.</em>) <br> 
The classes are defined by the following constants:  
<P> 
<P><img width=342 height=652 src="img216.gif" alt="Image file"><P>

<P>
<hr>
<a href="node384.htm#Node384"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node386"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node386"> Performance Variable Query Functions</a>
<b>Previous: </b><a href="node384.htm#Node384"> Performance Variables</a>
<p>
<hr><h3><span id="Node386">338.2. Performance Variable Query Functions</span></h3>
<a href="node384.htm#Node385"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node387"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node387"> Performance Experiment Sessions</a>
<b>Previous: </b><a href="node384.htm#Node385"> Performance Variable Classes</a>
<p>
An <font face="sans-serif"> MPI</font> implementation exports a set of <i>N</i> performance variables  
through the <font face="sans-serif"> MPI</font> tool information interface. If <i>N</i> is zero, then the <font face="sans-serif"> MPI</font> implementation does not  
export any performance variables; otherwise the provided performance  
variables are indexed from <i>0</i> to <i>N-1</i>. This index number is used in  
subsequent calls to identify the individual variables.  
<P> 
An <font face="sans-serif"> MPI</font> implementation is allowed to increase the number of  
performance variables during the execution of an <font face="sans-serif"> MPI</font> application  
when new variables become available through dynamic loading. However,  
<font face="sans-serif"> MPI</font> implementations are not allowed to change the index of a  
performance variable or to delete a variable once it has been added to  
the set. When  
a variable becomes inactive, e.g., through dynamic unloading, accessing  
its value should return a corresponding error code.  
<P> 
The following function can be used to query the number of performance  
variables, <i>N</i>:  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_GET_NUM(num_pvar)</TD></TR>  
<TR><TD> OUT num_pvar</TD><TD>returns number of performance variables (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_T_pvar_get_num(int *num_pvar) <br></tt>  
<P> 
The function <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> provides access to additional  
information for each variable.  
<P> 
<P><img width=364 height=543 src="img217.gif" alt="Image file"><P>
  
 <tt> int MPI_T_pvar_get_info(int pvar_index, char *name, int *name_len, int *verbosity, int *var_class, MPI_Datatype *datatype, MPI_T_enum *enumtype, char *desc, int *desc_len, int *bind, int *readonly, int *continuous, int *atomic) <br></tt>  
<P> 
After a successful call to <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> for a  
particular variable, subsequent calls to this routine that query  
information about the same variable must return the same  
information. An <font face="sans-serif"> MPI</font> implementation is not allowed to alter any of  
the returned values.  
<P> 
If any <font face="sans-serif">  OUT</font> parameter to <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> is a <font face="sans-serif">  NULL</font> pointer, the implementation will ignore the parameter and not return a value for the parameter.  
<P> 
 The arguments <font face="sans-serif"> name</font> and <font face="sans-serif"> name_len</font> are used to return the name of the performance variable as described in Section <a href="node375.htm#Node375">Convention for Returning Strings 
</a>.   
If completed successfully, the routine is required to return a name of  
at least length one.  
<P> 
The argument <font face="sans-serif"> verbosity</font> returns the verbosity level of the  
variable (see Section <a href="node373.htm#Node373">Verbosity Levels 
</a>).  
<P> 
The class of the performance variable is returned in the parameter  
<font face="sans-serif"> var_class</font>. The class must be one of the constants defined in  
Section <a href="node384.htm#Node385">Performance Variable Classes 
</a>.  
<P> 
The combination of the name and the class of the performance variable  
must be unique with respect to all other names for  performance  
variables used by the <font face="sans-serif"> MPI</font> implementation.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Groups of variables that belong closely together, but have different classes,  
can have the same name. This choice is useful, e.g., to refer to multiple variables  
that describe a single resource (like the level, the total size, as well as  
high and low watermarks).  
 (<em> End of advice to implementors.</em>) <br> 
The argument <font face="sans-serif"> datatype</font> returns the <font face="sans-serif"> MPI</font> datatype that is used  
to represent the performance variable.   
<P> 
If the variable is of type <font face="sans-serif">  MPI_INT</font>, <font face="sans-serif"> MPI</font> can optionally  
specify an enumeration for the values represented by this variable  
and return it in <font face="sans-serif"> enumtype</font>. In  
this case, <font face="sans-serif"> MPI</font> returns an enumeration identifier, which can then  
be used to gather more information as described in Section <a href="node377.htm#Node377">Datatype System 
</a>.  
Otherwise, <font face="sans-serif"> enumtype</font> is set to <font face="sans-serif">  MPI_T_ENUM_NULL</font>.  
If the datatype is not <font face="sans-serif">  MPI_INT</font> or the argument <font face="sans-serif"> enumtype</font> is the   
null pointer, no enumeration type is returned.  
<P> 
Returning a description is optional. If an <font face="sans-serif"> MPI</font> implementation  
does not return a description, the first character for  
<font face="sans-serif"> desc</font> must be set to the null character and <font face="sans-serif"> desc_len</font>  
must be set to one at the return from this function.  
<P> 
The parameter <font face="sans-serif"> bind</font> returns the type of the <font face="sans-serif"> MPI</font> object to  
which the variable must be bound or the value  
<font face="sans-serif">  MPI_T_BIND_NO_OBJECT</font> (see Section <a href="node374.htm#Node374">Binding <font face="sans-serif"> MPI</font> Tool Information Interface Variables to <font face="sans-serif"> MPI</font> Objects 
</a>).  
<P> 
Upon return, the argument <font face="sans-serif"> readonly</font> is set to zero if the variable can be written or reset by  
the user. It is set to one if the variable   
can only be read.  
<P> 
Upon return, the argument <font face="sans-serif"> continuous</font> is set to zero if the  
variable can be started and stopped by the user, i.e., it is possible  
for the user to control if and when the value of a variable is  
updated. It is set to one if the variable is always active and cannot  
be controlled by the user.  
<P> 
Upon return, the argument <font face="sans-serif"> atomic</font> is set to zero if the  
variable cannot be read and reset atomically. Only variables for  
which the call sets <font face="sans-serif"> atomic</font> to one can be used in  
a call to <font face="sans-serif"> MPI_T_PVAR_READRESET</font>.  
<P> 
If a performance variable has an equivalent name  
and has the same class across connected processes,  
the following <font face="sans-serif"> OUT</font>  parameters must be identical: <font face="sans-serif"> verbosity</font>,  
<font face="sans-serif"> varclass</font>,   
<font face="sans-serif"> datatype</font>, <font face="sans-serif"> enumtype</font>,   
<font face="sans-serif"> bind</font>, <font face="sans-serif"> readonly</font>, <font face="sans-serif"> continuous</font>, and <font face="sans-serif"> atomic</font>.   
The returned description must be equivalent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_GET_INDEX(name, var_class, pvar_index)</TD></TR>  
<TR><TD> IN name</TD><TD>the name of the performance variable (string)</TD></TR>  
<TR><TD> IN var_class</TD><TD>the class of the performance variable (integer)</TD></TR>  
<TR><TD> OUT pvar_index</TD><TD>the index of the performance variable (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_T_pvar_get_index(const char *name, int var_class, int *pvar_index) <br></tt>  
<P> 
<font face="sans-serif"> MPI_T_PVAR_GET_INDEX</font> is a function for retrieving   
the index of a performance variable given a known variable name and class. The   
<font face="sans-serif"> name</font> and <font face="sans-serif"> var_class</font> parameters are provided by the caller, and <font face="sans-serif"> pvar_index</font>   
is returned by the <font face="sans-serif"> MPI</font> implementation. The <font face="sans-serif"> name</font> parameter is a string   
terminated with a null character.  
<P> 
This routine returns <font face="sans-serif">  MPI_SUCCESS</font> on success and returns   
<font face="sans-serif">  MPI_T_ERR_INVALID_NAME</font> if <font face="sans-serif"> name</font> does not match the   
name of any performance variable of the specified <font face="sans-serif"> var_class</font> provided by the implementation   
at the time of the call.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
This routine is provided to enable fast retrieval of performance   
variables by a tool, assuming it knows the name of the variable for   
which it is looking. The number of variables exposed by the implementation   
can change over time, so it is not possible for the tool to simply iterate   
over the list of variables once at initialization. Although using <font face="sans-serif"> MPI</font>   
implementation specific variable names is not portable across <font face="sans-serif"> MPI</font>   
implementations, tool developers may choose to take this route for lower   
overhead at runtime because the tool will not have to iterate over the   
entire set of variables to find a specific one.   
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node384.htm#Node385"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node387"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node387"> Performance Experiment Sessions</a>
<b>Previous: </b><a href="node384.htm#Node385"> Performance Variable Classes</a>
<p>
<hr><h3><span id="Node387">338.3. Performance Experiment Sessions</span></h3>
<a href="node384.htm#Node386"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node388"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node388"> Handle Allocation and Deallocation</a>
<b>Previous: </b><a href="node384.htm#Node386"> Performance Variable Query Functions</a>
<p>
  
<P> 
Within a single program, multiple components can use the <font face="sans-serif"> MPI</font> tool information  
interface. To avoid collisions with respect to accesses to performance   
variables, users of the <font face="sans-serif"> MPI</font> tool information interface must first create a session.  
Subsequent calls that access performance variables can then be made  
within the context of this session. Any call executed in a session  
must not influence the results in any other session.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_SESSION_CREATE(session)</TD></TR>  
<TR><TD> OUT session</TD><TD>identifier of performance session (handle)</TD></TR>  
</TABLE>  
<P> 
  
 <tt> int MPI_T_pvar_session_create(MPI_T_pvar_session *session) <br></tt>  
<P> 
This call creates a new session for accessing performance  
variables and returns a handle for this session  
in the argument <font face="sans-serif"> session</font> of type <font face="sans-serif"> MPI_T_pvar_session</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_SESSION_FREE(session)</TD></TR>  
<TR><TD> INOUT session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
</TABLE>  
<P> 
  
 <tt> int MPI_T_pvar_session_free(MPI_T_pvar_session *session) <br></tt>  
<P> 
This call frees an existing session. Calls to the <font face="sans-serif"> MPI</font> tool information interface  can no longer be  
made within the context of a session after it is freed.    
On a  
successful return, <font face="sans-serif"> MPI</font> sets the session identifier to  
<font face="sans-serif">  MPI_T_PVAR_SESSION_NULL</font>.  
<P> 

<P>
<hr>
<a href="node384.htm#Node386"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node388"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node388"> Handle Allocation and Deallocation</a>
<b>Previous: </b><a href="node384.htm#Node386"> Performance Variable Query Functions</a>
<p>
<hr><h3><span id="Node388">338.4. Handle Allocation and Deallocation</span></h3>
<a href="node384.htm#Node387"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node389"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node389"> Starting and Stopping of Performance Variables</a>
<b>Previous: </b><a href="node384.htm#Node387"> Performance Experiment Sessions</a>
<p>
Before using a performance variable, a user must first  
allocate a handle of type <font face="sans-serif"> MPI_T_pvar_handle</font> for the variable by binding it to an <font face="sans-serif"> MPI</font>  
object (see also Section <a href="node374.htm#Node374">Binding <font face="sans-serif"> MPI</font> Tool Information Interface Variables to <font face="sans-serif"> MPI</font> Objects 
</a>).   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_HANDLE_ALLOC(session, pvar_index, obj_handle, handle, count)</TD></TR>  
<TR><TD> IN session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD> IN pvar_index</TD><TD>index of performance variable for which handle is to be allocated (integer)</TD></TR>  
<TR><TD> IN obj_handle</TD><TD>reference to a handle of the <font face="sans-serif"> MPI</font> object to which this variable is supposed to be bound (pointer)</TD></TR>  
<TR><TD> OUT handle</TD><TD>allocated handle (handle)</TD></TR>  
<TR><TD> OUT count</TD><TD>number of elements used to represent this variable (integer)</TD></TR>  
</TABLE>  
<P> 
   
  
 <tt> int MPI_T_pvar_handle_alloc(MPI_T_pvar_session session, int pvar_index, void *obj_handle, MPI_T_pvar_handle *handle, int *count) <br></tt>  
<P> 
This routine binds the performance variable specified by the argument  
<font face="sans-serif"> index</font> to an <font face="sans-serif"> MPI</font> object  in the session identified  
by the parameter <font face="sans-serif"> session</font>. The object is passed in the  
argument <font face="sans-serif"> obj_handle</font> as an address to a local variable  
that stores the object's handle.   
The argument <font face="sans-serif"> obj_handle</font> is ignored if the <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> call for this performance variable returned <font face="sans-serif">  MPI_T_BIND_NO_OBJECT</font> in the argument <font face="sans-serif"> bind</font>.  
The handle allocated to reference the variable is returned  
in the argument <font face="sans-serif"> handle</font>.  Upon successful return,  
<font face="sans-serif"> count</font> contains the number of elements (of the datatype  
returned by a previous <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> call)  
used to represent this variable.   
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The <font face="sans-serif"> count</font> can  
be different based on the <font face="sans-serif"> MPI</font> object to which the performance variable was bound. For example,  
variables bound to communicators could have a count that matches  
the size of the communicator.  
<P> 
It is not portable to pass references to predefined <font face="sans-serif"> MPI</font> object handles,  
such as <font face="sans-serif">  MPI_COMM_WORLD</font>, to this routine, since their  
implementation depends on the <font face="sans-serif"> MPI</font> library. Instead, such an object handle should  
be stored in a local variable and the address of this local variable  
should be passed into <font face="sans-serif"> MPI_T_PVAR_HANDLE_ALLOC</font>.  
 (<em> End of advice to users.</em>) <br> 
The value of index  
should be in the range <i>0</i> to <i>mpiargnum_pvar-1</i>, where <i>mpishortargnum_pvar</i> is the number of  
available performance variables as determined from a prior call to  
<font face="sans-serif"> MPI_T_PVAR_GET_NUM</font>.  The type of the <font face="sans-serif"> MPI</font> object it references must be consistent with the type   
returned in the <font face="sans-serif"> bind</font> argument in a prior call to <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font>.  
<P> 
For all routines in the rest of this section that take both <font face="sans-serif"> handle</font>  
and <font face="sans-serif"> session</font> as  IN or  INOUT arguments, if the <font face="sans-serif"> handle</font> argument passed in is not associated with the <font face="sans-serif"> session</font> argument,  
<font face="sans-serif">  MPI_T_ERR_INVALID_HANDLE</font> is returned.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_HANDLE_FREE(session, handle)</TD></TR>  
<TR><TD> IN session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD> INOUT handle</TD><TD>handle to be freed (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_T_pvar_handle_free(MPI_T_pvar_session session, MPI_T_pvar_handle *handle) <br></tt>  
<P> 
When  
a handle is no longer needed, a user of the <font face="sans-serif"> MPI</font> tool information interface should call <font face="sans-serif"> MPI_T_PVAR_HANDLE_FREE</font>  
to free the handle in the session identified  
by the parameter <font face="sans-serif"> session</font>  
and the associated resources in the <font face="sans-serif"> MPI</font>  implementation.  
On a successful return, <font face="sans-serif"> MPI</font> sets the handle to <font face="sans-serif">  MPI_T_PVAR_HANDLE_NULL</font>.  
<P> 

<P>
<hr>
<a href="node384.htm#Node387"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node389"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node389"> Starting and Stopping of Performance Variables</a>
<b>Previous: </b><a href="node384.htm#Node387"> Performance Experiment Sessions</a>
<p>
<hr><h3><span id="Node389">338.5. Starting and Stopping of Performance Variables</span></h3>
<a href="node384.htm#Node388"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node390"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node390"> Performance Variable Access Functions</a>
<b>Previous: </b><a href="node384.htm#Node388"> Handle Allocation and Deallocation</a>
<p>
Performance variables that have the continuous flag set during the   
query operation are continuously operating once a handle has been   
allocated.  Such variables may be queried at any time, but they cannot   
be started or stopped by the user.  
All other variables are in a stopped state after their handle has   
been allocated; their values are not updated until they have been   
started by the user.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_START(session, handle)</TD></TR>  
<TR><TD> IN session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD> IN handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
</TABLE>  
<P> 
  
   
 <tt> int MPI_T_pvar_start(MPI_T_pvar_session session, MPI_T_pvar_handle handle) <br></tt>  
<P> 
This functions starts the performance variable with the handle  
identified by the parameter <font face="sans-serif"> handle</font> in the session identified  
by the parameter <font face="sans-serif"> session</font>.  
<P> 
If the constant <font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font> is passed in  
<font face="sans-serif"> handle</font>, the <font face="sans-serif"> MPI</font> implementation attempts to start all variables   
within the session identified by the parameter <font face="sans-serif"> session</font> for  
which handles have been allocated.  In this case, the routine returns  
<font face="sans-serif">  MPI_SUCCESS</font> if all variables are started successfully  
(even if there are no non-continuous variables to be started),  
otherwise <font face="sans-serif">  MPI_T_ERR_PVAR_NO_STARTSTOP</font> is returned.   
Continuous  
variables and variables that are already started are ignored when  
<font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font> is specified.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_STOP(session, handle)</TD></TR>  
<TR><TD> IN session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD> IN handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
</TABLE>  
<P> 
   
  
 <tt> int MPI_T_pvar_stop(MPI_T_pvar_session session, MPI_T_pvar_handle handle) <br></tt>  
<P> 
This functions stops the performance variable with the handle  
identified by the parameter <font face="sans-serif"> handle</font> in the session identified  
by the parameter <font face="sans-serif"> session</font>.  
<P> 
If the constant <font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font> is passed in  
<font face="sans-serif"> handle</font>, the <font face="sans-serif"> MPI</font> implementation attempts to stop all   
variables within the session identified by the parameter  
<font face="sans-serif"> session</font> for which handles have been allocated.  In this case,  
the routine returns <font face="sans-serif">  MPI_SUCCESS</font> if all variables are stopped  
successfully   
(even if there are no non-continuous variables to be stopped),  
otherwise <font face="sans-serif">  MPI_T_ERR_PVAR_NO_STARTSTOP</font> is returned.   
Continuous variables and variables that are already stopped  
are ignored when <font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font> is specified.  
<P> 

<P>
<hr>
<a href="node384.htm#Node388"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node390"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node390"> Performance Variable Access Functions</a>
<b>Previous: </b><a href="node384.htm#Node388"> Handle Allocation and Deallocation</a>
<p>
<hr><h3><span id="Node390">338.6. Performance Variable Access Functions</span></h3>
<a href="node384.htm#Node389"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node391"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node391"> Example: Tool to Detect Receives with Long Unexpected Message Queues</a>
<b>Previous: </b><a href="node384.htm#Node389"> Starting and Stopping of Performance Variables</a>
<p>
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_READ(session, handle, buf)</TD></TR>  
<TR><TD> IN session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD> IN handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of storage location for variable value (choice)</TD></TR>  
</TABLE>  
<P> 
   
  
 <tt> int MPI_T_pvar_read(MPI_T_pvar_session session, MPI_T_pvar_handle handle, void* buf) <br></tt>  
<P> 
The <font face="sans-serif"> MPI_T_PVAR_READ</font> call queries the value of the  
performance variable with the handle <font face="sans-serif"> handle</font> in the session  
identified by the parameter <font face="sans-serif"> session</font> and stores the result in  
the buffer identified by the parameter <font face="sans-serif"> buf</font>.    
The user is  
responsible to ensure that the buffer is of the appropriate size to  
hold the entire value of the performance variable (based on the  
datatype and count returned by the corresponding previous calls to   
<font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> and <font face="sans-serif"> MPI_T_PVAR_HANDLE_ALLOC</font>, respectively).  
<P> 
The   
constant <font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font> cannot be used as an argument  
for the  function <font face="sans-serif"> MPI_T_PVAR_READ</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_WRITE(session,handle, buf)</TD></TR>  
<TR><TD> IN session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD> IN handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of storage location for variable value (choice)</TD></TR>  
</TABLE>  
<P> 
   
  
 <tt> int MPI_T_pvar_write(MPI_T_pvar_session session, MPI_T_pvar_handle handle, const void* buf) <br></tt>  
<P> 
The <font face="sans-serif"> MPI_T_PVAR_WRITE</font> call attempts to write the value of the  
performance variable with the handle identified by the parameter  
<font face="sans-serif"> handle</font> in the session identified by the parameter  
<font face="sans-serif"> session</font>.   
The value to be written is passed in the buffer  
identified by the parameter <font face="sans-serif"> buf</font>.  The user must  
ensure that the buffer is of the appropriate size to hold the entire  
value of the performance variable (based on the  
datatype and count returned by the corresponding previous calls to   
<font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> and <font face="sans-serif"> MPI_T_PVAR_HANDLE_ALLOC</font>, respectively).  
<P> 
If it is not possible to change the variable, the function returns  
<font face="sans-serif">  MPI_T_ERR_PVAR_NO_WRITE</font>.  
<P> 
The constant <font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font> cannot be used as an argument  
for the  function <font face="sans-serif"> MPI_T_PVAR_WRITE</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_RESET(session, handle)</TD></TR>  
<TR><TD> IN session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD> IN handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
</TABLE>  
<P> 
   
  
 <tt> int MPI_T_pvar_reset(MPI_T_pvar_session session, MPI_T_pvar_handle handle) <br></tt>  
<P> 
The <font face="sans-serif"> MPI_T_PVAR_RESET</font> call sets the performance variable with  
the handle identified by the parameter <font face="sans-serif"> handle</font> to its starting  
value specified in Section <a href="node384.htm#Node385">Performance Variable Classes 
</a>. If it is not  
possible to change the variable, the function returns  
<font face="sans-serif">  MPI_T_ERR_PVAR_NO_WRITE</font>.  
<P> 
If the constant <font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font> is passed in <font face="sans-serif"> handle</font>, the  
<font face="sans-serif"> MPI</font> implementation attempts to reset all variables   
within the session identified by the parameter <font face="sans-serif"> session</font> for  
which handles have been allocated.  In this case, the routine returns  
<font face="sans-serif">  MPI_SUCCESS</font> if all variables are reset successfully  
(even if there are no valid handles or all are read-only),  
otherwise <font face="sans-serif">  MPI_T_ERR_PVAR_NO_WRITE</font> is returned.   
Read-only variables  
are ignored when <font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font> is specified.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_READRESET(session, handle, buf)</TD></TR>  
<TR><TD> IN session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD> IN handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of storage location for variable value (choice)</TD></TR>  
</TABLE>  
<P> 
   
  
 <tt> int MPI_T_pvar_readreset(MPI_T_pvar_session session, MPI_T_pvar_handle handle, void* buf) <br></tt>  
<P> 
This call atomically combines the functionality of <font face="sans-serif"> MPI_T_PVAR_READ</font> and  
<font face="sans-serif"> MPI_T_PVAR_RESET</font> with the same semantics as if these two  
calls were called separately.   
If atomic operations on this variable are not  
supported, this routine returns <font face="sans-serif">  MPI_T_ERR_PVAR_NO_ATOMIC</font>.  
<P> 
The constant <font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font> cannot be used as an  
argument for the  function <font face="sans-serif"> MPI_T_PVAR_READRESET</font>.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Sampling-based tools rely on the ability to call the <font face="sans-serif"> MPI</font>  
tool information interface, in particular routines to start, stop,  
read, write, and reset performance variables, from any program  
context, including asynchronous contexts such as signal handlers.  
<font face="sans-serif"> MPI</font> implementations should strive, if possible in their particular  
environment, to enable these usage scenarios for all or a subset of the  
routines mentioned above. If implementing only a subset, the  
read, write, and reset routines are typically the most critical  
for sampling based tools. An <font face="sans-serif"> MPI</font> implementation should clearly  
document any restrictions on the program contexts in which  
the <font face="sans-serif"> MPI</font> tool information interface can be used. Restrictions  
might include guaranteeing usage outside of all signals or  
outside a specific set of signals. Any restrictions could be  
documented, for example, through the description returned by  
<font face="sans-serif"> MPI_T_PVAR_GET_INFO</font>.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
All routines to read, to write or to reset performance variables require the  
session argument. This requirement keeps the interface consistent and allows the  
use of <font face="sans-serif">  MPI_T_PVAR_ALL_HANDLES</font>  where appropriate.  
Further, this opens up additional performance optimizations for   
the implementation of handles.  
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node384.htm#Node389"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node384.htm#Node391"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node384.htm#Node391"> Example: Tool to Detect Receives with Long Unexpected Message Queues</a>
<b>Previous: </b><a href="node384.htm#Node389"> Starting and Stopping of Performance Variables</a>
<p>
<hr><h3><span id="Node391">338.7. Example: Tool to Detect Receives with Long Unexpected Message Queues</span></h3>
<a href="node384.htm#Node390"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node392.htm#Node392"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node392.htm#Node392"> Variable Categorization</a>
<b>Previous: </b><a href="node384.htm#Node390"> Performance Variable Access Functions</a>
<p>
<br><b> Example</b>  
  
<P> 
The following example shows a sample tool to identify receive  
operations that occur during times with long message queues.  This examples  
assumes that the <font face="sans-serif"> MPI</font> implementation exports a variable with the name  
``<tt> MPI_T_UMQ_LENGTH</tt>'' to represent the current length of  
the unexpected message queue. The tool is implemented as a  
PMPI tool using the <font face="sans-serif"> MPI</font> profiling interface.  
<P> 
The tool consists of three parts: (1) the initialization (by  
intercepting the call to <font face="sans-serif"> MPI_INIT</font>), (2) the test for long  
unexpected message queues (by intercepting calls to  
<font face="sans-serif"> MPI_RECV</font>), and (3) the clean-up phase (by  
intercepting the call to <font face="sans-serif"> MPI_FINALIZE</font>).   
To capture all receives, the example  
would have to be extended to have similar wrappers for all  
receive operations.  
<P> 
<P> 
Part 1--- Initialization: During initialization, the tool searches for the variable and, once  
the right index is found, allocates a session and a handle for the  
variable with the found index, and starts the performance variable.  
<P> 
<br> 
<pre><tt>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 
#include &lt;assert.h&gt; 
#include &lt;mpi.h&gt; 
 
/* Global variables for the tool */ 
static MPI_T_pvar_session session; 
static MPI_T_pvar_handle handle; 
 
int MPI_Init(int *argc, char ***argv ) { 
      int err, num, i, index, namelen, verbosity; 
      int var_class, bind, threadsup; 
      int readonly, continuous, atomic, count; 
      char name[18]; 
      MPI_Comm comm; 
      MPI_Datatype datatype; 
      MPI_T_enum enumtype; 
 
      err=PMPI_Init(argc,argv); 
      if (err!=MPI_SUCCESS) return err; 
 
      err=PMPI_T_init_thread(MPI_THREAD_SINGLE,&amp;threadsup); 
      if (err!=MPI_SUCCESS) return err; 
 
      err=PMPI_T_pvar_get_num(&amp;num); 
      if (err!=MPI_SUCCESS) return err;  
      index=-1; 
      i=0; 
      while ((i&lt;num) &amp;&amp; (index&lt;0) &amp;&amp; (err==MPI_SUCCESS)) { 
            /* Pass a buffer that is at least one character longer than */ 
            /* the name of the variable being searched for to avoid */ 
            /* finding variables that have a name that has a prefix */ 
            /* equal to the name of the variable being searched. */ 
            namelen=18; 
            err=PMPI_T_pvar_get_info(i, name, &amp;namelen, &amp;verbosity,  
                    &amp;var_class, &amp;datatype, &amp;enumtype, NULL, NULL, &amp;bind,  
                    &amp;readonly, &amp;continuous, &amp;atomic); 
            if (strcmp(name,"MPI_T_UMQ_LENGTH")==0) index=i;         
            i++; } 
      if (err!=MPI_SUCCESS) return err;  
 
      /* this could be handled in a more flexible way for a generic tool */ 
      assert(index&gt;=0); 
      assert(var_class==MPI_T_PVAR_CLASS_LEVEL); 
      assert(datatype==MPI_INT); 
      assert(bind==MPI_T_BIND_MPI_COMM); 
 
      /* Create a session */ 
      err=PMPI_T_pvar_session_create(&amp;session); 
      if (err!=MPI_SUCCESS) return err; 
 
      /* Get a handle and bind to MPI_COMM_WORLD */ 
      comm=MPI_COMM_WORLD; 
      err=PMPI_T_pvar_handle_alloc(session, index, &amp;comm, &amp;handle, &amp;count); 
      if (err!=MPI_SUCCESS) return err; 
 
      /* this could be handled in a more flexible way for a generic tool */ 
      assert(count==1); 
 
      /* Start variable */ 
      err=PMPI_T_pvar_start(session, handle); 
      if (err!=MPI_SUCCESS) return err; 
 
      return MPI_SUCCESS; 
} 
</tt></pre> 
<P> 
Part 2 --- Testing the Queue Lengths During Receives: During every receive operation, the tool reads the unexpected  
queue length through the matching performance variable and  
compares it against a predefined threshold.  
<P> 
<br> 
<pre><tt>#define THRESHOLD 5 
 
int MPI_Recv(void *buf, int count, MPI_Datatype datatype, int source, 
             int tag, MPI_Comm comm, MPI_Status *status) 
{ 
        int value, err; 
 
        if (comm==MPI_COMM_WORLD) { 
                err=PMPI_T_pvar_read(session, handle, &amp;value); 
                if ((err==MPI_SUCCESS) &amp;&amp; (value&gt;THRESHOLD)) 
                { 
                        /* tool identified receive called with long UMQ */ 
                        /* execute tool functionality, */ 
                        /* e.g., gather and print call stack */ 
                }                 
        } 
 
        return PMPI_Recv(buf, count, datatype, source, tag, comm, status); 
}          
</tt></pre> 
<P> 
Part 3 --- Termination: In the wrapper for <font face="sans-serif"> MPI_FINALIZE</font>, the <font face="sans-serif"> MPI</font> tool information interface  
is finalized.   
<P> 
<br> 
<pre><tt>int MPI_Finalize(void) 
{ 
        int err; 
        err=PMPI_T_pvar_handle_free(session, &amp;handle); 
        err=PMPI_T_pvar_session_free(&amp;session); 
        err=PMPI_T_finalize(); 
        return PMPI_Finalize(); 
} 
</tt></pre> 
  
<P> 

<P>
<hr>
<a href="node384.htm#Node390"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node392.htm#Node392"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Performance Variables</a>
<b>Next: </b><a href="node392.htm#Node392"> Variable Categorization</a>
<b>Previous: </b><a href="node384.htm#Node390"> Performance Variable Access Functions</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
