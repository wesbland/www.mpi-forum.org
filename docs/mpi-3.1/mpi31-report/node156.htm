<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-context/context.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Communicator Constructors</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node156">149. Communicator Constructors</span></h2>
<a href="node155.htm#Node155"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node154.htm#Node154"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node157.htm#Node157"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node154.htm#Node154"> Communicator Management</a>
<b>Next: </b><a href="node157.htm#Node157"> Communicator Destructors</a>
<b>Previous: </b><a href="node155.htm#Node155"> Communicator Accessors</a>
<p>
  
The following are collective functions that are invoked by all processes in the  
group or groups associated with <font face="sans-serif"> comm</font>,  
  with the exception of <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font>, which is  
  invoked only by the processes in the group of the new communicator  
  being constructed.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
Note that there is a chicken-and-egg aspect to <font face="sans-serif"> MPI</font> in that a  
communicator is needed to create a new communicator.  The base  
communicator for all <font face="sans-serif"> MPI</font> communicators is predefined outside of <font face="sans-serif"> MPI</font>,  
and is <font face="sans-serif">  MPI_COMM_WORLD</font>.  This model was arrived at after  
considerable debate, and was chosen to increase ``safety'' of programs  
written in <font face="sans-serif"> MPI</font>.  
 (<em> End of rationale.</em>) <br> 
This chapter presents  
the following communicator construction routines: <font face="sans-serif"> MPI_COMM_CREATE</font>, <font face="sans-serif"> MPI_COMM_DUP</font>,   
<font face="sans-serif"> MPI_COMM_IDUP</font>,<font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font>, and   
<font face="sans-serif"> MPI_COMM_SPLIT</font> can be used to create both intracommunicators and   
intercommunicators; <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> and   
<font face="sans-serif"> MPI_INTERCOMM_MERGE</font> (see Section <a href="node168.htm#Node168">Inter-communicator Operations 
</a>)   
can be used to create   
intracommunicators; and <font face="sans-serif"> MPI_INTERCOMM_CREATE</font>   
(see Section <a href="node168.htm#Node168">Inter-communicator Operations 
</a>)  
can be used to create intercommunicators.  
<P> 
An intracommunicator involves a single group while an intercommunicator   
involves two groups.  
Where the following discussions address intercommunicator semantics,   
the two groups in an intercommunicator are  
called the <em> left</em> and <em> right</em> groups.  A process in an  
intercommunicator is a member of either the left or the right group.  From the  
point of view of that process, the  
group that the process is a member of is called the <em> local group</em>; the  
other group (relative to that process) is the <em> remote group</em>.  
The left and right group labels give us a way to describe the two groups in  
an intercommunicator that is not relative to any particular process (as the  
local and remote groups are).  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_DUP(comm, newcomm)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>copy of <font face="sans-serif"> comm</font> (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_dup(MPI_Comm comm, MPI_Comm *newcomm) <br></tt>  
<P> 
 <tt> MPI_Comm_dup(comm, newcomm, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>TYPE(MPI_Comm), INTENT(OUT) :: newcomm <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_COMM_DUP(COMM, NEWCOMM, IERROR)<br> INTEGER COMM, NEWCOMM, IERROR <br></tt>  
  
  
  
  
  
  
  
  
  
  
  
<P> 
<font face="sans-serif"> MPI_COMM_DUP</font> duplicates the  
existing communicator <font face="sans-serif"> comm</font> with   
associated key values, topology information, and   
info hints.  For each key value, the respective copy callback  
function determines the attribute value associated with this key in the  
new communicator; one particular action that a copy callback may take  
is to delete the attribute from the new communicator.  
Returns in <font face="sans-serif"> newcomm</font> a new  
communicator with the same group or groups, same   
topology, same info hints, any copied cached information,  
but a new context (see Section <a href="node173.htm#Node173">Functionality 
</a>).  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
This operation is used to provide a parallel library  
with a duplicate   
communication  
space that has the same properties as the original communicator.  This  
includes any attributes (see below), topologies (see  
Chapter <a href="node186.htm#Node186">Process Topologies 
</a>), and associated info hints   
(see Section <a href="node158.htm#Node158">Communicator Info 
</a>).  This call is valid even if there are  
pending point-to-point communications involving the communicator  
<font face="sans-serif"> comm</font>.  A typical call might involve a <font face="sans-serif"> MPI_COMM_DUP</font>  
at the beginning of the parallel call, and an <font face="sans-serif"> MPI_COMM_FREE</font> of  
that duplicated communicator at the end of the call.  Other models  
of communicator management are also possible.  
<P> 
This call applies to both intra- and inter-communicators.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
One need not actually copy the group information, but only add a new reference  
and increment the reference count.  Copy on write can be used for the cached  
information. (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_DUP_WITH_INFO(comm, info, newcomm)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>copy of comm (handle)</TD></TR>  
</TABLE>  
<P> 
  
 <tt> int MPI_Comm_dup_with_info(MPI_Comm comm, MPI_Info info, MPI_Comm *newcomm) <br></tt>  
<P> 
 <tt> MPI_Comm_dup_with_info(comm, info, newcomm, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>TYPE(MPI_Info), INTENT(IN) :: info<br>TYPE(MPI_Comm), INTENT(OUT) :: newcomm<br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
<P> 
 <tt> MPI_COMM_DUP_WITH_INFO(COMM, INFO, NEWCOMM, IERROR)<br> INTEGER COMM, INFO, NEWCOMM, IERROR <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font> behaves exactly as  
<font face="sans-serif"> MPI_COMM_DUP</font> except that the info hints associated with  
the communicator <font face="sans-serif"> comm</font> are not duplicated in  
<font face="sans-serif"> newcomm</font>. The hints provided by the argument <font face="sans-serif"> info</font> are  
associated with the output communicator <font face="sans-serif"> newcomm</font> instead.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
It is expected that some hints will only be valid at communicator  
creation time. However, for legacy reasons, most communicator creation  
calls do not provide an info argument. One may associate info hints  
with a duplicate of any communicator at creation time through a call  
to <font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font>.  
 (<em> End of rationale.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_IDUP(comm, newcomm, request)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>copy of comm (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
  
 <tt> int MPI_Comm_idup(MPI_Comm comm, MPI_Comm *newcomm, MPI_Request *request) <br></tt>  
<P> 
 <tt> MPI_Comm_idup(comm, newcomm, request, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>TYPE(MPI_Comm), INTENT(OUT), ASYNCHRONOUS :: newcomm <br>TYPE(MPI_Request), INTENT(OUT) :: request <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
<P> 
 <tt> MPI_COMM_IDUP(COMM, NEWCOMM, REQUEST, IERROR)<br> INTEGER COMM, NEWCOMM, REQUEST, IERROR <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_IDUP</font> is a nonblocking variant of <font face="sans-serif"> MPI_COMM_DUP</font>.   
The semantics   
of <font face="sans-serif"> MPI_COMM_IDUP</font> are as if <font face="sans-serif"> MPI_COMM_DUP</font> was executed at the time   
that <font face="sans-serif"> MPI_COMM_IDUP</font> is called. For example, attributes changed  
after <font face="sans-serif"> MPI_COMM_IDUP</font> will not be copied to the new communicator. All   
restrictions and assumptions for nonblocking collective   
operations (see Section <a href="node126.htm#Node126">Nonblocking Collective Operations 
</a>) apply to <font face="sans-serif"> MPI_COMM_IDUP</font> and   
the returned request.  
<P> 
It is erroneous to use the communicator <font face="sans-serif"> newcomm</font> as an   
input argument to other <font face="sans-serif"> MPI</font> functions before the <font face="sans-serif"> MPI_COMM_IDUP</font>   
operation completes.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
This functionality is crucial for the development   
of purely nonblocking libraries (see [<a href="node522.htm#-Bib36">36</a>]).  
 (<em> End of rationale.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_CREATE(comm, group, newcomm)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN group</TD><TD>group, which is a subset of the group of  
<font face="sans-serif"> comm</font> (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>new communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_create(MPI_Comm comm, MPI_Group group, MPI_Comm *newcomm) <br></tt>  
<P> 
 <tt> MPI_Comm_create(comm, group, newcomm, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>TYPE(MPI_Group), INTENT(IN) :: group <br>TYPE(MPI_Comm), INTENT(OUT) :: newcomm <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_COMM_CREATE(COMM, GROUP, NEWCOMM, IERROR)<br> INTEGER COMM, GROUP, NEWCOMM, IERROR <br></tt>  
<P> 
  
  
<P> 
 If <font face="sans-serif"> comm</font> is an intracommunicator, this function returns a new communicator <font face="sans-serif"> newcomm</font> with  
communication group defined by the <font face="sans-serif"> group</font> argument. No cached information propagates from  
<font face="sans-serif"> comm</font> to <font face="sans-serif"> newcomm</font>. Each process must call  
<font face="sans-serif"> MPI_COMM_CREATE</font> with a  
<font face="sans-serif"> group</font> argument that is a subgroup    
of the <font face="sans-serif"> group</font> associated with <font face="sans-serif"> comm</font>; this could be <font face="sans-serif">  MPI_GROUP_EMPTY</font>. The processes   
may specify different values for the <font face="sans-serif"> group</font> argument. If a process calls with a non-empty <font face="sans-serif"> group</font>  
then all processes in that <font face="sans-serif"> group</font> must call the function with the same <font face="sans-serif"> group</font> as argument,   
that is the same processes in the same  
order. Otherwise, the call is erroneous. This  
implies that the set of    
groups specified across the processes must be disjoint. If the calling process is a member of the group   
given as <font face="sans-serif"> group</font> argument, then <font face="sans-serif"> newcomm</font> is a communicator with <font face="sans-serif"> group</font> as its associated group. In the case   
that a process calls with a <font face="sans-serif"> group</font> to which it does not belong, e.g., <font face="sans-serif">  MPI_GROUP_EMPTY</font>, then <font face="sans-serif">  MPI_COMM_NULL</font>   
is returned as <font face="sans-serif"> newcomm</font>. The function is collective and must be called by all processes in the group of <font face="sans-serif"> comm</font>.  
<P> 
 
<br> 
<em> Rationale.</em>  
 <P> 
The interface supports the original mechanism from <font face="sans-serif"> MPI-1.1</font>, which required the same <font face="sans-serif"> group</font> in all   
processes of <font face="sans-serif"> comm</font>. It was extended in <font face="sans-serif"> MPI-2.2</font> to allow the use of disjoint subgroups in order to allow   
implementations to eliminate unnecessary communication that  <font face="sans-serif"> MPI_COMM_SPLIT</font> would incur when the user already   
knows the membership of the disjoint subgroups.   
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
The requirement that the entire group of <font face="sans-serif"> comm</font> participate in the call  
stems from the following considerations:  
<ul> 
 
<li>It allows the implementation to layer <font face="sans-serif"> MPI_COMM_CREATE</font> on top of  
regular collective communications.  
 
<li>It provides additional safety, in particular in the case where partially  
overlapping groups are used to create new communicators.  
 
<li>It permits implementations to  
sometimes avoid communication related to  
context   
creation.  
</ul> 
<br> 
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_COMM_CREATE</font> provides a means to subset a group of processes for the  
purpose of separate MIMD computation, with separate communication space.  
<font face="sans-serif"> newcomm</font>, which emerges from  
<font face="sans-serif"> MPI_COMM_CREATE</font>, can be used in   
subsequent calls to <font face="sans-serif"> MPI_COMM_CREATE</font> (or other communicator  
constructors) to  
further subdivide a computation into  
parallel sub-computations.  A more general service is provided by  
<font face="sans-serif"> MPI_COMM_SPLIT</font>, below.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
When calling <font face="sans-serif"> MPI_COMM_DUP</font>, all processes call with the same <font face="sans-serif"> group</font>   
(the <font face="sans-serif"> group</font> associated with the communicator).   
When calling <font face="sans-serif"> MPI_COMM_CREATE</font>, the processes provide the   
same <font face="sans-serif"> group</font> or disjoint subgroups. For both calls, it is theoretically possible   
to agree on a group-wide unique context with no communication.   
However, local execution of these functions requires  
use of a larger context name space and reduces error checking.  
Implementations may strike various compromises between these  
conflicting goals, such as bulk allocation of multiple contexts in one  
collective operation.  
<P> 
Important: If new communicators are created without synchronizing the  
processes involved then the communication system  
must be able to cope with   
messages arriving in a context that has not yet been allocated at the  
receiving process.  
 (<em> End of advice to implementors.</em>) <br> 
 If <font face="sans-serif"> comm</font> is an  
intercommunicator, then the output communicator is also an intercommunicator  
where the local group consists only of those processes contained in  
<font face="sans-serif"> group</font> (see Figure <a href="node156.htm#Figure14">14 
</a>).  The <font face="sans-serif"> group</font>   
argument should only contain those processes in the local group of the input  
intercommunicator that are to be a part of <font face="sans-serif"> newcomm</font>.   
All processes in the same local group of <font face="sans-serif"> comm</font> must specify the same value for   
<font face="sans-serif"> group</font>, i.e., the same members in the same order.  
If either  
<font face="sans-serif"> group</font> does not specify at least one process in the local group of  
the intercommunicator, or if the calling process is not included in the  
<font face="sans-serif"> group</font>, <font face="sans-serif">  MPI_COMM_NULL</font> is returned.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
In the case where either the left or right group is empty, a null communicator  
is returned instead of an intercommunicator with <font face="sans-serif">  MPI_GROUP_EMPTY</font>  
because the side with the empty group must return <font face="sans-serif">  MPI_COMM_NULL</font>.  
 (<em> End of rationale.</em>) <br> 
  <div style=\"text-align:center\"><P><img width=481 height=459 src="collective-create.gif" alt="Image file"><P>
</div>  
  <br> 
<b>Figure 14: </b><span id="Figure14">Intercommunicator 
    creation 
    using <font face="sans-serif"> MPI_COMM_CREATE</font> 
extended to intercommunicators.  The input groups are those in the grey
circle.</span><P> 
  
    
<br><b> Example</b>  
The following example illustrates how the first node in the left  
side of an intercommunicator could be joined with all members on the  
right side of an intercommunicator to form a new  
intercommunicator.  
<br> 
<pre><tt>        MPI_Comm  inter_comm, new_inter_comm; 
        MPI_Group local_group, group; 
        int       rank = 0; /* rank on left side to include in  
                               new inter-comm */ 
 
        /* Construct the original intercommunicator: "inter_comm" */ 
        ... 
 
        /* Construct the group of processes to be in new  
           intercommunicator */ 
        if (/* I'm on the left side of the intercommunicator */) { 
          MPI_Comm_group ( inter_comm, &amp;local_group ); 
          MPI_Group_incl ( local_group, 1, &amp;rank, &amp;group ); 
          MPI_Group_free ( &amp;local_group ); 
        } 
        else  
          MPI_Comm_group ( inter_comm, &amp;group ); 
 
        MPI_Comm_create ( inter_comm, group, &amp;new_inter_comm ); 
        MPI_Group_free( &amp;group ); 
</tt></pre> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_CREATE_GROUP(comm, group, tag, newcomm)</TD></TR>  
<TR><TD> IN comm</TD><TD>intracommunicator (handle)</TD></TR>  
<TR><TD> IN group</TD><TD>group, which is a subset of the group of <font face="sans-serif"> comm</font> (handle)</TD></TR>  
<TR><TD> IN tag</TD><TD>tag (integer)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>new communicator (handle)</TD></TR>  
</TABLE>  
<P> 
  
 <tt> int MPI_Comm_create_group(MPI_Comm comm, MPI_Group group, int tag, MPI_Comm *newcomm) <br></tt>  
<P> 
 <tt> MPI_Comm_create_group(comm, group, tag, newcomm, ierror)<br> TYPE(MPI_Comm), INTENT(IN) :: comm<br>TYPE(MPI_Group), INTENT(IN) :: group<br>INTEGER, INTENT(IN) :: tag<br>TYPE(MPI_Comm), INTENT(OUT) :: newcomm<br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
<P> 
 <tt> MPI_COMM_CREATE_GROUP(COMM, GROUP, TAG, NEWCOMM, IERROR)<br> INTEGER COMM, GROUP, TAG, NEWCOMM, IERROR <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> is similar to  
<font face="sans-serif"> MPI_COMM_CREATE</font>; however, <font face="sans-serif"> MPI_COMM_CREATE</font> must  
be called by all processes in the group of <font face="sans-serif"> comm</font>, whereas  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> must be called by all processes in  
<font face="sans-serif"> group</font>, which is a subgroup of the group of <font face="sans-serif"> comm</font>. In  
addition, <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> requires that  
<font face="sans-serif"> comm</font> is an  
intracommunicator. <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> returns a new  
intracommunicator, <font face="sans-serif"> newcomm</font>, for which the <font face="sans-serif"> group</font>  
argument defines the communication group. No cached information  
propagates from <font face="sans-serif"> comm</font> to <font face="sans-serif"> newcomm</font>. Each process must  
provide a group argument that is a subgroup of the group associated  
with <font face="sans-serif"> comm</font>; this could be <font face="sans-serif">  MPI_GROUP_EMPTY</font>. If a  
non-empty group is specified, then all processes in that group must  
call the function, and each of these processes must provide the same  
arguments, including a group that contains the same members with the  
same ordering. Otherwise the call is erroneous. If the calling process  
is a member of the group given as the <font face="sans-serif"> group</font> argument, then  
<font face="sans-serif"> newcomm</font> is a communicator with <font face="sans-serif"> group</font> as its  
associated group. If the calling process is not a member of  
<font face="sans-serif"> group</font>, e.g., <font face="sans-serif"> group</font> is <font face="sans-serif">  MPI_GROUP_EMPTY</font>, then  
the call is a local operation and <font face="sans-serif">  MPI_COMM_NULL</font> is returned  
as <font face="sans-serif"> newcomm</font>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
Functionality similar to <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> can be  
implemented through repeated <font face="sans-serif"> MPI_INTERCOMM_CREATE</font> and  
<font face="sans-serif"> MPI_INTERCOMM_MERGE</font> calls that start with the  
<font face="sans-serif">  MPI_COMM_SELF</font> communicators at each process in  
<font face="sans-serif"> group</font> and build up an intracommunicator with group  
<font face="sans-serif"> group</font> [<a href="node522.htm#-Bib16">16</a>]. Such an algorithm  
requires the creation of many intermediate communicators;  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> can provide a more efficient  
implementation that avoids this overhead.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
An intercommunicator can be created collectively over processes in the union of the local and remote groups by creating the local communicator using <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> and using that communicator as the local communicator argument to <font face="sans-serif"> MPI_INTERCOMM_CREATE</font>.  
 (<em> End of advice to users.</em>) <br> 
The <font face="sans-serif"> tag</font> argument does not conflict with tags used in  
point-to-point communication and is not permitted to be a wildcard. If  
multiple threads at a given process perform concurrent  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> operations, the user must  
distinguish these operations by providing different <font face="sans-serif"> tag</font> or  
<font face="sans-serif"> comm</font> arguments.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_COMM_CREATE</font> may provide lower overhead than  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> because it can take advantage of  
collective communication on <font face="sans-serif"> comm</font> when constructing <font face="sans-serif"> newcomm</font>.  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_SPLIT(comm, color, key, newcomm)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN color</TD><TD>control of subset assignment (integer)</TD></TR>  
<TR><TD> IN key</TD><TD> control of rank assigment (integer)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD> new communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_split(MPI_Comm comm, int color, int key, MPI_Comm *newcomm) <br></tt>  
<P> 
 <tt> MPI_Comm_split(comm, color, key, newcomm, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(IN) :: color, key <br>TYPE(MPI_Comm), INTENT(OUT) :: newcomm <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_COMM_SPLIT(COMM, COLOR, KEY, NEWCOMM, IERROR)<br> INTEGER COMM, COLOR, KEY, NEWCOMM, IERROR <br></tt>  
<P> 
  
  
<P> 
 This function partitions the group associated with <font face="sans-serif"> comm</font>  
into disjoint subgroups, one for each value of <font face="sans-serif"> color</font>.  Each subgroup  
contains all processes of the same color.  Within each subgroup, the processes  
are ranked in the order defined by the value of the argument <font face="sans-serif"> key</font>,  
with ties broken according to their rank in the old group.  A new communicator  
is created for each subgroup and returned in <font face="sans-serif"> newcomm</font>.  A process may  
supply the color value <font face="sans-serif"> MPI_UNDEFINED</font>, in which case <font face="sans-serif"> newcomm</font>  
returns <font face="sans-serif">  MPI_COMM_NULL</font>.  This is a collective call, but each process  
is permitted to provide different values for <font face="sans-serif"> color</font> and <font face="sans-serif"> key</font>.  
<P> 
With an intracommunicator <font face="sans-serif"> comm</font>, a call to <font face="sans-serif"> MPI_COMM_CREATE(comm, group, newcomm)</font> is   
equivalent to a call to <font face="sans-serif"> MPI_COMM_SPLIT(comm, color, key, newcomm)</font>, where processes  
that are members of their <font face="sans-serif"> group</font> argument provide  
<font face="sans-serif"> color</font><i>~=~</i>number of the <font face="sans-serif"> group</font>  
(based on a unique numbering of all disjoint groups) and   
<font face="sans-serif"> key</font><i>~=~</i>rank in <font face="sans-serif"> group</font>, and  
all processes that are not members of their <font face="sans-serif"> group</font> argument provide   
<font face="sans-serif"> color</font><i>~=~</i><font face="sans-serif"> MPI_UNDEFINED</font>.  
<P> 
The value of <font face="sans-serif"> color</font> must be  
non-negative or <font face="sans-serif">  MPI_UNDEFINED</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
This is an extremely powerful mechanism for dividing a single  
communicating  group of processes into <i>k</i> subgroups, with <i>k</i> chosen  
implicitly by the user (by the number of  
colors asserted over all the processes).  Each resulting communicator will be  
non-overlapping.  Such a division could be useful for defining a hierarchy  
of computations, such as for multigrid, or linear algebra.  
For intracommunicators, <font face="sans-serif"> MPI_COMM_SPLIT</font> provides similar capability as <font face="sans-serif"> MPI_COMM_CREATE</font>   
to split a communicating group into disjoint subgroups. <font face="sans-serif"> MPI_COMM_SPLIT</font> is useful   
when some processes do not have complete information of the other members in their   
group, but all processes know (the color of) the group to which they belong.   
In this case, the <font face="sans-serif"> MPI</font> implementation discovers the other group members via   
communication. <font face="sans-serif"> MPI_COMM_CREATE</font> is useful when all processes have complete   
information of the members of their group. In this case, <font face="sans-serif"> MPI</font> can avoid the extra   
communication required to discover group membership.   
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> is useful when  
all processes in a given group have complete information of the members of   
their group and synchronization with processes outside the group can be   
avoided.  
<P> 
Multiple calls to <font face="sans-serif"> MPI_COMM_SPLIT</font> can be used to overcome the  
requirement that any call have no overlap of the resulting communicators (each  
process is of only one color per call).  In this way, multiple overlapping  
communication structures can be created.  Creative use of the <font face="sans-serif"> color</font>  
and <font face="sans-serif"> key</font> in such splitting operations is encouraged.  
<P> 
Note that, for a fixed color, the keys need not  
be unique.  It is <font face="sans-serif"> MPI_COMM_SPLIT</font>'s responsibility to sort processes  
in ascending order according to this key, and to break ties in a consistent  
way.  If all the keys are specified in the same way, then all the processes  
in a given color will have the relative rank order as they did in their  
parent group.    
<P> 
Essentially, making the key value zero for all processes of a given color  
means that one does not really care about the rank-order of the processes in  
the new communicator.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
<font face="sans-serif"> color</font> is restricted to be non-negative, so as not to confict with the value assigned to <font face="sans-serif">  MPI_UNDEFINED</font>.  
 (<em> End of rationale.</em>) <br> 
 The result of <font face="sans-serif"> MPI_COMM_SPLIT</font> on an intercommunicator is that those  
processes on the left with the same <font face="sans-serif"> color</font> as those processes on  
the right combine to create a new intercommunicator.  The <font face="sans-serif"> key</font>  
argument describes the relative rank of processes on each side of the  
intercommunicator (see Figure <a href="node156.htm#Figure15">15 
</a>).  For those colors  
that are specified only on one side of the intercommunicator,  
<font face="sans-serif">  MPI_COMM_NULL</font> is returned.  <font face="sans-serif">  MPI_COMM_NULL</font>   
is also returned to those processes that specify <font face="sans-serif">  MPI_UNDEFINED</font>  
as the color.  
 
<br> 
<em> Advice to users.</em>  
<P> 
For intercommunicators, <font face="sans-serif"> MPI_COMM_SPLIT</font> is more general than <font face="sans-serif"> MPI_COMM_CREATE</font>.   
A single call to <font face="sans-serif"> MPI_COMM_SPLIT</font> can create a set of disjoint intercommunicators,   
while a call to <font face="sans-serif"> MPI_COMM_CREATE</font> creates only one.  
 (<em> End of advice to users.</em>) <br> 
  <div style=\"text-align:center\"><P><img width=293 height=431 src="collective-split2.gif" alt="Image file"><P>
</div>  
  <br> 
<b>Figure 15: </b><span id="Figure15">Intercommunicator construction achieved by splitting an
    existing intercommunicator with <font face="sans-serif"> MPI_COMM_SPLIT</font>
extended to intercommunicators.</span><P> 
  
    
<br><b> Example</b>(Parallel client-server model).  
The following client code illustrates how clients on the left side of an  
intercommunicator could be assigned to a single server from a pool of  
servers on the right side of an intercommunicator.  
<br> 
<pre><tt>        /* Client code */ 
        MPI_Comm  multiple_server_comm; 
        MPI_Comm  single_server_comm; 
        int       color, rank, num_servers; 
         
        /* Create intercommunicator with clients and servers:  
           multiple_server_comm */ 
        ... 
         
        /* Find out the number of servers available */ 
        MPI_Comm_remote_size ( multiple_server_comm, &amp;num_servers ); 
         
        /* Determine my color */ 
        MPI_Comm_rank ( multiple_server_comm, &amp;rank ); 
        color = rank % num_servers; 
         
        /* Split the intercommunicator */ 
        MPI_Comm_split ( multiple_server_comm, color, rank,  
                         &amp;single_server_comm ); 
</tt></pre> 
 The following is the corresponding server code:  
<br> 
<pre><tt>        /* Server code */ 
        MPI_Comm  multiple_client_comm; 
        MPI_Comm  single_server_comm; 
        int       rank; 
 
        /* Create intercommunicator with clients and servers:  
           multiple_client_comm */ 
        ... 
         
        /* Split the intercommunicator for a single server per group 
           of clients */ 
        MPI_Comm_rank ( multiple_client_comm, &amp;rank ); 
        MPI_Comm_split ( multiple_client_comm, rank, 0,  
                         &amp;single_server_comm );   
</tt></pre> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_SPLIT_TYPE(comm, split_type, key, info, newcomm)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN split_type</TD><TD>type of processes to be grouped together (integer)</TD></TR>  
<TR><TD> IN key</TD><TD>control of rank assignment (integer)</TD></TR>  
<TR><TD> IN info</TD><TD>info argument (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD> new communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_split_type(MPI_Comm comm, int split_type, int key, MPI_Info info, MPI_Comm *newcomm) <br></tt>  
<P> 
 <tt> MPI_Comm_split_type(comm, split_type, key, info, newcomm, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(IN) :: split_type, key <br>TYPE(MPI_Info), INTENT(IN) :: info <br>TYPE(MPI_Comm), INTENT(OUT) :: newcomm <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_COMM_SPLIT_TYPE(COMM, SPLIT_TYPE, KEY, INFO, NEWCOMM, IERROR)<br> INTEGER COMM, SPLIT_TYPE, KEY, INFO, NEWCOMM, IERROR <br></tt>  
<P> 
 This function partitions the group associated with  
<font face="sans-serif"> comm</font> into disjoint subgroups, based on the type specified by  
<font face="sans-serif"> split_type</font>. Each subgroup contains all processes of the same  
type.  Within each subgroup, the processes are ranked in the order  
defined by the value of the argument <font face="sans-serif"> key</font>, with ties broken  
according to their rank in the old group.  A new communicator is  
created for each subgroup and returned in <font face="sans-serif"> newcomm</font>. This is a  
collective call; all processes must provide the same  
<font face="sans-serif"> split_type</font>, but each process is permitted to provide  
different values for <font face="sans-serif"> key</font>. An exception to this rule is that a  
process may supply the type value <font face="sans-serif"> MPI_UNDEFINED</font>, in which  
case <font face="sans-serif"> newcomm</font> returns <font face="sans-serif">  MPI_COMM_NULL</font>.  
<P> 
The following type is predefined by MPI:  
<P> 
<dl> 
 
<dt> 
<b></b><dd> 
<font face="sans-serif">  MPI_COMM_TYPE_SHARED</font> --- this type splits the  
  communicator into subcommunicators, each of which can create a  
  shared memory region.  
<P> 
</dl> 
<br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Implementations can define their own types, or use the <font face="sans-serif"> info</font>  
argument, to assist in creating communicators that help expose  
platform-specific information to the application.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node155.htm#Node155"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node154.htm#Node154"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node157.htm#Node157"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node154.htm#Node154"> Communicator Management</a>
<b>Next: </b><a href="node157.htm#Node157"> Communicator Destructors</a>
<b>Previous: </b><a href="node155.htm#Node155"> Communicator Accessors</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
