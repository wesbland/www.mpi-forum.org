<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-dynamic/dynamic-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Starting Processes and Establishing Communication</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node237">220. Starting Processes and Establishing Communication</span></h2>
<a href="node236.htm#Node236"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node235.htm#Node235"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node238.htm#Node238"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node235.htm#Node235"> Process Manager Interface</a>
<b>Next: </b><a href="node238.htm#Node238"> Starting Multiple Executables and Establishing Communication</a>
<b>Previous: </b><a href="node236.htm#Node236"> Processes in <font face="sans-serif"> MPI</font></a>
<p>
  
<P> 
The following routine starts a number of <font face="sans-serif"> MPI</font> processes and  
establishes communication with them, returning an intercommunicator.   
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
It is possible in <font face="sans-serif"> MPI</font> to start a static SPMD or MPMD application by  
first starting one process and having   
that process start its siblings  
with <font face="sans-serif"> MPI_COMM_SPAWN</font>. This practice is discouraged primarily for  
reasons of performance.  If possible, it is preferable to start all  
processes at once, as a single   
<font face="sans-serif"> MPI</font>   
application.  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_SPAWN(command, argv, maxprocs, info,   
root, comm, intercomm,  array_of_errcodes)</TD></TR>  
<TR><TD> IN command</TD><TD>name of program to be spawned (string, significant only at root)</TD></TR>  
<TR><TD> IN argv</TD><TD>arguments to <font face="sans-serif"> command</font> (array of strings, significant only at root)</TD></TR>  
<TR><TD> IN maxprocs</TD><TD>maximum number of processes to start  
(integer, significant only at root)</TD></TR>  
<TR><TD> IN info</TD><TD>a set of key-value pairs telling the runtime system where and how to  
start the processes (handle, significant only at root)</TD></TR>  
<TR><TD> IN root</TD><TD>rank of process in which previous arguments are   
examined (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>intracommunicator containing group of spawning processes (handle)</TD></TR>  
<TR><TD> OUT intercomm</TD><TD>intercommunicator between original group and  
the <br>  
newly spawned group (handle)</TD></TR>  
<TR><TD> OUT array_of_errcodes</TD><TD>one code per process (array of integer)</TD></TR>  
</TABLE>  
 <tt> int MPI_Comm_spawn(const char *command, char *argv[], int maxprocs, MPI_Info info, int root, MPI_Comm comm, MPI_Comm *intercomm, int array_of_errcodes[]) <br></tt>  
 <tt> MPI_Comm_spawn(command, argv, maxprocs, info, root, comm, intercomm, array_of_errcodes, ierror) <br> CHARACTER(LEN=*), INTENT(IN) :: command, argv(*) <br>INTEGER, INTENT(IN) :: maxprocs, root <br>TYPE(MPI_Info), INTENT(IN) :: info <br>TYPE(MPI_Comm), INTENT(IN) :: comm <br>TYPE(MPI_Comm), INTENT(OUT) :: intercomm <br>INTEGER :: array_of_errcodes(*) <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_COMM_SPAWN(COMMAND, ARGV, MAXPROCS, INFO, ROOT, COMM, INTERCOMM, ARRAY_OF_ERRCODES, IERROR)<br> CHARACTER*(*) COMMAND, ARGV(*) <br>INTEGER INFO, MAXPROCS, ROOT, COMM, INTERCOMM, ARRAY_OF_ERRCODES(*), IERROR <br></tt>  
  
  
<P> 
<font face="sans-serif"> MPI_COMM_SPAWN</font> tries to start <font face="sans-serif"> maxprocs</font> identical copies  
of the <font face="sans-serif"> MPI</font> program specified by <font face="sans-serif"> command</font>, establishing  
communication with them and returning an intercommunicator.   
The spawned processes are referred to as children.  
The children have their own  
<font face="sans-serif">  MPI_COMM_WORLD</font>, which is separate from that of the parents.  
<font face="sans-serif"> MPI_COMM_SPAWN</font> is collective over <font face="sans-serif"> comm</font>, and also may not  
return until <font face="sans-serif"> MPI_INIT</font> has been called in the children.   
Similarly, <font face="sans-serif"> MPI_INIT</font> in the children may not return  
until all parents have called <font face="sans-serif"> MPI_COMM_SPAWN</font>. In this   
sense, <font face="sans-serif"> MPI_COMM_SPAWN</font> in the parents and <font face="sans-serif"> MPI_INIT</font>   
in the children form a collective operation over the union   
of parent and child processes.   
The intercommunicator  
returned by <font face="sans-serif"> MPI_COMM_SPAWN</font> contains the parent processes in   
the local group and the child processes in the remote group.   
The ordering of processes in the local and remote groups is the same   
as the  
ordering of the group of the <font face="sans-serif"> comm</font>  
in the parents  
and of <font face="sans-serif">  MPI_COMM_WORLD</font> of the children, respectively.   
This intercommunicator can be obtained in the children through the function  
<font face="sans-serif"> MPI_COMM_GET_PARENT</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
An implementation may automatically establish communication before  
<font face="sans-serif"> MPI_INIT</font> is called by the children. Thus, completion of  
<font face="sans-serif"> MPI_COMM_SPAWN</font> in the parent does not necessarily mean that  
<font face="sans-serif"> MPI_INIT</font> has been called in the children (although the   
returned intercommunicator can be used immediately).   
 (<em> End of advice to users.</em>) <br> 
<P> 
The <font face="sans-serif"> command</font> argument The <font face="sans-serif"> command</font> argument is a string containing the name of   
a program to be spawned. The string is null-terminated in C.   
In Fortran, leading and trailing spaces are stripped.   
<font face="sans-serif"> MPI</font> does not specify how to find the executable or how the working  
directory is determined. These rules are implementation-dependent  
and should be appropriate for the runtime environment.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The implementation should use a natural rule for finding  
executables and determining working directories.  For instance, a  
homogeneous system with a global file system might look first in the  
working directory of the spawning process, or might search the  
directories in a PATH environment variable as do Unix shells. An  
implementation on top of PVM would use PVM's rules for finding  
executables (usually in <tt>$HOME/pvm3/bin/$PVM_ARCH</tt>).   
An <font face="sans-serif"> MPI</font> implementation running under POE on an  
IBM SP would use POE's method of finding executables. An implementation   
should document its rules for finding executables and determining  
working directories, and a high-quality implementation should give the   
user some control over these rules.   
 (<em> End of advice to implementors.</em>) <br> 
If the program named in <font face="sans-serif"> command</font> does not call  
<font face="sans-serif"> MPI_INIT</font>, but instead forks a process that calls  
<font face="sans-serif"> MPI_INIT</font>, the results are undefined. Implementations  
may allow this case to work but are not required to.   
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI</font> does not say what happens if the program you start is   
a shell script and that shell script starts a program that  
calls <font face="sans-serif"> MPI_INIT</font>. Though some implementations may allow   
you to do this, they may also have restrictions, such as requiring  
that arguments supplied to the shell script be supplied  
to the program, or requiring that certain parts of the environment  
not be changed.   
 (<em> End of advice to users.</em>) <br> 
<P> 
The <font face="sans-serif"> argv</font> argument <font face="sans-serif"> argv</font> is an array of strings containing   
arguments that are passed to the program.   
The first element of <font face="sans-serif"> argv</font> is the first argument  
passed to <font face="sans-serif"> command</font>, not, as is conventional in   
some contexts, the command itself. The argument list is terminated  
by <font face="sans-serif">  NULL</font> in C and an empty string   
in Fortran. In Fortran,   
leading and trailing spaces are always stripped, so that a string consisting  
of all spaces is considered an empty string.   
The constant <font face="sans-serif">  MPI_ARGV_NULL</font> may be used in C and  
Fortran to indicate an empty argument list. In C this constant is the same as   
<font face="sans-serif">  NULL</font>.   
<P> 
<br><b> Example</b>  
Examples of <font face="sans-serif"> argv</font> in C and Fortran  
  
 To run the program ``ocean'' with arguments ``-gridfile'' and  
``ocean1.grd'' in C:  
<br> 
<pre><tt>       char command[] = "ocean"; 
       char *argv[] = {"-gridfile", "ocean1.grd", NULL}; 
       MPI_Comm_spawn(command, argv, ...); 
</tt></pre> 
or, if not everything is known at compile time:  
<br> 
<pre><tt>       char *command; 
       char **argv; 
       command = "ocean"; 
       argv=(char **)malloc(3 * sizeof(char *)); 
       argv[0] = "-gridfile"; 
       argv[1] = "ocean1.grd"; 
       argv[2] = NULL; 
       MPI_Comm_spawn(command, argv, ...); 
</tt></pre> 
In Fortran:  
<br> 
<pre><tt>       CHARACTER*25 command, argv(3) 
       command = ' ocean ' 
       argv(1) = ' -gridfile ' 
       argv(2) = ' ocean1.grd' 
       argv(3) = ' ' 
       call MPI_COMM_SPAWN(command, argv, ...) 
</tt></pre> 
  
<P> 
Arguments are supplied to the program if this is allowed by the  
operating system. In C, the <font face="sans-serif"> MPI_COMM_SPAWN</font> argument  
<font face="sans-serif"> argv</font> differs from the <tt>argv</tt>  
argument of <tt>main</tt> in two respects. First, it is shifted by one element.  
Specifically, <tt>argv[0]</tt> of <tt>main</tt> is provided  
by the implementation and conventionally contains  
the name of the program (given by <font face="sans-serif"> command</font>). <tt>argv[1]</tt>   
of <tt>main</tt> corresponds to <font face="sans-serif"> argv[0]</font> in  
<font face="sans-serif"> MPI_COMM_SPAWN</font>, <tt>argv[2]</tt> of <tt>main</tt> to  
<font face="sans-serif"> argv[1]</font> of <font face="sans-serif"> MPI_COMM_SPAWN</font>, etc.   
Passing an <font face="sans-serif"> argv</font> of  
<font face="sans-serif">  MPI_ARGV_NULL</font> to <font face="sans-serif"> MPI_COMM_SPAWN</font>   
results in <tt>main</tt> receiving <tt>argc</tt> of 1  
and an <tt>argv</tt> whose element 0 is (conventionally) the  
name of the program.   
Second, <font face="sans-serif"> argv</font> of <font face="sans-serif"> MPI_COMM_SPAWN</font> must be null-terminated, so that its length can be determined.   
<P> 
If a Fortran implementation supplies  
routines that allow a program to obtain its arguments, the  
arguments may be available through that mechanism.   
In C, if the operating system does not support   
arguments appearing in <tt>argv</tt> of <tt>main()</tt>,   
the <font face="sans-serif"> MPI</font> implementation may add the  
arguments to the <font face="sans-serif"> argv</font> that is passed to <font face="sans-serif"> MPI_INIT</font>.   
<P> 
<P> 
The <font face="sans-serif"> maxprocs</font> argument <font face="sans-serif"> MPI</font> tries to spawn <font face="sans-serif"> maxprocs</font> processes.  If it is unable to  
spawn <font face="sans-serif"> maxprocs</font> processes, it raises an error  
of class <font face="sans-serif"> MPI_ERR_SPAWN</font>.  
<P> 
An implementation may allow the <font face="sans-serif"> info</font> argument to change  
the default behavior, such that if the implementation is  
unable to spawn all <font face="sans-serif"> maxprocs</font> processes, it may  
spawn a smaller number of processes instead of raising  
an error. In principle, the <font face="sans-serif"> info</font>   
argument may specify an arbitrary set <img width=121 height=11 src="img185.gif" alt="Image file">
 of allowed values for the number of   
processes spawned. The set <i>{m<SUB>i</SUB>}</i> does not necessarily  
include the value <font face="sans-serif"> maxprocs</font>. If an implementation  
is able to spawn one of these allowed numbers of processes,  
<font face="sans-serif"> MPI_COMM_SPAWN</font> returns successfully  
and the number of spawned processes, <i>m</i>,   
is given by the size of the remote group of <font face="sans-serif"> intercomm</font>.   
If <i>m</i> is less than  
<font face="sans-serif"> maxproc</font>, reasons why the other processes  
were not spawned are given in <font face="sans-serif"> array_of_errcodes</font>  
as described below.  If it is  
not possible to spawn one of the allowed numbers of processes,   
<font face="sans-serif"> MPI_COMM_SPAWN</font> raises an   
error of class <font face="sans-serif"> MPI_ERR_SPAWN</font>.  
<P> 
A spawn call with the default behavior is called <em> hard</em>.   
A spawn call for which fewer than <font face="sans-serif"> maxprocs</font> processes may be  
returned is called <em> </em><font face="sans-serif"> soft</font></em>. See Section <a href="node239.htm#Node239">Reserved Keys 
</a>  
for  
more information on the <font face="sans-serif"> soft</font> key for <font face="sans-serif"> info</font>.    
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
By default, requests are hard and <font face="sans-serif"> MPI</font> errors are fatal. This means  
that by default there will be a fatal error if <font face="sans-serif"> MPI</font> cannot  
spawn all the requested processes. If you want the behavior  
``spawn as many processes as possible, up to <i>N</i>,'' you   
should do a soft spawn, where the set of allowed values <i>{m<SUB>i</SUB>}</i>   
is <i>{0 ... N}</i>. However, this is not completely portable,   
as implementations are not required to support soft spawning.   
 (<em> End of advice to users.</em>) <br> 
<P> 
The <font face="sans-serif"> info</font> argument The <font face="sans-serif"> info</font> argument to all of the routines in this  
chapter is an opaque handle of type <font face="sans-serif"> MPI_Info</font>   
in C and Fortran with the <tt>mpi_f08</tt>   
module and  
<tt> INTEGER</tt> in Fortran with the <tt>mpi</tt> module or the include file <tt>mpif.h</tt>.    
It is a container for a number of user-specified  
(<font face="sans-serif"> key</font>,<font face="sans-serif"> value</font>) pairs. <font face="sans-serif"> key</font> and <font face="sans-serif"> value</font> are strings (null-terminated <tt>char*</tt> in  
C, <tt>character*(*)</tt> in Fortran). Routines to create and manipulate  
the <font face="sans-serif"> info</font>  
argument are described in Chapter <a href="node229.htm#Node229">The <font face="sans-serif"> Info</font> Object 
</a>.  
<P> 
For the <font face="sans-serif"> SPAWN</font> calls, <font face="sans-serif"> info</font> provides additional (and  
possibly implementation-dependent) instructions to <font face="sans-serif"> MPI</font> and the runtime  
system on how to start processes.   
An application may pass  
<font face="sans-serif">  MPI_INFO_NULL</font> in C or Fortran.  Portable programs not  
requiring detailed control over process locations should use  
<font face="sans-serif">  MPI_INFO_NULL</font>.  
<P> 
<font face="sans-serif"> MPI</font> does not specify the content of the <font face="sans-serif"> info</font> argument,   
except to reserve a number of special <font face="sans-serif"> key</font> values  
(see Section <a href="node239.htm#Node239">Reserved Keys 
</a>).  
The <font face="sans-serif"> info</font> argument is quite flexible and could even  
be used, for example,   
to specify the executable and its command-line arguments. In this  
case the <font face="sans-serif"> command</font> argument to <font face="sans-serif"> MPI_COMM_SPAWN</font> could be  
empty.  The ability to do this follows from the fact that <font face="sans-serif"> MPI</font> does not  
specify how an executable is found, and the <font face="sans-serif"> info</font> argument  
can tell the runtime system where to ``find'' the executable  
``'' (empty string).   
Of course a program that does  
this will not be portable across <font face="sans-serif"> MPI</font> implementations.  
<P> 
<P> 
The <font face="sans-serif"> root</font> argument All arguments before the <font face="sans-serif"> root</font> argument are examined only  
on the process whose rank in <font face="sans-serif"> comm</font> is equal to <font face="sans-serif"> root</font>.  
The value of these arguments on other processes is ignored.   
<P> 
<P> 
The <font face="sans-serif"> array_of_errcodes</font> argument The <font face="sans-serif"> array_of_errcodes</font> is an array of length <font face="sans-serif"> maxprocs</font>  
in which <font face="sans-serif"> MPI</font> reports the status of each process that  
<font face="sans-serif"> MPI</font> was requested to start. If all <font face="sans-serif"> maxprocs</font> processes were spawned,   
<font face="sans-serif"> array_of_errcodes</font> is filled in with the value  
<font face="sans-serif">  MPI_SUCCESS</font>. If only <i>m</i> (<img width=87 height=9 src="img186.gif" alt="Image file">
)  
processes are spawned, <i>m</i> of the entries will contain  
<font face="sans-serif">  MPI_SUCCESS</font> and the rest will contain  
an implementation-specific error code indicating the   
reason <font face="sans-serif"> MPI</font> could not start the process. <font face="sans-serif"> MPI</font> does not  
specify which entries correspond to failed processes.  
An implementation may, for instance, fill in   
error codes in one-to-one correspondence with  
a detailed specification in the <font face="sans-serif"> info</font>  
argument. These error codes  
all belong to the error class <font face="sans-serif"> MPI_ERR_SPAWN</font>  
if there was no error in the argument list.   
In C or  
Fortran,  
an application may pass <font face="sans-serif">  MPI_ERRCODES_IGNORE</font>  
if it is not interested in the error codes.   
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
<font face="sans-serif">  MPI_ERRCODES_IGNORE</font> in Fortran is a special type  
of constant, like <font face="sans-serif">  MPI_BOTTOM</font>.  
See the discussion in Section <a href="node28.htm#Node28">Named Constants 
</a>.  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_GET_PARENT(parent)</TD></TR>  
<TR><TD> OUT parent</TD><TD>the parent communicator (handle)</TD></TR>  
</TABLE>  
 <tt> int MPI_Comm_get_parent(MPI_Comm *parent) <br></tt>  
 <tt> MPI_Comm_get_parent(parent, ierror) <br> TYPE(MPI_Comm), INTENT(OUT) :: parent <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_COMM_GET_PARENT(PARENT, IERROR) <br> INTEGER PARENT, IERROR <br></tt>  
  
<P> 
If a process was started with <font face="sans-serif"> MPI_COMM_SPAWN</font> or   
<font face="sans-serif"> MPI_COMM_SPAWN_MULTIPLE</font>,   
<font face="sans-serif"> MPI_COMM_GET_PARENT</font> returns the ``parent'' intercommunicator  
of the current process. This parent intercommunicator is created   
implicitly inside of <font face="sans-serif"> MPI_INIT</font> and is the same  
intercommunicator returned by <font face="sans-serif"> SPAWN</font> in the parents.  
<P> 
If the process was not spawned, <font face="sans-serif"> MPI_COMM_GET_PARENT</font>  
returns <font face="sans-serif">  MPI_COMM_NULL</font>.  
<P> 
After the parent communicator is freed or disconnected, <font face="sans-serif"> MPI_COMM_GET_PARENT</font>  
returns <font face="sans-serif">  MPI_COMM_NULL</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_COMM_GET_PARENT</font> returns a handle to a single intercommunicator.   
Calling <font face="sans-serif"> MPI_COMM_GET_PARENT</font> a second time returns a handle  
to the same intercommunicator. Freeing the handle with <font face="sans-serif"> MPI_COMM_DISCONNECT</font>  
or <font face="sans-serif"> MPI_COMM_FREE</font> will cause other references to   
the intercommunicator to become invalid (dangling).   
Note that calling <font face="sans-serif"> MPI_COMM_FREE</font> on the parent  
communicator is not useful.   
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
The desire of the Forum was to create a constant <font face="sans-serif">  MPI_COMM_PARENT</font>  
similar to <font face="sans-serif">  MPI_COMM_WORLD</font>. Unfortunately such a constant cannot  
be used (syntactically) as an argument to <font face="sans-serif"> MPI_COMM_DISCONNECT</font>,   
which is explicitly allowed.   
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node236.htm#Node236"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node235.htm#Node235"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node238.htm#Node238"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node235.htm#Node235"> Process Manager Interface</a>
<b>Next: </b><a href="node238.htm#Node238"> Starting Multiple Executables and Establishing Communication</a>
<b>Previous: </b><a href="node236.htm#Node236"> Processes in <font face="sans-serif"> MPI</font></a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
