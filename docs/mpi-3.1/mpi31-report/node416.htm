<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Additional Support for Fortran Numeric Intrinsic Types</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node416">363. Additional Support for Fortran Numeric Intrinsic Types</span></h2>
<a href="node415.htm#Node415"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node416.htm#Node417"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node416.htm#Node417"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<b>Previous: </b><a href="node415.htm#Node415"> Additional Support for Fortran Register-Memory-Synchronization</a>
<p>
  
<P> 
<font face="sans-serif"> MPI</font>   
provides a small number of named datatypes that correspond to  
named intrinsic types supported by C and Fortran. These include  
<font face="sans-serif">  MPI_INTEGER</font>, <font face="sans-serif">  MPI_REAL</font>, <font face="sans-serif">  MPI_INT</font>,  
<font face="sans-serif">  MPI_DOUBLE</font>, etc., as well as the optional types  
<font face="sans-serif">  MPI_REAL4</font>, <font face="sans-serif">  MPI_REAL8</font>, etc.  There is a one-to-one  
correspondence between language declarations and <font face="sans-serif"> MPI</font> types.  
<P> 
Fortran (starting with Fortran 90) provides so-called <tt>KIND</tt>-parameterized  
types. These types are declared using an intrinsic type (one of   
<tt> INTEGER</tt>, <tt> REAL</tt>, <tt> COMPLEX</tt>, <tt> LOGICAL</tt>, and   
<tt> CHARACTER</tt>) with an optional integer  
<tt>KIND</tt> parameter that selects from among one or more variants.  
The specific meaning of different <tt>KIND</tt> values themselves are   
implementation dependent and not specified by the language.  
Fortran  
provides the <tt>KIND</tt> selection functions <tt>selected_real_kind</tt>   
for <tt> REAL</tt> and <tt> COMPLEX</tt> types, and  
<tt>selected_int_kind</tt> for <tt> INTEGER</tt> types  
that allow users to declare variables  
with a minimum precision or number of digits. These functions provide  
a portable way to declare <tt>KIND</tt>-parameterized <tt> REAL</tt>,  
<tt> COMPLEX</tt>, and <tt> INTEGER</tt> variables in Fortran.   
This scheme is backward compatible with Fortran 77. <tt> REAL</tt> and  
<tt> INTEGER</tt> Fortran variables have a default <tt>KIND</tt> if none  
is specified. Fortran <tt> DOUBLE PRECISION</tt> variables are of  
intrinsic type <tt> REAL</tt> with a non-default <tt>KIND</tt>. The following  
two declarations are equivalent:  
<br> 
<pre><tt>    double precision x 
    real(KIND(0.0d0)) x 
</tt></pre> 
<font face="sans-serif"> MPI</font> provides two orthogonal methods for handling communication  
buffers of  
numeric intrinsic types. The first method   
(see the following section)   
can be used when  
variables have been declared in a portable way --- using  
default <tt>KIND</tt> or using <tt>KIND</tt> parameters obtained with  
the <tt>selected_int_kind</tt> or <tt>selected_real_kind</tt>  
functions. With this method, <font face="sans-serif"> MPI</font> automatically   
selects the correct data size (e.g., 4 or 8 bytes) and  
provides representation conversion in heterogeneous   
environments.  The second method   
(see ``Support for size-specific <font face="sans-serif"> MPI</font> Datatypes'' on page <a href="node416.htm#Node418">Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes 
</a>)   
gives the user complete  
control over communication by exposing machine representations.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node415.htm#Node415"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node416.htm#Node417"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node416.htm#Node417"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<b>Previous: </b><a href="node415.htm#Node415"> Additional Support for Fortran Register-Memory-Synchronization</a>
<p>
<hr><h3><span id="Node417">363.1. Parameterized Datatypes with Specified Precision and Exponent Range</span></h3>
<a href="node416.htm#Node416"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node416.htm#Node416"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node416.htm#Node418"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node416.htm#Node416"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node416.htm#Node418"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<b>Previous: </b><a href="node416.htm#Node416"> Additional Support for Fortran Numeric Intrinsic Types</a>
<p>
<font face="sans-serif"> MPI</font>   
provides named datatypes corresponding to standard Fortran 77  
numeric types: <font face="sans-serif">  MPI_INTEGER</font>, <font face="sans-serif">  MPI_COMPLEX</font>,  
<font face="sans-serif">  MPI_REAL</font>, <font face="sans-serif">  MPI_DOUBLE_PRECISION</font> and <font face="sans-serif">  MPI_DOUBLE_COMPLEX</font>.  
<font face="sans-serif"> MPI</font> automatically selects the correct data size and provides  
representation conversion in heterogeneous environments. The  
mechanism described in this section extends this model  
to support portable parameterized numeric types.   
<P> 
The model for supporting portable parameterized types is as follows.   
Real variables are declared (perhaps indirectly) using  
<tt>selected_real_kind(p, r)</tt> to determine the <tt>KIND</tt> parameter, where  
<tt>p</tt> is decimal digits of precision and <tt>r</tt> is an exponent range.  
Implicitly <font face="sans-serif"> MPI</font> maintains  
a two-dimensional array of predefined <font face="sans-serif"> MPI</font> datatypes <tt>D(p, r)</tt>.  
<tt>D(p, r)</tt> is defined for each value of <tt>(p, r)</tt> supported  
by the compiler, including pairs for which one value is unspecified.   
Attempting to access an element of the array with an index <tt>(p, r)</tt> not   
supported by the compiler is erroneous.  
<font face="sans-serif"> MPI</font> implicitly maintains a similar array of <tt> COMPLEX</tt> datatypes.   
For integers, there is a similar implicit array related to   
<tt>selected_int_kind</tt> and indexed by  
the requested number of digits <tt>r</tt>. Note that the predefined datatypes  
contained in these implicit arrays are not the same as the named  
<font face="sans-serif"> MPI</font> datatypes <font face="sans-serif">  MPI_REAL</font>, etc., but a new set.   
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The above description is for explanatory purposes only. It is not  
expected that implementations will have such internal arrays.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<tt>selected_real_kind()</tt> maps a large number of <tt>(p,r)</tt> pairs  
to a much smaller number of <tt>KIND</tt> parameters supported by the compiler.  
<tt>KIND</tt> parameters are not specified by the language and are not  
portable.  From the language point of view intrinsic types of the  
same base type and <tt>KIND</tt> parameter are of the same type.  
In order to allow interoperability in a heterogeneous environment,  
<font face="sans-serif"> MPI</font> is more stringent. The corresponding <font face="sans-serif"> MPI</font> datatypes match if  
and only if they have the same <tt>(p,r)</tt> value (<tt> REAL</tt> and <tt> COMPLEX</tt>) or  
<tt>r</tt> value (<tt> INTEGER</tt>). Thus <font face="sans-serif"> MPI</font> has many more datatypes than  
there are fundamental language types.   
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_F90_REAL(p, r, newtype)</TD></TR>  
<TR><TD> IN p</TD><TD>precision, in decimal digits (integer)</TD></TR>  
<TR><TD> IN r</TD><TD>decimal exponent range (integer)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>the requested <font face="sans-serif"> MPI</font> datatype (handle)</TD></TR>  
</TABLE>  
 <tt> int MPI_Type_create_f90_real(int p, int r, MPI_Datatype *newtype) <br></tt>  
 <tt> MPI_Type_create_f90_real(p, r, newtype, ierror) <br> INTEGER, INTENT(IN) :: p, r <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_CREATE_F90_REAL(P, R, NEWTYPE, IERROR)<br> INTEGER P, R, NEWTYPE, IERROR <br></tt>  
<P> 
This function returns a predefined <font face="sans-serif"> MPI</font> datatype that matches a <tt> REAL</tt> variable  
of <tt>KIND</tt> <tt>selected_real_kind(p, r)</tt>. In the model described above  
it returns a handle for the element <tt>D(p, r)</tt>.  
Either <tt>p</tt> or <tt>r</tt> may be omitted from calls to   
<tt>selected_real_kind(p, r)</tt> (but not both).  Analogously, either   
<tt>p</tt> or <tt>r</tt> may be set to <font face="sans-serif">  MPI_UNDEFINED</font>.  
In communication, an <font face="sans-serif"> MPI</font> datatype <tt>A</tt> returned by   
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font> matches a datatype <tt>B</tt>  
if and only if <tt>B</tt> was returned by <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>  
called with the same values for <tt>p</tt> and <tt>r</tt> or <tt>B</tt>  
is a duplicate of such a datatype.   
Restrictions on using the returned datatype with the ``external32'' data  
representation are given on page <a href="node416.htm#Node417">Parameterized Datatypes with Specified Precision and Exponent Range 
</a>.  
<P> 
It is erroneous to supply values for <font face="sans-serif"> p</font> and <font face="sans-serif"> r</font> not  
supported by the compiler.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_F90_COMPLEX(p, r, newtype)</TD></TR>  
<TR><TD> IN p</TD><TD>precision, in decimal digits (integer)</TD></TR>  
<TR><TD> IN r</TD><TD>decimal exponent range (integer)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>the requested <font face="sans-serif"> MPI</font> datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_f90_complex(int p, int r, MPI_Datatype *newtype) <br></tt>  
 <tt> MPI_Type_create_f90_complex(p, r, newtype, ierror) <br> INTEGER, INTENT(IN) :: p, r <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_CREATE_F90_COMPLEX(P, R, NEWTYPE, IERROR)<br> INTEGER P, R, NEWTYPE, IERROR <br></tt>  
<P> 
This function returns a predefined <font face="sans-serif"> MPI</font> datatype that matches a <tt> COMPLEX</tt> variable  
of <tt>KIND</tt> <tt>selected_real_kind(p, r)</tt>.  
Either <tt>p</tt> or <tt>r</tt> may be omitted from calls to   
<tt>selected_real_kind(p, r)</tt> (but not both).  Analogously, either   
<tt>p</tt> or <tt>r</tt> may be set to <font face="sans-serif">  MPI_UNDEFINED</font>.  
Matching rules for datatypes created by this function are  
analogous to the matching rules for datatypes created by  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>.  
Restrictions on using the returned datatype with the ``external32'' data  
representation are given on page <a href="node416.htm#Node417">Parameterized Datatypes with Specified Precision and Exponent Range 
</a>.  
<P> 
It is erroneous to supply values for <font face="sans-serif"> p</font> and <font face="sans-serif"> r</font> not  
supported by the compiler.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_F90_INTEGER(r, newtype)</TD></TR>  
<TR><TD> IN r</TD><TD>decimal exponent range, i.e., number of decimal digits (integer)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>the requested <font face="sans-serif"> MPI</font> datatype (handle)</TD></TR>  
</TABLE>  
 <tt> int MPI_Type_create_f90_integer(int r, MPI_Datatype *newtype) <br></tt>  
 <tt> MPI_Type_create_f90_integer(r, newtype, ierror) <br> INTEGER, INTENT(IN) :: r <br>TYPE(MPI_Datatype), INTENT(OUT) :: newtype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_CREATE_F90_INTEGER(R, NEWTYPE, IERROR)<br> INTEGER R, NEWTYPE, IERROR <br></tt>  
<P> 
This function returns a predefined <font face="sans-serif"> MPI</font> datatype that matches a <tt> INTEGER</tt> variable  
of <tt>KIND</tt> <tt>selected_int_kind(r)</tt>.   
Matching rules for datatypes created by this function are  
analogous to the matching rules for datatypes created by  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>.  
Restrictions on using the returned datatype with the ``external32'' data  
representation are given on page <a href="node416.htm#Node417">Parameterized Datatypes with Specified Precision and Exponent Range 
</a>.  
 <P> 
It is erroneous to supply a value for <font face="sans-serif"> r</font> that is not  
supported by the compiler.   
<P> 
Example:  
  
<br> 
<pre><tt>   integer       longtype, quadtype 
   integer, parameter :: long = selected_int_kind(15) 
   integer(long) ii(10) 
   real(selected_real_kind(30)) x(10) 
   call MPI_TYPE_CREATE_F90_INTEGER(15, longtype, ierror) 
   call MPI_TYPE_CREATE_F90_REAL(30, MPI_UNDEFINED, quadtype, ierror) 
   ... 
 
   call MPI_SEND(ii, 10, longtype, ...) 
   call MPI_SEND(x,  10, quadtype, ...) 
</tt></pre> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The datatypes returned by the above functions are  
predefined datatypes. They cannot be freed; they do not need to be   
committed; they can be used with predefined reduction operations.   
There are two situations in which they behave differently syntactically,   
but not semantically, from the <font face="sans-serif"> MPI</font> named predefined datatypes.  
<ol> 
 
1. <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> returns special  
combiners that allow a program to retrieve the values of   
<font face="sans-serif"> p</font> and <font face="sans-serif"> r</font>.  
 
<br> 
2. Because the datatypes are not named, they cannot  
be used as compile-time initializers or otherwise  
accessed before a call to one of the <font face="sans-serif"> MPI_TYPE_CREATE_F90_</font><font face="sans-serif"> XXX</font></font>  
routines.  
</ol> 
If a variable was declared specifying a non-default <tt>KIND</tt> value that was  
not obtained with  <tt>selected_real_kind()</tt> or  
<tt>selected_int_kind()</tt>, the only way to obtain a matching  
<font face="sans-serif"> MPI</font> datatype is to use the size-based mechanism described  
in the next section.   
<P> 
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
An application may often repeat a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_</font><font face="sans-serif"> XXX</font></font> with the same combination of   
(<font face="sans-serif"> </font><font face="sans-serif"> XXX</font></font>,<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>).  
The application is not allowed to free the returned predefined, unnamed  
datatype handles. To prevent the creation of a potentially huge amount of handles,   
a high quality   
<font face="sans-serif"> MPI</font> implementation should return the same datatype handle for  
the same   
(<font face="sans-serif"> REAL</font>/<font face="sans-serif"> COMPLEX</font>/ <font face="sans-serif"> INTEGER</font>,<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>)   
combination.    
Checking for the  
combination (<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>) in the preceding call to   
<font face="sans-serif"> MPI_TYPE_CREATE_F90_</font><font face="sans-serif"> XXX</font></font> and  
using a hash table to find formerly generated handles should limit the  
overhead of finding a previously generated datatype with same combination  
of (<font face="sans-serif"> </font><font face="sans-serif"> XXX</font></font>,<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>).  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
The <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL/COMPLEX/INTEGER</font> interface  
needs as input the original range and precision values to be able to   
define useful and compiler-independent   
external (Section <a href="node333.htm#Node333">External Data Representation: ``external32'' 
</a>)  
or user-defined (Section <a href="node334.htm#Node334">User-Defined Data Representations 
</a>) data representations, and in   
order to be able to perform automatic and efficient data conversions in a   
heterogeneous environment.   
 (<em> End of rationale.</em>) <br> 
We now specify how the datatypes described in this section  
behave when used with the ``external32'' external data representation  
described in Section <a href="node333.htm#Node333">External Data Representation: ``external32'' 
</a>.  
<P> 
The external32 representation specifies data formats for integer  
and floating point values. Integer values are represented in two's complement  
big-endian format. Floating point values are represented by one  
of three IEEE formats. These are the IEEE ``Single,'' ``Double,'' and   
``Double Extended'' formats, requiring 4, 8, and 16 bytes of storage,   
respectively.   
For the IEEE ``Double Extended'' formats, <font face="sans-serif"> MPI</font> specifies a  
Format Width of 16 bytes, with 15 exponent bits, bias = +10383,  
112 fraction bits, and an encoding analogous to the ``Double'' format.   
<P> 
The external32 representations of the datatypes returned by   
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL/COMPLEX/INTEGER</font>  
are given by the following rules.   
<br>  
   
For <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>:  
<br> 
<pre><tt>   if      (p &gt; 33) or (r &gt; 4931) then  external32 representation 
                                        is undefined   
   else if (p &gt; 15) or (r &gt;  307) then  external32_size = 16 
   else if (p &gt;  6) or (r &gt;   37) then  external32_size =  8 
   else                                 external32_size =  4 
</tt></pre> 
For <font face="sans-serif"> MPI_TYPE_CREATE_F90_COMPLEX</font>: twice the size  
as for<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>.  
<br>  
For <font face="sans-serif"> MPI_TYPE_CREATE_F90_INTEGER</font>:  
<br> 
<pre><tt>   if      (r &gt; 38) then  external32 representation is undefined 
   else if (r &gt; 18) then  external32_size =  16  
   else if (r &gt;  9) then  external32_size =  8  
   else if (r &gt;  4) then  external32_size =  4 
   else if (r &gt;  2) then  external32_size =  2  
   else                   external32_size =  1  
</tt></pre> 
If the external32 representation of  
a datatype is undefined, the result of using the datatype directly  
or indirectly (i.e., as part of another datatype or through a  
duplicated datatype) in operations that require the external32  
representation is undefined. These operations include <font face="sans-serif"> MPI_PACK_EXTERNAL</font>,  
<font face="sans-serif"> MPI_UNPACK_EXTERNAL</font>, and many <font face="sans-serif"> MPI_FILE</font>  
functions, when the ``external32'' data representation is used.   
The ranges for which the external32 representation is undefined are  
reserved for future standardization.   
 <P> 

<P>
<hr>
<a href="node416.htm#Node416"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node416.htm#Node416"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node416.htm#Node418"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node416.htm#Node416"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node416.htm#Node418"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<b>Previous: </b><a href="node416.htm#Node416"> Additional Support for Fortran Numeric Intrinsic Types</a>
<p>
<hr><h3><span id="Node418">363.2. Support for Size-specific  MPI Datatypes</span></h3>
<a href="node416.htm#Node417"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node416.htm#Node416"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node416.htm#Node419"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node416.htm#Node416"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node416.htm#Node419"> Communication With Size-specific Types</a>
<b>Previous: </b><a href="node416.htm#Node417"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<p>
  
<P> 
<font face="sans-serif"> MPI</font>   
provides named datatypes corresponding to optional Fortran 77  
numeric types that contain explicit byte lengths --- <font face="sans-serif">  MPI_REAL4</font>,   
<font face="sans-serif">  MPI_INTEGER8</font>, etc. This section describes a mechanism  
that generalizes this model to support all Fortran numeric   
intrinsic types.   
<P> 
We assume that for each <b> typeclass</b> (integer, real, complex) and each  
word size there is a unique machine representation.    
For every pair (<b> typeclass</b>, <b> n</b>) supported by a compiler,   
<font face="sans-serif"> MPI</font> must provide a named size-specific datatype.    
The name of this datatype is of the form  
<font face="sans-serif">  MPI_<i>&lt;</i>TYPE<i>&gt;</i>n</font> in C and   
Fortran where <font face="sans-serif">  <i>&lt;</i>TYPE<i>&gt;</i></font> is one of  
<font face="sans-serif">  REAL</font>, <font face="sans-serif">  INTEGER</font> and <font face="sans-serif">  COMPLEX</font>, and <b> n</b> is the length in bytes of the  
machine representation.  This datatype locally matches all variables  
of type (<b> typeclass</b>, <b> n</b>) in Fortran.  The list of names for such types  
includes:  
<br> 
<pre><tt>MPI_REAL4    
MPI_REAL8 
MPI_REAL16    
MPI_COMPLEX8 
MPI_COMPLEX16 
MPI_COMPLEX32 
MPI_INTEGER1 
MPI_INTEGER2    
MPI_INTEGER4 
MPI_INTEGER8    
MPI_INTEGER16    
</tt></pre> 
One   
datatype is required for each representation supported by  
the Fortran compiler.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
Particularly for the longer floating-point types, C and Fortran may  
  use different representations. For example, a Fortran compiler may  
  define a 16-byte <font face="sans-serif">  REAL</font> type with 33 decimal digits of  
  precision while a C compiler may define a 16-byte <font face="sans-serif">  long  
    double</font> type that implements an 80-bit (10 byte) extended  
  precision floating point value. Both of these types are 16 bytes  
  long, but they are not interoperable. Thus, these types are defined  
  by Fortran, even though C may define types of the same length.  
 (<em> End of rationale.</em>) <br> 
To be backward compatible with the interpretation of  
these types in <font face="sans-serif"> MPI-1</font>, we assume that the nonstandard declarations  
<tt> REAL*n</tt>, <tt> INTEGER*n</tt>, always create a variable whose  
representation is of size <b> n</b>.   
These datatypes may also be used for variables declared with   
<tt> KIND=INT8/16/32/64</tt> or <tt> KIND=REAL32/64/128</tt>,   
which are defined in the <tt> ISO_FORTRAN_ENV</tt> intrinsic module.  
Note that the <font face="sans-serif"> MPI</font> datatypes and the <tt> REAL*n</tt>, <tt> INTEGER*n</tt>   
declarations count bytes whereas  
the Fortran <tt> KIND</tt> values count bits.      
All these datatypes are predefined.  
<P> 
The following functions allow a  
user to obtain a size-specific <font face="sans-serif"> MPI</font> datatype for any intrinsic Fortran type.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SIZEOF(x, size)</TD></TR>   
<TR><TD> IN x</TD><TD>a Fortran variable of numeric intrinsic type (choice)</TD></TR>   
<TR><TD> OUT size</TD><TD>size of machine representation of that type (integer)</TD></TR>   
</TABLE>  
<P> 
 <tt> MPI_Sizeof(x, size, ierror) <br> TYPE(*), DIMENSION(..) :: x <br>INTEGER, INTENT(OUT) :: size <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_SIZEOF(X, SIZE, IERROR) <br> &lt;type&gt; X<br>INTEGER SIZE, IERROR  <br></tt>  
<P> 
This function returns the size in bytes of the machine representation of  
the given variable. It is a generic Fortran routine and has a Fortran  
binding only.   
<P> 
 
<br> 
<em> Advice to users.</em>  
 <P> 
This function is similar to the C <em> sizeof</em> operator  
but behaves slightly differently. If given an array argument, it   
returns the size of the base element, not the size of the  
whole array.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
This function is not available in other languages because it would  
not be useful.   
 (<em> End of rationale.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_MATCH_SIZE(typeclass, size, datatype)</TD></TR>  
<TR><TD> IN typeclass</TD><TD>generic type specifier (integer)</TD></TR>  
<TR><TD> IN size</TD><TD>size, in bytes, of representation (integer)</TD></TR>  
<TR><TD> OUT datatype</TD><TD>datatype with correct type, size (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_match_size(int typeclass, int size, MPI_Datatype *datatype) <br></tt>  
 <tt> MPI_Type_match_size(typeclass, size, datatype, ierror) <br> INTEGER, INTENT(IN) :: typeclass, size <br>TYPE(MPI_Datatype), INTENT(OUT) :: datatype <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_MATCH_SIZE(TYPECLASS, SIZE, DATATYPE, IERROR) <br> INTEGER TYPECLASS, SIZE, DATATYPE, IERROR <br></tt>  
<P> 
<font face="sans-serif"> typeclass</font> is one of <font face="sans-serif">  MPI_TYPECLASS_REAL</font>,  
<font face="sans-serif">  MPI_TYPECLASS_INTEGER</font> and   
<font face="sans-serif">  MPI_TYPECLASS_COMPLEX</font>,  
corresponding to the  desired <b> typeclass</b>.  The function returns  
an <font face="sans-serif"> MPI</font> datatype matching a local variable of type (<b> typeclass</b>,  
<b> size</b>).   
<P> 
This function  
returns a reference (handle) to one of the predefined named  
datatypes, not a duplicate. This type cannot be freed.   
<font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font> can be used to obtain a size-specific type that  
matches a Fortran numeric intrinsic type by first calling  
<font face="sans-serif"> MPI_SIZEOF</font> in order to compute the variable size, and then  
calling <font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font> to find a suitable  
datatype.    
In C,   
one can use the C function <font face="sans-serif"> sizeof()</font>, instead of  
<font face="sans-serif"> MPI_SIZEOF</font>.  In addition, for variables of default kind  
the variable's size can be computed by a call to  
<font face="sans-serif"> MPI_TYPE_GET_EXTENT</font>, if the <tt>typeclass</tt> is known.  
It is erroneous to specify a size not supported by the compiler.   
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
This is a convenience function. Without it, it can be tedious to   
find the correct named type. See note to implementors below.   
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
This function could be implemented as a series of tests.  
  
<br> 
<pre><tt>int MPI_Type_match_size(int typeclass, int size, MPI_Datatype *rtype) 
{ 
  switch(typeclass) { 
      case MPI_TYPECLASS_REAL: switch(size) { 
        case 4: *rtype = MPI_REAL4; return MPI_SUCCESS; 
        case 8: *rtype = MPI_REAL8; return MPI_SUCCESS; 
        default: error(...); 
      } 
      case MPI_TYPECLASS_INTEGER: switch(size) { 
         case 4: *rtype = MPI_INTEGER4; return MPI_SUCCESS;          
         case 8: *rtype = MPI_INTEGER8; return MPI_SUCCESS; 
         default: error(...); 
      } 
     ... etc. ...  
   } 
 
   return MPI_SUCCESS; 
}  
</tt></pre> 
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node416.htm#Node417"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node416.htm#Node416"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node416.htm#Node419"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node416.htm#Node416"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node416.htm#Node419"> Communication With Size-specific Types</a>
<b>Previous: </b><a href="node416.htm#Node417"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<p>
<hr><h3><span id="Node419">363.3. Communication With Size-specific Types</span></h3>
<a href="node416.htm#Node418"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node416.htm#Node416"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node420.htm#Node420"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node416.htm#Node416"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node420.htm#Node420"> Problems With Fortran Bindings for <font face="sans-serif"> MPI</font></a>
<b>Previous: </b><a href="node416.htm#Node418"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<p>
The usual type matching rules apply to size-specific datatypes: a  
value sent with datatype   
<font face="sans-serif">  MPI_<i>&lt;</i>TYPE<i>&gt;</i>n</font> can be received with this same datatype on  
another process.  
Most modern computers use 2's complement for integers and  
IEEE format for floating point.  Thus, communication using these  
size-specific datatypes will not entail loss of precision or  
truncation errors.  
<P> 
 
<br> 
<em> Advice to users.</em>  
 <P> 
Care is required when communicating in a heterogeneous  
environment. Consider the following code:  
  
<br> 
<pre><tt>real(selected_real_kind(5)) x(100)    
call MPI_SIZEOF(x, size, ierror)    
call MPI_TYPE_MATCH_SIZE(MPI_TYPECLASS_REAL, size, xtype, ierror)    
if (myrank .eq. 0) then 
    ... initialize x ...       
    call MPI_SEND(x, xtype, 100, 1, ...)    
else if (myrank .eq. 1) then       
    call MPI_RECV(x, xtype, 100, 0, ...) 
endif  
</tt></pre> 
This may not work in a heterogeneous environment  
if the value of <font face="sans-serif"> size</font> is not the same on process 1 and  
process 0. There should be no problem in a homogeneous environment.  
To communicate in a heterogeneous environment, there are at least four  
options. The first is to declare variables of default type and use  
the <font face="sans-serif"> MPI</font> datatypes for these types, e.g., declare a variable of type  
<tt> REAL</tt> and use <font face="sans-serif">  MPI_REAL</font>.  The second is to use   
<tt>selected_real_kind</tt> or <tt>selected_int_kind</tt> and  
with the functions of the previous section.   
The third is to declare a variable   
that is known to be the same size on all architectures (e.g.,   
<tt>selected_real_kind(12)</tt> on almost all compilers will result in an 8-byte  
representation). The fourth is to carefully check  
representation size before communication. This may require explicit  
conversion to a variable of size that can be communicated and  
handshaking between sender and receiver to agree on a size.    
<P> 
Note finally that using the ``external32'' representation for I/O  
requires explicit attention to the representation sizes. Consider the  
following code:   
<P> 
  
<br> 
<pre><tt>real(selected_real_kind(5)) x(100)   
call MPI_SIZEOF(x, size, ierror)    
call MPI_TYPE_MATCH_SIZE(MPI_TYPECLASS_REAL, size, xtype, ierror) 
 
if (myrank .eq. 0) then 
   call MPI_FILE_OPEN(MPI_COMM_SELF, 'foo',                &amp; 
                      MPI_MODE_CREATE+MPI_MODE_WRONLY,     &amp; 
                      MPI_INFO_NULL, fh, ierror) 
   call MPI_FILE_SET_VIEW(fh, zero, xtype, xtype, 'external32',  &amp; 
                          MPI_INFO_NULL, ierror) 
   call MPI_FILE_WRITE(fh, x, 100, xtype, status, ierror) 
   call MPI_FILE_CLOSE(fh, ierror) 
endif 
 
call MPI_BARRIER(MPI_COMM_WORLD, ierror) 
 
if (myrank .eq. 1) then 
   call MPI_FILE_OPEN(MPI_COMM_SELF, 'foo', MPI_MODE_RDONLY,  &amp; 
                 MPI_INFO_NULL, fh, ierror) 
   call MPI_FILE_SET_VIEW(fh, zero, xtype, xtype, 'external32',  &amp; 
                          MPI_INFO_NULL, ierror) 
   call MPI_FILE_WRITE(fh, x, 100, xtype, status, ierror) 
   call MPI_FILE_CLOSE(fh, ierror) 
endif 
 
</tt></pre> 
If processes 0 and 1 are on different machines, this code may not work  
as expected if the <font face="sans-serif"> size</font> is different on the two machines.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node416.htm#Node418"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node416.htm#Node416"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node420.htm#Node420"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node416.htm#Node416"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node420.htm#Node420"> Problems With Fortran Bindings for <font face="sans-serif"> MPI</font></a>
<b>Previous: </b><a href="node416.htm#Node418"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
