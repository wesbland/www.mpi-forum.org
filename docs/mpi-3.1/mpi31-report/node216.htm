<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-inquiry/inquiry.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Memory Allocation</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node216">199. Memory Allocation</span></h1>
<a href="node210.htm#Node215"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node217.htm#Node217"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node217.htm#Node217"> Error Handling</a>
<b>Previous: </b><a href="node210.htm#Node215"> Inquire Processor Name</a>
<p>
  
  
<P> 
In some systems, message-passing and remote-memory-access (<font face="sans-serif"> RMA</font>) operations  
run faster when accessing specially allocated memory (e.g., memory that is  
shared by the other processes in the communicating group on an SMP).  <font face="sans-serif"> MPI</font>  
provides a mechanism for allocating and freeing such special memory.  The use  
of such memory for message-passing or <font face="sans-serif"> RMA</font> is not mandatory, and this memory  
can be used without restrictions as any other dynamically allocated memory.  
However, implementations may restrict the use of some RMA functionality as defined  
in Section <a href="node282.htm#Node282">Lock 
</a>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_ALLOC_MEM(size, info, baseptr)</TD></TR>  
<TR><TD> IN size</TD><TD>size of memory segment in bytes (non-negative integer)</TD></TR>  
<TR><TD> IN info</TD><TD>info argument (handle)</TD></TR>  
<TR><TD> OUT baseptr</TD><TD>pointer to beginning of memory segment allocated</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Alloc_mem(MPI_Aint size, MPI_Info info, void *baseptr) <br></tt>  
<P> 
 <tt> MPI_Alloc_mem(size, info, baseptr, ierror) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size <br>TYPE(MPI_Info), INTENT(IN) :: info <br>TYPE(C_PTR), INTENT(OUT) :: baseptr <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_ALLOC_MEM(SIZE, INFO, BASEPTR, IERROR) <br> INTEGER INFO, IERROR <br>INTEGER(KIND=MPI_ADDRESS_KIND) SIZE, BASEPTR  <br></tt>  
<P> 
  
<P> 
If the Fortran compiler provides <tt> TYPE(C_PTR)</tt>,   
then the following generic interface must be provided in the <tt>mpi</tt>  
module and should be provided in <tt>mpif.h</tt> through overloading,   
i.e., with the same routine name as the  
routine with <tt> INTEGER(KIND=MPI_ADDRESS_KIND) BASEPTR</tt>,   
but with a different specific procedure name:  
<P> 
<br> 
<pre><tt>INTERFACE MPI_ALLOC_MEM 
    SUBROUTINE MPI_ALLOC_MEM(SIZE, INFO, BASEPTR, IERROR) 
        IMPORT ::  MPI_ADDRESS_KIND 
        INTEGER INFO, IERROR 
        INTEGER(KIND=MPI_ADDRESS_KIND) SIZE, BASEPTR 
    END SUBROUTINE 
    SUBROUTINE MPI_ALLOC_MEM_CPTR(SIZE, INFO, BASEPTR, IERROR) 
        USE, INTRINSIC ::  ISO_C_BINDING, ONLY : C_PTR 
        IMPORT ::  MPI_ADDRESS_KIND 
        INTEGER ::  INFO, IERROR 
        INTEGER(KIND=MPI_ADDRESS_KIND) ::  SIZE 
        TYPE(C_PTR) ::  BASEPTR 
    END SUBROUTINE 
END INTERFACE 
</tt></pre> 
The base procedure name of this overloaded function is <font face="sans-serif"> MPI_ALLOC_MEM_CPTR</font>. The implied specific procedure names  
are described in Section <a href="node412.htm#Node412">Interface Specifications, Procedure Names, and the Profiling Interface 
</a>.  
<P> 
The <font face="sans-serif"> info</font> argument can be used to provide  
directives that control the desired location of the allocated memory.  
Such a directive does not affect the semantics of the call. Valid  
<font face="sans-serif"> info</font> values are implementation-dependent; a null directive  
value of <font face="sans-serif"> info = MPI_INFO_NULL</font> is always valid.  
<P> 
The  function <font face="sans-serif"> MPI_ALLOC_MEM</font> may return an error code of class   
<font face="sans-serif"> MPI_ERR_NO_MEM</font>   
to indicate it failed because memory   
is exhausted.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FREE_MEM(base)</TD></TR>  
<TR><TD> IN base</TD><TD>initial address of memory segment allocated by <br>  
<font face="sans-serif"> MPI_ALLOC_MEM</font> (choice)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Free_mem(void *base) <br></tt>  
<P> 
 <tt> MPI_Free_mem(base, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: base <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_FREE_MEM(BASE, IERROR) <br>  &lt;type&gt; BASE(*) <br>INTEGER IERROR <br></tt>  
<P> 
  
<P> 
The function <font face="sans-serif"> MPI_FREE_MEM</font> may return an error code of class  
<font face="sans-serif"> MPI_ERR_BASE</font> to indicate an invalid base argument.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The C bindings of <font face="sans-serif"> MPI_ALLOC_MEM</font> and  
<font face="sans-serif"> MPI_FREE_MEM</font> are similar to the bindings for the  
<tt>malloc</tt> and <tt>free</tt> C library calls:  
a call to  
<font face="sans-serif"> MPI_Alloc_mem(<i>...</i>, &amp;base)</font> should be paired with a call to  
<font face="sans-serif"> MPI_Free_mem(base)</font> (one less   
level of indirection). Both arguments are declared to  
be of same type <font face="sans-serif">  void*</font> so as to facilitate type casting.  
The Fortran binding is consistent with the C bindings:  
the Fortran <font face="sans-serif"> MPI_ALLOC_MEM</font> call returns in   
<font face="sans-serif"> baseptr</font> the <tt> TYPE(C_PTR)</tt> pointer or  
the (integer valued) address   
of the allocated memory.  
The <font face="sans-serif"> base</font> argument of <font face="sans-serif"> MPI_FREE_MEM</font> is a choice  
argument, which passes (a reference to) the variable stored at that location.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
If <font face="sans-serif"> MPI_ALLOC_MEM</font> allocates special memory, then  
a design similar to the design of C <tt>malloc</tt> and <tt>free</tt>  
functions has to  
be used, in order to find out the size of a memory segment, when the segment is freed.  
If no special memory is used,  
<font face="sans-serif"> MPI_ALLOC_MEM</font> simply invokes <tt>malloc</tt>, and <font face="sans-serif"> MPI_FREE_MEM</font> invokes <tt>free</tt>.  
<P> 
A call to <font face="sans-serif"> MPI_ALLOC_MEM</font> can be used in shared memory  
systems to allocate  memory in a shared memory segment.  
 (<em> End of advice to implementors.</em>) <br> 
<br><b> Example</b>  
  
  
  
Example of use of <font face="sans-serif"> MPI_ALLOC_MEM</font>, in Fortran with   
<tt> TYPE(C_PTR)</tt> pointers. We assume 4-byte <font face="sans-serif">  REAL</font>s.  
<br> 
<pre><tt>  USE mpi_f08   !  or  USE mpi      (not guaranteed with INCLUDE 'mpif.h') 
  USE, INTRINSIC :: ISO_C_BINDING 
  TYPE(C_PTR) :: p 
  REAL, DIMENSION(:,:), POINTER :: a            ! no memory is allocated 
  INTEGER, DIMENSION(2) :: shape 
  INTEGER(KIND=MPI_ADDRESS_KIND) :: size 
  shape = (/100,100/) 
  size = 4 * shape(1) * shape(2)                ! assuming 4 bytes per REAL 
  CALL MPI_Alloc_mem(size,MPI_INFO_NULL,p,ierr) ! memory is allocated and 
  CALL C_F_POINTER(p, a, shape) ! intrinsic     ! now accessible via a(i,j) 
  ...                           ! in ISO_C_BINDING 
  a(3,5) = 2.71; 
  ... 
  CALL MPI_Free_mem(a, ierr)                    ! memory is freed 
</tt></pre> 
  
<P> 
<br><b> Example</b>  
  
  
  
Example of use of <font face="sans-serif"> MPI_ALLOC_MEM</font>, in Fortran with   
non-standard <em> Cray-pointers</em>.  
We assume 4-byte <font face="sans-serif">  REAL</font>s, and assume that these pointers  
are address-sized.  
<br> 
<pre><tt>  REAL A 
  POINTER (P, A(100,100))   ! no memory is allocated 
  INTEGER(KIND=MPI_ADDRESS_KIND) SIZE 
  SIZE = 4*100*100  
  CALL MPI_ALLOC_MEM(SIZE, MPI_INFO_NULL, P, IERR) 
  ! memory is allocated 
  ... 
  A(3,5) = 2.71; 
  ... 
  CALL MPI_FREE_MEM(A, IERR) ! memory is freed 
</tt></pre> 
This code is not Fortran 77 or Fortran 90 code.  
Some compilers   
may   
not support this code or need a special option, e.g., the GNU gFortran compiler needs <tt>-fcray-pointer</tt>.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Some compilers map Cray-pointers to address-sized integers,  
some to <tt> TYPE(C_PTR)</tt> pointers (e.g., Cray Fortran, version 7.3.3).  
From the user's viewpoint, this mapping is irrelevant   
because Examples <a href="node216.htm#Node216">Memory Allocation 
</a> should work correctly with  
an <font face="sans-serif"> MPI-3.0</font> (or later) library if Cray-pointers are available.   
 (<em> End of advice to implementors.</em>) <br> 
  
<P> 
<br><b> Example</b>  
  
Same example, in C.  
<br> 
<pre><tt>  float  (* f)[100][100]; 
  /* no memory is allocated */ 
  MPI_Alloc_mem(sizeof(float)*100*100, MPI_INFO_NULL, &amp;f); 
  /* memory allocated */ 
  ... 
  (*f)[5][3] = 2.71; 
  ... 
  MPI_Free_mem(f); 
</tt></pre> 
  
<P> 

<P>
<hr>
<a href="node210.htm#Node215"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node217.htm#Node217"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node217.htm#Node217"> Error Handling</a>
<b>Previous: </b><a href="node210.htm#Node215"> Inquire Processor Name</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
