<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-context/context.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Group Constructors</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node152">145. Group Constructors</span></h2>
<a href="node151.htm#Node151"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node150.htm#Node150"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node153.htm#Node153"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node150.htm#Node150"> Group Management</a>
<b>Next: </b><a href="node153.htm#Node153"> Group Destructors</a>
<b>Previous: </b><a href="node151.htm#Node151"> Group Accessors</a>
<p>
  
Group constructors are used  
to subset and superset existing groups.  
These constructors construct new groups from existing groups.  
These are local operations, and distinct groups may be defined on  
different processes; a process may also define a group that does not  
include itself.  Consistent definitions are required when groups are  
used as arguments in communicator-building functions.  <font face="sans-serif"> MPI</font> does not  
provide a mechanism to build a group from scratch, but only from  
other, previously defined groups.  The base group, upon which all  
other groups are defined, is the group associated with the initial  
communicator <font face="sans-serif"> MPI_COMM_WORLD</font> (accessible through  
the function <font face="sans-serif"> MPI_COMM_GROUP</font>).  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
In what follows, there is no group duplication function analogous to  
<font face="sans-serif"> MPI_COMM_DUP</font>, defined later in this chapter.  There is no need for  
a group duplicator.  A group, once created, can have several references to it  
by making copies of the handle.  The following constructors address the need  
for subsets and supersets of existing groups.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Each group constructor behaves as if it returned a new group object.  
When this new group is a copy of an existing group, then  
one can avoid creating such new objects, using  
a reference-count mechanism.  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_GROUP(comm, group)</TD></TR>  
<TR><TD> IN comm</TD><TD> communicator (handle)</TD></TR>  
<TR><TD> OUT group</TD><TD> group corresponding to <font face="sans-serif"> comm</font> (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_group(MPI_Comm comm, MPI_Group *group) <br></tt>  
<P> 
 <tt> MPI_Comm_group(comm, group, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>TYPE(MPI_Group), INTENT(OUT) :: group <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_COMM_GROUP(COMM, GROUP, IERROR)<br> INTEGER COMM, GROUP, IERROR <br></tt>  
  
<P> 
<font face="sans-serif"> MPI_COMM_GROUP</font> returns in <font face="sans-serif"> group</font> a handle to the  
group of <font face="sans-serif"> comm</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_UNION(group1, group2, newgroup)</TD></TR>  
<TR><TD> IN group1</TD><TD> first group  (handle)</TD></TR>  
<TR><TD> IN group2</TD><TD> second group (handle)</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> union group (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_union(MPI_Group group1, MPI_Group group2, MPI_Group *newgroup) <br></tt>  
<P> 
 <tt> MPI_Group_union(group1, group2, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: group1, group2 <br>TYPE(MPI_Group), INTENT(OUT) :: newgroup <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GROUP_UNION(GROUP1, GROUP2, NEWGROUP, IERROR)<br> INTEGER GROUP1, GROUP2, NEWGROUP, IERROR <br></tt>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_INTERSECTION(group1, group2, newgroup)</TD></TR>  
<TR><TD> IN group1</TD><TD> first group (handle)</TD></TR>  
<TR><TD> IN group2</TD><TD> second group  (handle)</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> intersection group (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_intersection(MPI_Group group1, MPI_Group group2, MPI_Group *newgroup) <br></tt>  
<P> 
 <tt> MPI_Group_intersection(group1, group2, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: group1, group2 <br>TYPE(MPI_Group), INTENT(OUT) :: newgroup <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GROUP_INTERSECTION(GROUP1, GROUP2, NEWGROUP, IERROR)<br> INTEGER GROUP1, GROUP2, NEWGROUP, IERROR <br></tt>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_DIFFERENCE(group1, group2, newgroup)</TD></TR>  
<TR><TD> IN group1</TD><TD> first group (handle)</TD></TR>  
<TR><TD> IN group2</TD><TD> second group (handle)</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> difference group (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_difference(MPI_Group group1, MPI_Group group2, MPI_Group *newgroup) <br></tt>  
<P> 
 <tt> MPI_Group_difference(group1, group2, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: group1, group2 <br>TYPE(MPI_Group), INTENT(OUT) :: newgroup <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GROUP_DIFFERENCE(GROUP1, GROUP2, NEWGROUP, IERROR)<br> INTEGER GROUP1, GROUP2, NEWGROUP, IERROR <br></tt>  
  
<P> 
 The set-like operations are defined as follows:  
<dl> 
 
<dt> 
<b>union</b><dd> 
 All elements of the first group (<font face="sans-serif"> group1</font>), followed by  
all elements of second group (<font face="sans-serif"> group2</font>) not in  
the first group.  
 
<dt> 
<b>intersect</b><dd> 
 all elements of the first group that are also  
in the second group, ordered as in the first group.  
 
<dt> 
<b>difference</b><dd> 
 all elements of the first group that are not  
in the second group, ordered as in the first group.  
</dl> 
<br> 
Note that for these operations the order of processes in the output  
group is determined primarily by order in the first group (if possible)  
and then, if necessary, by order in the second group.  Neither union nor  
intersection are commutative, but both are associative.  
<P> 
The new group can be empty, that is, equal to  
<font face="sans-serif">  MPI_GROUP_EMPTY</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_INCL(group, n, ranks, newgroup)</TD></TR>  
<TR><TD> IN group</TD><TD>  group (handle)</TD></TR>  
<TR><TD> IN n</TD><TD> number of elements in array ranks (and size of <font face="sans-serif"> newgroup</font>) (integer)</TD></TR>  
<TR><TD> IN ranks</TD><TD>  ranks of processes in <font face="sans-serif"> group</font> to appear in <font face="sans-serif"> newgroup</font> (array of integers)</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> new group derived from above, in the order defined by <font face="sans-serif">  ranks</font> (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_incl(MPI_Group group, int n, const int ranks[], MPI_Group *newgroup) <br></tt>  
<P> 
 <tt> MPI_Group_incl(group, n, ranks, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: group <br>INTEGER, INTENT(IN) :: n, ranks(n) <br>TYPE(MPI_Group), INTENT(OUT) :: newgroup <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GROUP_INCL(GROUP, N, RANKS, NEWGROUP, IERROR)<br> INTEGER GROUP, N, RANKS(*), NEWGROUP, IERROR <br></tt>  
  
<P> 
The function <font face="sans-serif"> MPI_GROUP_INCL</font> creates a group  
<font face="sans-serif"> newgroup</font> that consists of the <font face="sans-serif"> n</font> processes in  
<font face="sans-serif"> group</font> with ranks <font face="sans-serif"> ranks[0],<i>...</i>, ranks[n-1]</font>;  
the process with rank <font face="sans-serif"> i</font> in  
<font face="sans-serif"> newgroup</font> is the process with rank <font face="sans-serif"> ranks[i]</font> in  
<font face="sans-serif"> group</font>.  Each of the <font face="sans-serif"> n</font> elements of <font face="sans-serif"> ranks</font> must be a  
valid rank in <font face="sans-serif"> group</font> and all elements must be distinct, or else the  
program is erroneous.  If <font face="sans-serif"> n</font><i>~=~0</i>, then <font face="sans-serif"> newgroup</font> is  
<font face="sans-serif">  MPI_GROUP_EMPTY</font>.  
This function can, for instance, be used to reorder the  
elements of a group.  See also <font face="sans-serif"> MPI_GROUP_COMPARE</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_EXCL(group, n, ranks, newgroup)</TD></TR>  
<TR><TD> IN group</TD><TD> group (handle)</TD></TR>  
<TR><TD> IN n</TD><TD> number of elements in array ranks (integer)</TD></TR>  
<TR><TD> IN ranks</TD><TD> array of integer ranks in <font face="sans-serif"> group</font> not to appear in <font face="sans-serif"> newgroup</font></TD></TR>  
<TR><TD> OUT newgroup</TD><TD> new group derived from above, preserving the order defined by <font face="sans-serif">  group</font> (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_excl(MPI_Group group, int n, const int ranks[], MPI_Group *newgroup) <br></tt>  
<P> 
 <tt> MPI_Group_excl(group, n, ranks, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: group <br>INTEGER, INTENT(IN) :: n, ranks(n) <br>TYPE(MPI_Group), INTENT(OUT) :: newgroup <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GROUP_EXCL(GROUP, N, RANKS, NEWGROUP, IERROR)<br> INTEGER GROUP, N, RANKS(*), NEWGROUP, IERROR <br></tt>  
  
<P> 
The function <font face="sans-serif"> MPI_GROUP_EXCL</font> creates a group of processes  
<font face="sans-serif"> newgroup</font> that is obtained by deleting from <font face="sans-serif"> group</font>  
those processes with ranks  
<font face="sans-serif"> ranks[0] ,<i>...</i> ranks[n-1]</font>.  
The ordering of processes in <font face="sans-serif"> newgroup</font> is identical to the ordering  
in <font face="sans-serif"> group</font>.  
Each of the <font face="sans-serif"> n</font> elements of <font face="sans-serif"> ranks</font> must be a valid  
rank in <font face="sans-serif"> group</font> and all elements must be distinct; otherwise, the  
program is erroneous.  
If <font face="sans-serif"> n</font><i>~=~0</i>, then <font face="sans-serif"> newgroup</font> is identical to <font face="sans-serif"> group</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_RANGE_INCL(group, n, ranges, newgroup)</TD></TR>  
<TR><TD> IN group</TD><TD>  group (handle)</TD></TR>  
<TR><TD> IN n</TD><TD> number of triplets in array <font face="sans-serif"> ranges</font> (integer) </TD></TR>  
<TR><TD> IN ranges</TD><TD> a one-dimensional array of integer triplets, of the  
form (first rank, last rank, stride) indicating ranks in  
<font face="sans-serif"> group</font> of processes to be included in <font face="sans-serif"> newgroup</font></TD></TR>  
<TR><TD> OUT newgroup</TD><TD> new group derived from above, in the  
order defined by <font face="sans-serif"> ranges</font> (handle) </TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_range_incl(MPI_Group group, int n, int ranges[][3], MPI_Group *newgroup) <br></tt>  
<P> 
 <tt> MPI_Group_range_incl(group, n, ranges, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: group <br>INTEGER, INTENT(IN) :: n, ranges(3,n) <br>TYPE(MPI_Group), INTENT(OUT) :: newgroup <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GROUP_RANGE_INCL(GROUP, N, RANGES, NEWGROUP, IERROR)<br> INTEGER GROUP, N, RANGES(3,*), NEWGROUP, IERROR <br></tt>  
  
<P> 
 If <font face="sans-serif"> ranges</font> consists of the triplets  
<p><i> 
(first<SUB>1</SUB> , last<SUB>1</SUB>, stride<SUB>1</SUB>) , ... , (first<SUB>n</SUB>, last<SUB>n</SUB>, stride<SUB>n</SUB>) 
</i><p>  
then <font face="sans-serif"> newgroup</font> consists of the sequence of  
processes in <font face="sans-serif"> group</font> with ranks  
<P><img width=313 height=25 src="img138.gif" alt="Image file"><P>
  
<P><img width=300 height=25 src="img139.gif" alt="Image file"><P>
  
<P> 
Each computed rank must be a valid  
rank in <font face="sans-serif"> group</font> and all computed ranks must be distinct, or else the  
program is erroneous.  
Note that we may have <i>first<SUB>i</SUB> &gt; last<SUB>i</SUB></i>, and <i>stride<SUB>i</SUB></i> may be negative, but  
cannot be zero.  
<P> 
The functionality of this routine is specified to be equivalent to  
expanding the array of ranges to an array of the included ranks and  
passing the resulting array of ranks and other arguments to  
<font face="sans-serif"> MPI_GROUP_INCL</font>.  A call to <font face="sans-serif"> MPI_GROUP_INCL</font> is  
equivalent to a call to  
<font face="sans-serif"> MPI_GROUP_RANGE_INCL</font> with each rank <font face="sans-serif"> i</font>  
in <font face="sans-serif"> ranks</font> replaced by the triplet <font face="sans-serif"> (i,i,1)</font> in the argument <font face="sans-serif"> ranges</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_RANGE_EXCL(group, n, ranges, newgroup)</TD></TR>  
<TR><TD> IN group</TD><TD>  group (handle)</TD></TR>  
<TR><TD> IN n</TD><TD> number of elements in array ranges (integer)</TD></TR>  
<TR><TD> IN ranges</TD><TD> a one-dimensional  
array of integer triplets of the  
form (first rank, last rank, stride), indicating the ranks in  
<font face="sans-serif"> group</font> of processes to be excluded  
from the output group <font face="sans-serif"> newgroup</font>. </TD></TR>  
<TR><TD> OUT newgroup</TD><TD> new group derived from above, preserving the  
order in <font face="sans-serif"> group</font> (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_range_excl(MPI_Group group, int n, int ranges[][3], MPI_Group *newgroup) <br></tt>  
<P> 
 <tt> MPI_Group_range_excl(group, n, ranges, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: group <br>INTEGER, INTENT(IN) :: n, ranges(3,n) <br>TYPE(MPI_Group), INTENT(OUT) :: newgroup <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GROUP_RANGE_EXCL(GROUP, N, RANGES, NEWGROUP, IERROR)<br> INTEGER GROUP, N, RANGES(3,*), NEWGROUP, IERROR <br></tt>  
  
<P> 
 Each computed rank must be a valid  
rank in <font face="sans-serif"> group</font> and all computed ranks must be distinct, or else the  
program is erroneous.  
<P> 
The functionality of this routine is specified to be equivalent to  
expanding the array of ranges to an array of the excluded ranks and  
passing the resulting array of ranks and other arguments to  
<font face="sans-serif"> MPI_GROUP_EXCL</font>. A call to <font face="sans-serif"> MPI_GROUP_EXCL</font> is  
equivalent to a call to <font face="sans-serif"> MPI_GROUP_RANGE_EXCL</font> with each rank  
<font face="sans-serif"> i</font> in <font face="sans-serif"> ranks</font> replaced by the triplet <font face="sans-serif"> (i,i,1)</font> in the argument  
<font face="sans-serif"> ranges</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The range operations do not explicitly enumerate ranks, and therefore  
are more scalable if implemented efficiently.  Hence, we recommend <font face="sans-serif"> MPI</font> programmers  
to use them whenenever possible, as high-quality implementations will  
take advantage of this fact.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The range operations should be implemented, if possible, without  
enumerating the group members,  
in order to obtain better scalability (time and space).  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node151.htm#Node151"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node150.htm#Node150"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node153.htm#Node153"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node150.htm#Node150"> Group Management</a>
<b>Next: </b><a href="node153.htm#Node153"> Group Destructors</a>
<b>Previous: </b><a href="node151.htm#Node151"> Group Accessors</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
