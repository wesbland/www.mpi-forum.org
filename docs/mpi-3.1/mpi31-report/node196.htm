<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-topol/topol.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Topology Inquiry Functions</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node196">184. Topology Inquiry Functions</span></h2>
<a href="node195.htm#Node195"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node191.htm#Node191"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node197.htm#Node197"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node191.htm#Node191"> Topology Constructors</a>
<b>Next: </b><a href="node197.htm#Node197"> Cartesian Shift Coordinates</a>
<b>Previous: </b><a href="node195.htm#Node195"> Distributed Graph Constructor</a>
<p>
  
<P> 
If a topology has been defined with one of the above functions, then the topology  
information can be looked up using inquiry functions. They all are local  
calls.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TOPO_TEST(comm, status)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator (handle)</TD></TR>  
<TR><TD> OUT  status</TD><TD> topology type of communicator <font face="sans-serif"> comm</font> (state)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Topo_test(MPI_Comm comm, int *status) <br></tt>  
<P> 
 <tt> MPI_Topo_test(comm, status, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(OUT) :: status <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TOPO_TEST(COMM, STATUS, IERROR)<br> INTEGER COMM, STATUS, IERROR <br></tt>  
  
<P> 
The function <font face="sans-serif"> MPI_TOPO_TEST</font> returns the type of topology that  
is assigned to a communicator.  
<P> 
The output value <font face="sans-serif"> status</font> is one of the following:  
<P><img width=326 height=48 src="img169.gif" alt="Image file"><P>
<TABLE><TR><TD COLSPAN=2>MPI_GRAPHDIMS_GET(comm, nnodes, nedges)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator for group with graph structure (handle)</TD></TR>  
<TR><TD> OUT  nnodes</TD><TD> number of nodes in graph (integer) (same as number of processes in the group)</TD></TR>  
<TR><TD> OUT  nedges</TD><TD> number of edges in graph (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graphdims_get(MPI_Comm comm, int *nnodes, int *nedges) <br></tt>  
<P> 
 <tt> MPI_Graphdims_get(comm, nnodes, nedges, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(OUT) :: nnodes, nedges <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GRAPHDIMS_GET(COMM, NNODES, NEDGES, IERROR)<br> INTEGER COMM, NNODES, NEDGES, IERROR <br></tt>  
  
<P> 
Functions <font face="sans-serif"> MPI_GRAPHDIMS_GET</font> and  
<font face="sans-serif"> MPI_GRAPH_GET</font> retrieve the graph-topology information  
that was associated with a communicator by  
<font face="sans-serif"> MPI_GRAPH_CREATE</font>.  
<P> 
The information provided by <font face="sans-serif"> MPI_GRAPHDIMS_GET</font> can be used  
to dimension the  
vectors <font face="sans-serif"> index</font> and <font face="sans-serif"> edges</font> correctly for the following call  
to <font face="sans-serif"> MPI_GRAPH_GET</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_GET(comm, maxindex, maxedges, index, edges)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with graph structure (handle)</TD></TR>  
<TR><TD> IN  maxindex</TD><TD> length of vector <font face="sans-serif"> index</font> in the calling program <br>(integer)</TD></TR>  
<TR><TD> IN  maxedges</TD><TD> length of vector <font face="sans-serif"> edges</font> in the calling program <br>(integer)</TD></TR>  
<TR><TD> OUT  index</TD><TD> array of integers containing the graph structure (for details see the definition of <font face="sans-serif"> MPI_GRAPH_CREATE</font>)</TD></TR>  
<TR><TD> OUT  edges</TD><TD> array of integers containing the graph structure </TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graph_get(MPI_Comm comm, int maxindex, int maxedges, int index[], int edges[]) <br></tt>  
<P> 
 <tt> MPI_Graph_get(comm, maxindex, maxedges, index, edges, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(IN) :: maxindex, maxedges <br>INTEGER, INTENT(OUT) :: index(maxindex), edges(maxedges) <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GRAPH_GET(COMM, MAXINDEX, MAXEDGES, INDEX, EDGES, IERROR)<br> INTEGER COMM, MAXINDEX, MAXEDGES, INDEX(*), EDGES(*), IERROR <br></tt>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CARTDIM_GET(comm, ndims)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with Cartesian structure (handle)</TD></TR>  
<TR><TD> OUT  ndims</TD><TD> number of dimensions of the Cartesian structure (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Cartdim_get(MPI_Comm comm, int *ndims) <br></tt>  
<P> 
 <tt> MPI_Cartdim_get(comm, ndims, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(OUT) :: ndims <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_CARTDIM_GET(COMM, NDIMS, IERROR)<br> INTEGER COMM, NDIMS, IERROR <br></tt>  
  
<P> 
The functions <font face="sans-serif"> MPI_CARTDIM_GET</font> and  
<font face="sans-serif"> MPI_CART_GET</font> return the Cartesian topology information that was  
associated with a communicator by  
<font face="sans-serif"> MPI_CART_CREATE</font>.  
If <font face="sans-serif"> comm</font> is associated with a zero-dimensional Cartesian topology,  
<font face="sans-serif"> MPI_CARTDIM_GET</font> returns <font face="sans-serif"> ndims=0</font> and <font face="sans-serif"> MPI_CART_GET</font> will keep  
all output arguments unchanged.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CART_GET(comm, maxdims, dims, periods, coords)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with Cartesian structure (handle)</TD></TR>  
<TR><TD> IN  maxdims</TD><TD> length of vectors <font face="sans-serif"> dims</font>, <font face="sans-serif"> periods</font>, and <font face="sans-serif"> coords</font> in the calling program (integer)</TD></TR>  
<TR><TD> OUT  dims</TD><TD> number of processes for each Cartesian dimension (array of integer)</TD></TR>  
<TR><TD> OUT  periods</TD><TD> periodicity (<font face="sans-serif">  true</font>/<font face="sans-serif">  false</font>) for each Cartesian dimension (array of logical)</TD></TR>  
<TR><TD> OUT  coords</TD><TD> coordinates of calling process in Cartesian structure (array of integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Cart_get(MPI_Comm comm, int maxdims, int dims[], int periods[], int coords[]) <br></tt>  
<P> 
 <tt> MPI_Cart_get(comm, maxdims, dims, periods, coords, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(IN) :: maxdims <br>INTEGER, INTENT(OUT) :: dims(maxdims), coords(maxdims) <br>LOGICAL, INTENT(OUT) :: periods(maxdims) <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_CART_GET(COMM, MAXDIMS, DIMS, PERIODS, COORDS, IERROR)<br> INTEGER COMM, MAXDIMS, DIMS(*), COORDS(*), IERROR <br>LOGICAL PERIODS(*) <br></tt>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CART_RANK(comm, coords, rank)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with Cartesian structure (handle)</TD></TR>  
<TR><TD> IN  coords</TD><TD> integer array (of size <font face="sans-serif"> ndims</font>) specifying the Cartesian coordinates of a process </TD></TR>  
<TR><TD> OUT  rank</TD><TD> rank of specified process (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Cart_rank(MPI_Comm comm, const int coords[], int *rank) <br></tt>  
<P> 
 <tt> MPI_Cart_rank(comm, coords, rank, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(IN) :: coords(*) <br>INTEGER, INTENT(OUT) :: rank <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_CART_RANK(COMM, COORDS, RANK, IERROR)<br> INTEGER COMM, COORDS(*), RANK, IERROR <br></tt>  
  
<P> 
For a process group with Cartesian structure, the function  
<font face="sans-serif"> MPI_CART_RANK</font> translates the logical process coordinates to process  
ranks as they are used by the point-to-point routines.  
<P> 
For dimension <font face="sans-serif"> i</font> with <font face="sans-serif"> periods(i) = true</font>, if the coordinate,  
<font face="sans-serif"> coords(i)</font>, is out of range, that is, <font face="sans-serif"> coords(i) <i>&lt;</i> 0</font> or  
<font face="sans-serif"> coords(i) <img width=6 height=8 src="img170.gif" alt="Image file">
 dims(i)</font>, it is shifted back to the interval  
  
<font face="sans-serif"> 0 <img width=6 height=8 src="img171.gif" alt="Image file">
 coords(i) <i>&lt;</i> dims(i)</font> automatically. Out-of-range  
coordinates are erroneous for non-periodic dimensions.  
 <P> 
If <font face="sans-serif"> comm</font> is associated with a zero-dimensional Cartesian topology,  
<font face="sans-serif"> coords</font> is not significant and 0 is returned in <font face="sans-serif"> rank</font>.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CART_COORDS(comm, rank, maxdims, coords)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with Cartesian structure (handle)</TD></TR>  
<TR><TD> IN  rank</TD><TD> rank of a process within group of <font face="sans-serif"> comm</font> (integer)</TD></TR>  
<TR><TD> IN  maxdims</TD><TD> length of vector  <font face="sans-serif"> coords</font> in the calling program (integer)</TD></TR>  
<TR><TD> OUT  coords</TD><TD> integer array (of size <font face="sans-serif"> ndims</font>) containing the Cartesian coordinates of specified process (array of integers)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Cart_coords(MPI_Comm comm, int rank, int maxdims, int coords[]) <br></tt>  
<P> 
 <tt> MPI_Cart_coords(comm, rank, maxdims, coords, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(IN) :: rank, maxdims <br>INTEGER, INTENT(OUT) :: coords(maxdims) <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_CART_COORDS(COMM, RANK, MAXDIMS, COORDS, IERROR)<br> INTEGER COMM, RANK, MAXDIMS, COORDS(*), IERROR <br></tt>  
  
<P> 
The inverse mapping, rank-to-coordinates translation is provided by  
<font face="sans-serif"> MPI_CART_COORDS</font>.   
If <font face="sans-serif"> comm</font> is associated with a zero-dimensional Cartesian topology,  
<font face="sans-serif"> coords</font> will be unchanged.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_NEIGHBORS_COUNT(comm, rank, nneighbors)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with graph topology (handle)</TD></TR>  
<TR><TD> IN  rank</TD><TD> rank of process in group of <font face="sans-serif"> comm</font> (integer)</TD></TR>  
<TR><TD> OUT  nneighbors</TD><TD> number of neighbors of specified process (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graph_neighbors_count(MPI_Comm comm, int rank, int *nneighbors) <br></tt>  
<P> 
 <tt> MPI_Graph_neighbors_count(comm, rank, nneighbors, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(IN) :: rank <br>INTEGER, INTENT(OUT) :: nneighbors <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GRAPH_NEIGHBORS_COUNT(COMM, RANK, NNEIGHBORS, IERROR)<br> INTEGER COMM, RANK, NNEIGHBORS, IERROR <br></tt>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_NEIGHBORS(comm, rank, maxneighbors, neighbors)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with graph topology (handle)</TD></TR>  
<TR><TD> IN  rank</TD><TD> rank of process in group of <font face="sans-serif"> comm</font> (integer)</TD></TR>  
<TR><TD> IN  maxneighbors</TD><TD> size of array <font face="sans-serif"> neighbors</font> (integer)</TD></TR>  
<TR><TD> OUT  neighbors</TD><TD> ranks of processes that are neighbors to specified process (array of integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graph_neighbors(MPI_Comm comm, int rank, int maxneighbors, int neighbors[]) <br></tt>  
<P> 
 <tt> MPI_Graph_neighbors(comm, rank, maxneighbors, neighbors, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(IN) :: rank, maxneighbors <br>INTEGER, INTENT(OUT) :: neighbors(maxneighbors) <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_GRAPH_NEIGHBORS(COMM, RANK, MAXNEIGHBORS, NEIGHBORS, IERROR)<br> INTEGER COMM, RANK, MAXNEIGHBORS, NEIGHBORS(*), IERROR <br></tt>  
  
<P> 
<font face="sans-serif"> MPI_GRAPH_NEIGHBORS_COUNT</font> and <font face="sans-serif"> MPI_GRAPH_NEIGHBORS</font> provide    
adjacency information for a graph topology.    
The returned count and array of neighbors for the queried rank will   
both include <em> all</em> neighbors and reflect the same edge ordering as   
was specified by the original call to <font face="sans-serif"> MPI_GRAPH_CREATE</font>.   
Specifically, <font face="sans-serif"> MPI_GRAPH_NEIGHBORS_COUNT</font> and   
<font face="sans-serif"> MPI_GRAPH_NEIGHBORS</font> will return values based on the original   
<font face="sans-serif"> index</font> and <font face="sans-serif"> edges</font> array passed to <font face="sans-serif"> MPI_GRAPH_CREATE</font>  
(for the purpose of this example, we assume that <font face="sans-serif"> index[-1]</font> is zero):  
<P> 
<ul> 
 
<li>The number of neighbors (<font face="sans-serif"> nneighbors</font>) returned from  <font face="sans-serif"> MPI_GRAPH_NEIGHBORS_COUNT</font> will be (<font face="sans-serif"> index[rank]</font> -   
  <font face="sans-serif"> index[rank-1]</font>).   
 
<li>The <font face="sans-serif"> neighbors</font> array returned from   
  <font face="sans-serif"> MPI_GRAPH_NEIGHBORS</font> will be <font face="sans-serif"> edges[index[rank-1]]</font>   
  through <font face="sans-serif"> edges[index[rank]-1]</font>.  
</ul> 
<br> 
<br><b> Example</b>  
     
     
  Assume there are four processes 0, 1, 2, 3 with the following   
  adjacency matrix (note that some neighbors are listed multiple times):  
<P> 
<div style="text-align:center">  
  <TABLE><TR><TD ALIGN="CENTER">     
  process</TD><TD ALIGN="LEFT"> neighbors </TD></TR> 
<TR><TD ALIGN="CENTER">  
     
  0</TD><TD ALIGN="LEFT"> 1, 1, 3   </TD></TR> 
<TR><TD ALIGN="CENTER">  
  1</TD><TD ALIGN="LEFT"> 0, 0      </TD></TR> 
<TR><TD ALIGN="CENTER">  
  2</TD><TD ALIGN="LEFT"> 3         </TD></TR> 
<TR><TD ALIGN="CENTER">  
  3</TD><TD ALIGN="LEFT"> 0, 2, 2   </TD></TR> 
<TR><TD ALIGN="CENTER">  
     
  </TD></TR></TABLE> 
</div>  
   <P> 
Thus, the input arguments to <font face="sans-serif"> MPI_GRAPH_CREATE</font> are:  
<div style="text-align:center">  
  <TABLE><TR><TD ALIGN="LEFT">  nnodes =</TD><TD ALIGN="LEFT"> 4 </TD></TR> 
<TR><TD ALIGN="LEFT">  
  index =</TD><TD ALIGN="LEFT"> 3, 5, 6, 9 </TD></TR> 
<TR><TD ALIGN="LEFT">  
  edges =</TD><TD ALIGN="LEFT"> 1, 1, 3, 0, 0, 3, 0, 2, 2   
  </TD></TR></TABLE> 
</div>     
<P> 
 Therefore, calling <font face="sans-serif"> MPI_GRAPH_NEIGHBORS_COUNT</font> and  
  <font face="sans-serif"> MPI_GRAPH_NEIGHBORS</font> for each of the 4 processes will return:  
<P> 
<div style="text-align:center">  
  <TABLE><TR><TD ALIGN="CENTER">  <TD ALIGN="CENTER" COLSPAN=1><b> Input rank</b></TD><TD ALIGN="LEFT"> <TD ALIGN="CENTER" COLSPAN=1><b> Count</b></TD><TD ALIGN="LEFT">   
  <TD ALIGN="CENTER" COLSPAN=1><b> Neighbors</b> </TD></TR> 
<TR><TD ALIGN="CENTER">  
     
  0</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="LEFT"> 1, 1, 3 </TD></TR> 
<TR><TD ALIGN="CENTER">  
  1</TD><TD ALIGN="CENTER"> 2</TD><TD ALIGN="LEFT"> 0, 0 </TD></TR> 
<TR><TD ALIGN="CENTER">  
  2</TD><TD ALIGN="CENTER"> 1</TD><TD ALIGN="LEFT"> 3 </TD></TR> 
<TR><TD ALIGN="CENTER">  
  3</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="LEFT"> 0, 2, 2 </TD></TR> 
<TR><TD ALIGN="CENTER">  
     
  </TD></TR></TABLE> 
</div>  
   
<P> 
<br><b> Example</b>  
  
  
Suppose that <font face="sans-serif"> comm</font> is a communicator with a  
shuffle-exchange topology.   The group has <i>2<SUP>n</SUP></i> members.  
Each process is labeled by <i>a<SUB>1</SUB> , ..., a<SUB>n</SUB></i> with <img width=48 height=11 src="img172.gif" alt="Image file">
, and has three neighbors:  
exchange(<img width=137 height=9 src="img173.gif" alt="Image file">
  
(<img width=44 height=7 src="img174.gif" alt="Image file">
), shuffle(<i>a<SUB>1</SUB> , ..., a<SUB>n</SUB> )= a<SUB>2</SUB> , ..., 
a<SUB>n</SUB>, a<SUB>1</SUB></i>, and unshuffle(<i>a<SUB>1</SUB> , ..., a<SUB>n</SUB> ) = a<SUB>n</SUB> , a<SUB>1</SUB> , ... , a<SUB>n-1</SUB></i>.  
The graph adjacency list is illustrated below for <i>n=3</i>.  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="CENTER">  
<TD ALIGN="CENTER" COLSPAN=2><b> node</b></TD><TD ALIGN="CENTER"><b> exchange</b></TD><TD ALIGN="CENTER"><b> shuffle</b></TD><TD ALIGN="LEFT"><b> unshuffle</b></TD></TR> 
<TR><TD ALIGN="CENTER">  
</TD><TD ALIGN="CENTER"></TD><TD ALIGN="CENTER"> neighbors(1)</TD><TD ALIGN="CENTER"> neighbors(2)</TD><TD ALIGN="CENTER"> neighbors(3) </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="CENTER"> (000)</TD><TD ALIGN="CENTER"> 1</TD><TD ALIGN="CENTER"> 0</TD><TD ALIGN="CENTER"> 0</TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="CENTER"> (001)</TD><TD ALIGN="CENTER"> 0</TD><TD ALIGN="CENTER"> 2</TD><TD ALIGN="CENTER"> 4</TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="CENTER"> (010)</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="CENTER"> 4</TD><TD ALIGN="CENTER"> 1</TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="CENTER"> (011)</TD><TD ALIGN="CENTER"> 2</TD><TD ALIGN="CENTER"> 6</TD><TD ALIGN="CENTER"> 5</TD></TR> 
<TR><TD ALIGN="CENTER">  
4</TD><TD ALIGN="CENTER"> (100)</TD><TD ALIGN="CENTER"> 5</TD><TD ALIGN="CENTER"> 1</TD><TD ALIGN="CENTER"> 2</TD></TR> 
<TR><TD ALIGN="CENTER">  
5</TD><TD ALIGN="CENTER"> (101)</TD><TD ALIGN="CENTER"> 4</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="CENTER"> 6</TD></TR> 
<TR><TD ALIGN="CENTER">  
6</TD><TD ALIGN="CENTER"> (110)</TD><TD ALIGN="CENTER"> 7</TD><TD ALIGN="CENTER"> 5</TD><TD ALIGN="CENTER"> 3</TD></TR> 
<TR><TD ALIGN="CENTER">  
7</TD><TD ALIGN="CENTER"> (111)</TD><TD ALIGN="CENTER"> 6</TD><TD ALIGN="CENTER"> 7</TD><TD ALIGN="CENTER"> 7</TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
</div>  
<P> 
Suppose that the communicator <font face="sans-serif"> comm</font> has this topology associated with it.  
The following code fragment cycles through the three types of neighbors  
and performs an appropriate permutation for each.  
<P> 
<br> 
<pre><tt>!  assume: each process has stored a real number A. 
!  extract neighborhood information 
      CALL MPI_COMM_RANK(comm, myrank, ierr) 
      CALL MPI_GRAPH_NEIGHBORS(comm, myrank, 3, neighbors, ierr) 
!  perform exchange permutation 
      CALL MPI_SENDRECV_REPLACE(A, 1, MPI_REAL, neighbors(1), 0, &amp; 
           neighbors(1), 0, comm, status, ierr) 
!  perform shuffle permutation 
      CALL MPI_SENDRECV_REPLACE(A, 1, MPI_REAL, neighbors(2), 0, &amp; 
           neighbors(3), 0, comm, status, ierr) 
!  perform unshuffle permutation 
      CALL MPI_SENDRECV_REPLACE(A, 1, MPI_REAL, neighbors(3), 0, &amp; 
           neighbors(2), 0, comm, status, ierr) 
</tt></pre> 
  
<P> 
<font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBORS_COUNT</font> and <font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBORS</font>   
provide adjacency information for a distributed graph topology.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_DIST_GRAPH_NEIGHBORS_COUNT(comm, indegree, outdegree, weighted)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with distributed graph topology (handle)</TD></TR>  
<TR><TD> OUT indegree</TD><TD>number of edges into this process (non-negative integer)</TD></TR>  
<TR><TD> OUT outdegree</TD><TD>number of edges out of this process (non-negative integer)</TD></TR>  
<TR><TD> OUT weighted</TD><TD><font face="sans-serif">  false</font> if <font face="sans-serif">  MPI_UNWEIGHTED</font> was supplied during creation,   
  <font face="sans-serif">  true</font> otherwise (logical)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Dist_graph_neighbors_count(MPI_Comm comm, int *indegree, int *outdegree, int *weighted) <br></tt>  
<P> 
 <tt> MPI_Dist_graph_neighbors_count(comm, indegree, outdegree, weighted, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(OUT) :: indegree, outdegree <br>LOGICAL, INTENT(OUT) :: weighted <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_DIST_GRAPH_NEIGHBORS_COUNT(COMM, INDEGREE, OUTDEGREE, WEIGHTED, IERROR)<br> INTEGER COMM, INDEGREE, OUTDEGREE, IERROR <br>LOGICAL WEIGHTED <br></tt>  
<P> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_DIST_GRAPH_NEIGHBORS(comm, maxindegree, sources, sourceweights,   
    maxoutdegree, destinations, destweights)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator with distributed graph topology (handle)</TD></TR>  
<TR><TD> IN maxindegree</TD><TD>size of sources and sourceweights arrays (non-negative integer)</TD></TR>  
<TR><TD> OUT sources</TD><TD>processes for which the calling process is a   
  destination (array of non-negative integers)</TD></TR>  
<TR><TD> OUT sourceweights</TD><TD>weights of the edges into the calling process   
  (array of non-negative integers)</TD></TR>  
<TR><TD> IN maxoutdegree</TD><TD>size of destinations and destweights arrays (non-negative integer)</TD></TR>  
<TR><TD> OUT destinations</TD><TD>processes for which the calling process is a source  
  (array of non-negative integers)</TD></TR>  
<TR><TD> OUT destweights</TD><TD>weights of the edges out of the calling process   
  (array of non-negative integers)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Dist_graph_neighbors(MPI_Comm comm, int maxindegree, int sources[], int sourceweights[], int maxoutdegree, int destinations[], int destweights[]) <br></tt>  
<P> 
 <tt> MPI_Dist_graph_neighbors(comm, maxindegree, sources, sourceweights, maxoutdegree, destinations, destweights, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, INTENT(IN) :: maxindegree, maxoutdegree <br>INTEGER, INTENT(OUT) :: sources(maxindegree),<br>    destinations(maxoutdegree) <br>INTEGER :: sourceweights(*), destweights(*) <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_DIST_GRAPH_NEIGHBORS(COMM, MAXINDEGREE, SOURCES, SOURCEWEIGHTS, MAXOUTDEGREE, DESTINATIONS, DESTWEIGHTS, IERROR)<br> INTEGER COMM, MAXINDEGREE, SOURCES(*), SOURCEWEIGHTS(*), MAXOUTDEGREE, <br>    DESTINATIONS(*), DESTWEIGHTS(*), IERROR <br></tt>  
<P> 
  
<P> 
These calls are local. The number of edges into and out of the process  
returned by <font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBORS_COUNT</font> are the total  
number of such edges given in the call to  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> or  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> (potentially by processes other  
than the calling process in the case of  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font>). Multiply defined edges are all  
counted and returned by <font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBORS</font> in some  
order. If <font face="sans-serif">  MPI_UNWEIGHTED</font> is supplied for  
<font face="sans-serif"> sourceweights</font> or <font face="sans-serif"> destweights</font> or both, or if  
<font face="sans-serif">  MPI_UNWEIGHTED</font> was supplied during the construction of the  
graph then no weight information is returned in that array or those  
arrays.   
If the communicator was created with <font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font>  
then for each rank in <font face="sans-serif"> comm</font>, the order of the values in   
<font face="sans-serif"> sources</font> and <font face="sans-serif"> destinations</font> is identical to the input  
that was used by the process with the same rank in <font face="sans-serif"> comm_old</font>  
in the creation call.  
If the communicator was created with <font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font>  
then the   
only requirement on the order of values in  
<font face="sans-serif"> sources</font> and <font face="sans-serif"> destinations</font> is that two calls to the  
routine with same input argument <font face="sans-serif"> comm</font> will return the same  
sequence of edges. If <font face="sans-serif"> maxindegree</font> or <font face="sans-serif"> maxoutdegree</font> is  
smaller than the numbers returned by  
<font face="sans-serif"> MPI_DIST_GRAPH_NEIGHBOR_COUNT</font>, then only the first part  
of the full list is returned.   
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Since the query calls are defined to be local, each process needs to  
store the list of its neighbors with incoming and outgoing  
edges. Communication is required at the collective  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> call in order to compute the neighbor  
lists for each process from the distributed graph specification.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node195.htm#Node195"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node191.htm#Node191"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node197.htm#Node197"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node191.htm#Node191"> Topology Constructors</a>
<b>Next: </b><a href="node197.htm#Node197"> Cartesian Shift Coordinates</a>
<b>Previous: </b><a href="node195.htm#Node195"> Distributed Graph Constructor</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
