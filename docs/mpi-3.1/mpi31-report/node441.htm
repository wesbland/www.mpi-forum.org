<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Comparison with C</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node441">374. Comparison with C</span></h2>
<a href="node440.htm#Node440"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node442.htm#Node442"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node442.htm#Node442"> Language Interoperability</a>
<b>Previous: </b><a href="node440.htm#Node440"> Permanent Data Movement</a>
<p>
  
 <P> 
In C, subroutines which modify variables that are not in the argument  
list will not cause register optimization problems.  This is because  
taking pointers to storage objects by using the <tt>&amp;</tt> operator and  
later referencing the objects by indirection on the pointer is an integral  
part of the language.  
A C compiler understands the implications,  
so that the problem should not occur, in general.  However,  
some compilers do offer optional aggressive optimization levels which may not  
be safe.  
Problems due to temporary memory modifications can also occur in C.  
As above, the best advice is to avoid the problem:  
use different variables for buffers in nonblocking <font face="sans-serif"> MPI</font> operations  
and computation that is executed while a nonblocking  
operation is pending.   
<P> 
<br><b> Example</b>  
Protecting GPU optimizations with the ASYNCHRONOUS attribute.  
  
  
<br> 
<pre><tt>USE mpi_f08  
REAL :: buf(100,100) 
CALL separated_sections(buf(1:1,1:100), buf(2:100,1:100)) 
END 
 
SUBROUTINE separated_sections(buf_halo, buf_inner) 
REAL, ASYNCHRONOUS :: buf_halo(1:1,1:100) 
REAL :: buf_inner(2:100,1:100) 
REAL :: local_buf(2:100,100)  
 
CALL MPI_Irecv(buf_halo(1,1:100),...req,...) 
local_buf = buf_inner  
DO j=1,100 
  DO i=2,100 
    local_buf(i,j)=.... 
  END DO 
END DO 
buf_inner = local_buf ! buf_halo is not touched!!! 
 
CALL MPI_Wait(req,...) 
</tt></pre> 
  
  
<P> 
<P> 

<P>
<hr>
<a href="node440.htm#Node440"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node407.htm#Node407"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node442.htm#Node442"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node407.htm#Node407"> Fortran Support</a>
<b>Next: </b><a href="node442.htm#Node442"> Language Interoperability</a>
<b>Previous: </b><a href="node440.htm#Node440"> Permanent Data Movement</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
