<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-coll/coll.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>User-Defined Reduction Operations</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node115">110. User-Defined Reduction Operations</span></h2>
<a href="node114.htm#Node114"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node110.htm#Node110"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node115.htm#Node116"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node110.htm#Node110"> Global Reduction Operations</a>
<b>Next: </b><a href="node115.htm#Node116"> Example of User-defined Reduce</a>
<b>Previous: </b><a href="node114.htm#Node114"> MINLOC and MAXLOC</a>
<p>
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_OP_CREATE(user_fn, commute, op)</TD></TR>  
<TR><TD> IN user_fn</TD><TD> user defined function (function)</TD></TR>  
<TR><TD> IN commute</TD><TD> <font face="sans-serif"> true</font> if commutative; <font face="sans-serif"> false</font> otherwise.</TD></TR>  
<TR><TD> OUT op</TD><TD> operation (handle) </TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Op_create(MPI_User_function* user_fn, int commute, MPI_Op* op) <br></tt>  
<P> 
 <tt> MPI_Op_create(user_fn, commute, op, ierror) <br> PROCEDURE(MPI_User_function) :: user_fn <br>LOGICAL, INTENT(IN) :: commute <br>TYPE(MPI_Op), INTENT(OUT) :: op <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_OP_CREATE( USER_FN, COMMUTE, OP, IERROR) <br> EXTERNAL USER_FN<br>LOGICAL COMMUTE <br>INTEGER OP, IERROR <br></tt>  
  
<P> 
<font face="sans-serif"> MPI_OP_CREATE</font> binds a user-defined reduction operation  
to an <font face="sans-serif"> op</font> handle that can subsequently be used in  
<font face="sans-serif"> MPI_REDUCE</font>, <font face="sans-serif"> MPI_ALLREDUCE</font>,  
<font face="sans-serif"> MPI_REDUCE_SCATTER_BLOCK</font>,  
<font face="sans-serif"> MPI_REDUCE_SCATTER</font>,   
<font face="sans-serif"> MPI_SCAN</font>, <font face="sans-serif"> MPI_EXSCAN</font>, all nonblocking variants of  
those (see Section <a href="node126.htm#Node126">Nonblocking Collective Operations 
</a>), and <font face="sans-serif"> MPI_REDUCE_LOCAL</font>.  
The user-defined operation is assumed to be associative.  
If <font face="sans-serif"> commute</font> <i>=</i> <font face="sans-serif"> true</font>, then the operation should be both  
commutative and associative. If  <font face="sans-serif"> commute</font> <i>=</i> <font face="sans-serif"> false</font>,  
then the order of operands is fixed and is defined to be in ascending, process  
rank order, beginning with process zero.  The order of evaluation can be  
changed, taking advantage of the associativity of the operation.  If  
<font face="sans-serif"> commute</font> <i>=</i> <font face="sans-serif"> true</font> then the order of evaluation can be changed,  
taking advantage of commutativity and associativity.  
<P> 
The argument <font face="sans-serif"> user_fn</font> is the user-defined function, which must have the  
following four arguments: <font face="sans-serif"> invec</font>, <font face="sans-serif"> inoutvec</font>, <font face="sans-serif"> len</font>, and  
<font face="sans-serif"> datatype</font>.  
<P> 
The   
ISO C   
prototype for the function is the following.  
<P> 
 <tt> typedef void MPI_User_function(void* invec, void* inoutvec, int *len, MPI_Datatype *datatype); <br></tt>  
<P> 
The Fortran declarations of the user-defined function <font face="sans-serif"> user_fn</font> appear   
below.  
<P> 
 <tt> SUBROUTINE MPI_User_function(invec, inoutvec, len, datatype) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(C_PTR), VALUE :: invec, inoutvec <br>INTEGER :: len <br>TYPE(MPI_Datatype) :: datatype <br></tt>  
 <tt> SUBROUTINE USER_FUNCTION(INVEC, INOUTVEC, LEN, DATATYPE) <br> &lt;type&gt; INVEC(LEN), INOUTVEC(LEN) <br>INTEGER LEN, DATATYPE <br></tt>  
<P> 
The <font face="sans-serif"> datatype</font> argument  
is a handle to the data type that was passed into the call  
to <font face="sans-serif"> MPI_REDUCE</font>.  
The user reduce function should be written such that the following  
holds:  
Let <font face="sans-serif"> u[0], <i>...</i> , u[len-1]</font> be the <font face="sans-serif"> len</font> elements in the  
communication buffer described by the arguments <font face="sans-serif"> invec, len</font>  
and <font face="sans-serif"> datatype</font> when the function is invoked;  
let <font face="sans-serif"> v[0], <i>...</i> , v[len-1]</font> be <font face="sans-serif"> len</font> elements in the  
communication buffer described by the arguments <font face="sans-serif"> inoutvec, len</font>  
and <font face="sans-serif"> datatype</font> when the function is invoked;  
let <font face="sans-serif"> w[0], <i>...</i> , w[len-1]</font> be  <font face="sans-serif"> len</font> elements in the  
communication buffer described by the arguments <font face="sans-serif"> inoutvec, len</font>  
and <font face="sans-serif"> datatype</font> when the function returns;  
then <font face="sans-serif"> w[i] = u[i]<i>&#176;</i>v[i]</font>, for <font face="sans-serif"> i=0 , <i>...</i> , len-1</font>,  
where <i>&#176;</i> is the reduce operation that the function computes.  
<P> 
Informally, we can think of  
<font face="sans-serif"> invec</font> and <font face="sans-serif"> inoutvec</font> as arrays of <font face="sans-serif"> len</font> elements that  
<font face="sans-serif"> user_fn</font>  
is combining.  The result of the reduction overwrites values in  
<font face="sans-serif"> inoutvec</font>, hence the name.  Each invocation of the function results in  
the pointwise evaluation of the reduce operator on <font face="sans-serif"> len</font>  
elements:  
i.e., the function returns in <font face="sans-serif"> inoutvec[i]</font> the value  
<img width=87 height=11 src="img126.gif" alt="Image file">
, for <img width=77 height=8 src="img127.gif" alt="Image file">
,  
where <i>&#176;</i> is the combining operation computed by the function.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The   
<font face="sans-serif"> len</font>   
argument allows  
<font face="sans-serif"> MPI_REDUCE</font> to avoid calling the function for each element  
in the input buffer.  Rather, the system can choose to apply  
the function to chunks of input.  In C, it is passed in as  
a reference for reasons of compatibility with Fortran.  
<P> 
By internally comparing the value of the <font face="sans-serif"> datatype</font> argument to  
known, global handles,  
it is possible to overload the use of a single user-defined function  
for several, different data types.  
 (<em> End of rationale.</em>) <br> 
General datatypes may be passed to the user function.  
However, use of datatypes that are not contiguous is likely to lead to  
inefficiencies.  
<P> 
No <font face="sans-serif"> MPI</font> communication function may be called inside the user function.  
<font face="sans-serif"> MPI_ABORT</font> may be called inside the  
function in case of an error.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Suppose one defines a library of user-defined reduce  
functions that are overloaded: the <font face="sans-serif"> datatype</font> argument is used  
to select the right execution path at each invocation, according to  
the types of the operands.  
The user-defined reduce function cannot ``decode'' the  
<font face="sans-serif"> datatype</font> argument that it is passed, and cannot identify,  
by itself, the correspondence between the datatype handles and the datatype  
they represent.  This correspondence was established when the datatypes  
were created.  Before the library is used, a library initialization  
preamble must be executed.  This preamble code will define the  
datatypes that are used by the library, and store handles to these  
datatypes in global, static variables that are shared by the user code and the  
library code.  
<P> 
The Fortran version of <font face="sans-serif"> MPI_REDUCE</font> will invoke a user-defined reduce  
function using the Fortran calling conventions and will pass a Fortran-type  
datatype argument;  the C version will use C calling convention and the C  
representation of a datatype handle.  Users who plan to mix languages should  
define their reduction functions accordingly.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
We outline below a naive and inefficient implementation of <font face="sans-serif"> MPI_REDUCE</font>  
not   
supporting the ``in place'' option.  
<P> 
<br> 
<pre><tt>      MPI_Comm_size(comm, &amp;groupsize); 
      MPI_Comm_rank(comm, &amp;rank); 
      if (rank &gt; 0) { 
          MPI_Recv(tempbuf, count, datatype, rank-1,...); 
          User_reduce(tempbuf, sendbuf, count, datatype); 
      } 
      if (rank &lt; groupsize-1) { 
          MPI_Send(sendbuf, count, datatype, rank+1, ...); 
      } 
      /* answer now resides in process groupsize-1 ... now send to root 
       */ 
      if (rank == root) { 
          MPI_Irecv(recvbuf, count, datatype, groupsize-1,..., &amp;req); 
      } 
      if (rank == groupsize-1) { 
          MPI_Send(sendbuf, count, datatype, root, ...); 
      } 
      if (rank == root) { 
          MPI_Wait(&amp;req, &amp;status); 
      } 
</tt></pre> 
The reduction computation proceeds, sequentially, from process <tt>0</tt>  
to process   
<tt>groupsize-1</tt>.    
This order is chosen so as to respect  
the order of a possibly non-commutative operator defined by the  
function <tt>User_reduce()</tt>.  
A more efficient implementation is achieved by taking advantage  
of associativity and  
using a logarithmic tree reduction.  Commutativity can be used  
to advantage, for those cases in which the <font face="sans-serif"> commute</font> argument  
to <font face="sans-serif"> MPI_OP_CREATE</font> is true.  Also, the amount of temporary buffer  
required can be reduced, and communication can be pipelined with  
computation, by transferring and reducing the elements in chunks of  
size <tt>len</tt> <i>&lt;</i><tt>count</tt>.  
<P> 
The predefined reduce operations can be implemented as a library of  
user-defined operations.  However, better performance might be  
achieved if <font face="sans-serif"> MPI_REDUCE</font> handles these functions as a special  
case.  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_OP_FREE(op)</TD></TR>  
<TR><TD> INOUT op</TD><TD> operation (handle) </TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Op_free(MPI_Op *op) <br></tt>  
<P> 
 <tt> MPI_Op_free(op, ierror) <br> TYPE(MPI_Op), INTENT(INOUT) :: op <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_OP_FREE(OP, IERROR) <br> INTEGER OP, IERROR <br></tt>  
  
<P> 
Marks a user-defined reduction operation for deallocation and sets  
<font face="sans-serif"> op</font> to <font face="sans-serif">  MPI_OP_NULL</font>.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node114.htm#Node114"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node110.htm#Node110"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node115.htm#Node116"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node110.htm#Node110"> Global Reduction Operations</a>
<b>Next: </b><a href="node115.htm#Node116"> Example of User-defined Reduce</a>
<b>Previous: </b><a href="node114.htm#Node114"> MINLOC and MAXLOC</a>
<p>
<hr><h3><span id="Node116">110.1. Example of User-defined Reduce</span></h3>
<a href="node115.htm#Node115"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node115.htm#Node115"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node117.htm#Node117"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node115.htm#Node115"> User-Defined Reduction Operations</a>
<b>Next: </b><a href="node117.htm#Node117"> All-Reduce</a>
<b>Previous: </b><a href="node115.htm#Node115"> User-Defined Reduction Operations</a>
<p>
  
<P> 
It is time for an example of user-defined reduction.  
The example in this section uses an intracommunicator.  
<P> 
<br><b> Example</b>  
  
Compute the product of an array of complex numbers, in C.  
<br> 
<pre><tt>typedef struct { 
    double real,imag; 
} Complex; 
 
/* the user-defined function 
 */ 
void myProd(void *inP, void *inoutP, int *len, MPI_Datatype *dptr) 
{ 
    int i; 
    Complex c; 
    Complex *in = (Complex *)inP, *inout = (Complex *)inoutP; 
 
    for (i=0; i&lt; *len; ++i) { 
        c.real = inout-&gt;real*in-&gt;real - 
                   inout-&gt;imag*in-&gt;imag; 
        c.imag = inout-&gt;real*in-&gt;imag + 
                   inout-&gt;imag*in-&gt;real; 
        *inout = c; 
        in++; inout++; 
    } 
} 
 
/* and, to call it... 
 */ 
... 
 
    /* each process has an array of 100 Complexes 
     */ 
    Complex a[100], answer[100]; 
    MPI_Op myOp; 
    MPI_Datatype ctype; 
 
    /* explain to MPI how type Complex is defined 
     */ 
    MPI_Type_contiguous(2, MPI_DOUBLE, &amp;ctype); 
    MPI_Type_commit(&amp;ctype); 
    /* create the complex-product user-op 
     */ 
    MPI_Op_create( myProd, 1, &amp;myOp ); 
 
    MPI_Reduce(a, answer, 100, ctype, myOp, root, comm); 
 
    /* At this point, the answer, which consists of 100 Complexes, 
     * resides on process root 
     */ 
</tt></pre> 
  
 <P> 
<br><b> Example</b>  
  
How to use the <tt> mpi_f08</tt> interface of the Fortran <tt> MPI_User_function</tt>.  
<br> 
<pre><tt>  subroutine my_user_function( invec, inoutvec, len, type ) 
    use, intrinsic :: iso_c_binding, only : c_ptr, c_f_pointer 
    use mpi_f08 
    type(c_ptr), value :: invec, inoutvec 
    integer :: len 
    type(MPI_Datatype) :: type 
    real, pointer :: invec_r(:), inoutvec_r(:) 
    if (type%MPI_VAL == MPI_REAL%MPI_VAL) then 
       call c_f_pointer(invec, invec_r, (/ len /) ) 
       call c_f_pointer(inoutvec, inoutvec_r, (/ len /) ) 
       inoutvec_r = invec_r + inoutvec_r 
    end if 
  end subroutine 
</tt></pre> 
  
<P> 

<P>
<hr>
<a href="node115.htm#Node115"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node115.htm#Node115"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node117.htm#Node117"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node115.htm#Node115"> User-Defined Reduction Operations</a>
<b>Next: </b><a href="node117.htm#Node117"> All-Reduce</a>
<b>Previous: </b><a href="node115.htm#Node115"> User-Defined Reduction Operations</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
