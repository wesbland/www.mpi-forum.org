<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-coll/coll.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>All-to-All Scatter/Gather</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node109">104. All-to-All Scatter/Gather</span></h1>
<a href="node108.htm#Node108"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node110.htm#Node110"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node110.htm#Node110"> Global Reduction Operations</a>
<b>Previous: </b><a href="node108.htm#Node108"> Example using <font face="sans-serif"> MPI_ALLGATHER</font></a>
<p>
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_ALLTOALL(sendbuf, sendcount, sendtype, recvbuf,  
recvcount, recvtype, comm)</TD></TR>  
<TR><TD> IN  sendbuf</TD><TD> starting address of send buffer (choice)</TD></TR>  
<TR><TD> IN  sendcount</TD><TD> number of elements sent to each process (non-negative  
integer)</TD></TR>  
<TR><TD> IN  sendtype</TD><TD> data type of send buffer elements (handle)</TD></TR>  
<TR><TD> OUT  recvbuf</TD><TD> address of receive buffer (choice)</TD></TR>  
<TR><TD> IN  recvcount</TD><TD> number of elements received from any process (non-negative  
integer)</TD></TR>  
<TR><TD> IN  recvtype</TD><TD> data type of receive buffer elements (handle)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Alltoall(const void* sendbuf, int sendcount, MPI_Datatype sendtype, void* recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm) <br></tt>  
<P> 
 <tt> MPI_Alltoall(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, comm, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: sendbuf <br>TYPE(*), DIMENSION(..) :: recvbuf <br>INTEGER, INTENT(IN) :: sendcount, recvcount <br>TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype <br>TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_ALLTOALL(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT, RECVTYPE, COMM, IERROR) <br> &lt;type&gt; SENDBUF(*), RECVBUF(*) <br>INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, COMM, IERROR <br></tt>  
<P> 
  
<P> 
<font face="sans-serif"> MPI_ALLTOALL</font> is an extension of <font face="sans-serif"> MPI_ALLGATHER</font> to the case  
where each process sends distinct data to each of the receivers.  
The   
<font face="sans-serif"> j</font>-th   
block sent from process <font face="sans-serif"> i</font> is received by process <font face="sans-serif"> j</font>  
and is placed in the   
<font face="sans-serif"> i</font>-th   
block of <font face="sans-serif"> recvbuf</font>.  
<P> 
The type signature associated with <font face="sans-serif"> sendcount, sendtype</font>,  
at a process must be equal to the type signature associated with  
<font face="sans-serif"> recvcount, recvtype</font> at any other process.  
This implies that the amount of data sent must be equal to the  
amount of data received, pairwise between every pair of processes.  
As usual, however, the type maps may be different.  
<P> 
If <font face="sans-serif"> comm</font> is an intracommunicator,   
the outcome is as if each process executed a send to each  
process (itself included)  
with a call to,  
<P><img width=348 height=10 src="img104.gif" alt="Image file"><P>
 and a receive from every other process  
with a call to,  
<P><img width=345 height=10 src="img105.gif" alt="Image file"><P>
All arguments  
on all processes are significant.  The argument <font face="sans-serif"> comm</font>  
must have identical values on all processes.  
<P> 
The ``in place'' option for intracommunicators is specified by passing  
<font face="sans-serif">  MPI_IN_PLACE</font> to the argument <font face="sans-serif"> sendbuf</font> at <em> all</em> processes.  
In such a case, <font face="sans-serif"> sendcount</font> and <font face="sans-serif"> sendtype</font> are ignored.  
The data to be sent is taken from the <font face="sans-serif"> recvbuf</font> and replaced by the received data.  
Data sent and received must have the same type map as specified by <font face="sans-serif"> recvcount</font> and <font face="sans-serif"> recvtype</font>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
For large <font face="sans-serif"> MPI_ALLTOALL</font> instances,  
allocating both send and receive buffers may consume too much memory.  
The ``in place'' option effectively halves the application memory consumption  
and is useful in situations where the data to be sent will not be used by the  
sending process after the <font face="sans-serif"> MPI_ALLTOALL</font> exchange (e.g., in parallel  
Fast Fourier Transforms).  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Users may opt to use the ``in place'' option in order to conserve memory.  
Quality <font face="sans-serif"> MPI</font> implementations should thus strive to minimize system buffering.  
 (<em> End of advice to implementors.</em>) <br> 
If <font face="sans-serif"> comm</font> is an intercommunicator, then the outcome is as if  
each process in group A sends a message to each process in group B,  
and vice versa.  The <font face="sans-serif"> j</font>-th send buffer of process <font face="sans-serif"> i</font> in group A should  
be consistent with the <font face="sans-serif"> i</font>-th receive buffer of process <font face="sans-serif"> j</font> in group B,  
and vice versa.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
When a complete exchange is executed on an intercommunication domain, then  
the number of data items sent from processes in group A to processes  
in group B need not equal the number of items sent in the reverse  
direction.  In particular, one can have unidirectional communication  
by specifying <font face="sans-serif"> sendcount = 0</font> in the reverse direction.  
 (<em> End of advice to users.</em>) <br> 
<P><img width=361 height=389 src="img106.gif" alt="Image file"><P>
 <tt> int MPI_Alltoallv(const void* sendbuf, const int sendcounts[], const int sdispls[], MPI_Datatype sendtype, void* recvbuf, const int recvcounts[], const int rdispls[], MPI_Datatype recvtype, MPI_Comm comm) <br></tt>  
<P> 
 <tt> MPI_Alltoallv(sendbuf, sendcounts, sdispls, sendtype, recvbuf, recvcounts, rdispls, recvtype, comm, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: sendbuf <br>TYPE(*), DIMENSION(..) :: recvbuf <br>INTEGER, INTENT(IN) :: sendcounts(*), sdispls(*), recvcounts(*), rdispls(*) <br>TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype <br>TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_ALLTOALLV(SENDBUF, SENDCOUNTS, SDISPLS, SENDTYPE, RECVBUF, RECVCOUNTS, RDISPLS, RECVTYPE, COMM, IERROR) <br> &lt;type&gt; SENDBUF(*), RECVBUF(*) <br>INTEGER SENDCOUNTS(*), SDISPLS(*), SENDTYPE, RECVCOUNTS(*), RDISPLS(*), RECVTYPE, COMM, IERROR <br></tt>  
<P> 
  
<P> 
<font face="sans-serif"> MPI_ALLTOALLV</font> adds flexibility to <font face="sans-serif"> MPI_ALLTOALL</font> in that  
the location of data for the send is specified by <font face="sans-serif"> sdispls</font>  
and the location of the placement of the data on the receive side  
is specified by <font face="sans-serif"> rdispls</font>.  
<P> 
If <font face="sans-serif"> comm</font> is an intracommunicator, then  
the   
<font face="sans-serif"> j</font>-th   
block sent from process <font face="sans-serif"> i</font> is received by process <font face="sans-serif"> j</font>  
and is placed in the   
<font face="sans-serif"> i</font>-th   
block of <font face="sans-serif"> recvbuf</font>.  These blocks need not all have the same size.  
<P> 
The type signature associated with  
<font face="sans-serif"> sendcounts[j], sendtype</font> at process <font face="sans-serif"> i</font> must be equal  
to the type signature  
associated with <font face="sans-serif"> recvcounts[i], recvtype</font> at process <font face="sans-serif"> j</font>.  
This implies that the amount of data sent must be equal to the  
amount of data received, pairwise between every pair of processes.  
Distinct type maps between sender and receiver are still allowed.  
<P> 
The outcome is as if each process sent a message to every other process  
with,  
<P><img width=344 height=11 src="img107.gif" alt="Image file"><P>
 and received a message from every other process with  
a call to  
<P><img width=335 height=11 src="img108.gif" alt="Image file"><P>
All arguments  
on all processes are significant.  The argument <font face="sans-serif"> comm</font>  
must have identical values on all processes.  
<P> 
The ``in place'' option for intracommunicators is specified by passing  
<font face="sans-serif">  MPI_IN_PLACE</font> to the argument <font face="sans-serif"> sendbuf</font> at <em> all</em> processes.  
In such a case, <font face="sans-serif"> sendcounts</font>, <font face="sans-serif"> sdispls</font> and <font face="sans-serif"> sendtype</font> are ignored.  
The data to be sent is taken from the <font face="sans-serif"> recvbuf</font> and replaced by the received data.  
Data sent and received must have the same type map as specified by the <font face="sans-serif"> recvcounts</font>  
array and the <font face="sans-serif"> recvtype</font>, and is taken from the locations of the receive buffer  
specified by <font face="sans-serif"> rdispls</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Specifying the ``in place'' option (which must be given on all processes)  
implies that the same amount and type of data is sent and received between  
any two processes in the group of the communicator.  
Different pairs of processes can exchange different amounts of data.  
Users must ensure that <font face="sans-serif"> recvcounts[j]</font> and <font face="sans-serif"> recvtype</font> on process  
<font face="sans-serif"> i</font> match <font face="sans-serif"> recvcounts[i]</font> and <font face="sans-serif"> recvtype</font> on process <font face="sans-serif"> j</font>.  
This symmetric exchange can be useful in applications where the data to be sent will  
not be used by the sending process after the <font face="sans-serif"> MPI_ALLTOALLV</font> exchange.  
 (<em> End of advice to users.</em>) <br> 
If <font face="sans-serif"> comm</font> is an intercommunicator, then the outcome is as if  
each process in group A sends a message to each process in group B,  
and vice versa.  The <font face="sans-serif"> j</font>-th send buffer of process <font face="sans-serif"> i</font> in group A should  
be consistent with the <font face="sans-serif"> i</font>-th receive buffer of process <font face="sans-serif"> j</font> in group B,  
and vice versa.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The definitions of <font face="sans-serif"> MPI_ALLTOALL</font> and <font face="sans-serif"> MPI_ALLTOALLV</font> give as much  
flexibility as one would achieve by specifying <font face="sans-serif"> n</font> independent,  
point-to-point communications, with two exceptions: all messages use the same  
datatype, and messages are scattered from (or gathered to) sequential  
storage.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Although the discussion of collective communication in terms of  
point-to-point operation implies that each message is transferred directly  
from sender to receiver, implementations may use a tree communication  
pattern. Messages can be forwarded by intermediate nodes where they  
are split (for scatter) or concatenated (for gather), if this  
is more efficient.  
 (<em> End of advice to implementors.</em>) <br> 
  
<P> 
<P><img width=361 height=470 src="img109.gif" alt="Image file"><P>
 <tt> int MPI_Alltoallw(const void* sendbuf, const int sendcounts[], const int sdispls[], const MPI_Datatype sendtypes[], void* recvbuf, const int recvcounts[], const int rdispls[], const MPI_Datatype recvtypes[], MPI_Comm comm) <br></tt>  
<P> 
 <tt> MPI_Alltoallw(sendbuf, sendcounts, sdispls, sendtypes, recvbuf, recvcounts, rdispls, recvtypes, comm, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: sendbuf <br>TYPE(*), DIMENSION(..) :: recvbuf <br>INTEGER, INTENT(IN) :: sendcounts(*), sdispls(*), recvcounts(*), rdispls(*) <br>TYPE(MPI_Datatype), INTENT(IN) :: sendtypes(*) <br>TYPE(MPI_Datatype), INTENT(IN) :: recvtypes(*) <br>TYPE(MPI_Comm), INTENT(IN) :: comm <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_ALLTOALLW(SENDBUF, SENDCOUNTS, SDISPLS, SENDTYPES, RECVBUF, RECVCOUNTS, RDISPLS, RECVTYPES, COMM, IERROR) <br> &lt;type&gt; SENDBUF(*), RECVBUF(*)<br>INTEGER SENDCOUNTS(*), SDISPLS(*), SENDTYPES(*), RECVCOUNTS(*), RDISPLS(*), RECVTYPES(*), COMM, IERROR <br></tt>  
<P> 
  
<P> 
<font face="sans-serif"> MPI_ALLTOALLW</font>  
is the most general form of complete exchange.  
Like <font face="sans-serif"> MPI_TYPE_CREATE_STRUCT</font>, the most general type constructor,  
<font face="sans-serif"> MPI_ALLTOALLW</font> allows separate specification of count,  
displacement and datatype.  In addition, to allow maximum flexibility,  
the displacement of blocks within the send and receive buffers is  
specified in bytes.  
<P> 
If <font face="sans-serif"> comm</font> is an intracommunicator, then  
the <font face="sans-serif"> j</font>-th block sent from process <font face="sans-serif"> i</font> is received by process  
<font face="sans-serif"> j</font> and is placed in the <font face="sans-serif"> i</font>-th block of <font face="sans-serif"> recvbuf</font>.  
These blocks need not all have the same size.  
<P> 
The type signature associated with  
<font face="sans-serif"> sendcounts[j], sendtypes[j]</font> at process <font face="sans-serif"> i</font> must be equal  
to the type signature  
associated with <font face="sans-serif"> recvcounts[i], recvtypes[i]</font> at process <font face="sans-serif"> j</font>.  
This implies that the amount of data sent must be equal to the  
amount of data received, pairwise between every pair of processes.  
Distinct type maps between sender and receiver are still allowed.  
<P> 
The outcome is as if each process sent a message to every other process with  
<P><img width=277 height=11 src="img110.gif" alt="Image file"><P>
 and received a message from every other process with a call to  
<P><img width=271 height=11 src="img111.gif" alt="Image file"><P>
All arguments on all processes are significant.  The argument  
<font face="sans-serif"> comm</font> must describe the same communicator on all processes.  
<P> 
Like for <font face="sans-serif"> MPI_ALLTOALLV</font>, the ``in place'' option for intracommunicators  
is specified by passing <font face="sans-serif">  MPI_IN_PLACE</font> to the argument <font face="sans-serif"> sendbuf</font>  
at <em> all</em> processes.  
In such a case, <font face="sans-serif"> sendcounts</font>, <font face="sans-serif"> sdispls</font> and <font face="sans-serif"> sendtypes</font> are ignored.  
The data to be sent is taken from the <font face="sans-serif"> recvbuf</font> and replaced by the received data.  
Data sent and received must have the same type map as specified by the <font face="sans-serif"> recvcounts</font>  
and <font face="sans-serif"> recvtypes</font> arrays, and is taken from the locations of the receive buffer  
specified by <font face="sans-serif"> rdispls</font>.  
<P> 
If <font face="sans-serif"> comm</font> is an intercommunicator, then the outcome is as if  
each process in group A sends a message to each process in group B,  
and vice versa.  The <font face="sans-serif"> j</font>-th send buffer of process <font face="sans-serif"> i</font> in group A should  
be consistent with the <font face="sans-serif"> i</font>-th receive buffer of process <font face="sans-serif"> j</font> in group B,  
and vice versa.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The <font face="sans-serif"> MPI_ALLTOALLW</font> function generalizes several <font face="sans-serif"> MPI</font> functions by  
carefully selecting the input arguments.  For example, by making all but one  
process have <font face="sans-serif"> sendcounts[i] = 0</font>, this achieves an <font face="sans-serif"> MPI_SCATTERW</font>  
function.   
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node108.htm#Node108"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node110.htm#Node110"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node110.htm#Node110"> Global Reduction Operations</a>
<b>Previous: </b><a href="node108.htm#Node108"> Example using <font face="sans-serif"> MPI_ALLGATHER</font></a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
