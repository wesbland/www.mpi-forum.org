<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Derived Datatypes</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node77">72. Derived Datatypes</span></h1>
<a href="node76.htm#Node76"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node78.htm#Node78"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node78.htm#Node78"> Type Constructors with Explicit Addresses</a>
<b>Previous: </b><a href="node76.htm#Node76"> Datatypes</a>
<p>
  
  
<P> 
Up to here, all point to point communications have involved only   
buffers containing a sequence of identical basic datatypes.  
This is too constraining on two accounts.  One often wants to pass  
messages that contain values with different datatypes (e.g., an integer count,  
followed by a sequence of real numbers); and one often wants to send  
noncontiguous data (e.g., a sub-block of a matrix).  One solution is to  
pack noncontiguous data into a contiguous buffer  
at the sender site and unpack it   
at the receiver site.   This has  
the disadvantage of requiring additional memory-to-memory copy operations  
at both sites, even when the communication  
subsystem has scatter-gather capabilities.   Instead, <font face="sans-serif"> MPI</font> provides  
mechanisms to specify more general, mixed, and noncontiguous  
communication buffers. It is up to the implementation to decide  
whether data should be first packed in a contiguous buffer before being  
transmitted, or whether it can be collected directly from where it  
resides.  
<P> 
The general mechanisms provided here allow one to transfer directly,  
without copying, objects of various shapes and sizes.  It is not assumed  
that the <font face="sans-serif"> MPI</font> library is cognizant of the objects declared in the host  
language. Thus, if one wants to transfer a structure, or an array  
section, it will be necessary to provide in <font face="sans-serif"> MPI</font> a definition of a  
communication buffer that mimics the definition of the structure or  
array section in question.  These facilities can be used by library  
designers to define communication functions that can transfer objects  
defined in the host language --- by decoding their definitions as  
available in a symbol table or a dope vector.  Such higher-level  
communication functions are not part of <font face="sans-serif"> MPI</font>.  
<P> 
More general communication buffers are specified by replacing the  
basic datatypes that have been used so far with derived datatypes that  
are constructed from basic datatypes using the constructors described  
in this section.  These methods of constructing derived datatypes can  
be applied recursively.  
<P> 
A <b> general datatype</b> is an opaque object that specifies two  
things:  
<ul> 
 
<li>A sequence of basic datatypes  
 
<li>A sequence of integer (byte) displacements  
</ul> 
<br> 
The displacements are not required to be positive, distinct, or  
in increasing order. Therefore, the order of items need not  
coincide with their order in store, and an item may appear more than  
once.  
We call such a pair of sequences (or sequence of pairs) a <b> type map</b>.  
The sequence of basic datatypes (displacements ignored) is the <b> type  
signature</b> of the datatype.  
<P> 
Let  
<p><i> 
Typemap = { (type<SUB>0</SUB>,disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</i><p>  
be such a type map, where <i>type<SUB>i</SUB></i> are basic types, and  
<i>disp<SUB>i</SUB></i> are  displacements.  
Let  
<p><i> 
Typesig = { type<SUB>0</SUB> , ... , type<SUB>n-1</SUB> } 
</i><p>  
be the associated type signature.  
This type map, together with a base address <font face="sans-serif"> buf</font>,  
specifies a communication buffer: the communication buffer that consists of <i>n</i>  
entries, where the <i>i</i>-th entry is at address <img width=49 height=10 src="img12.gif" alt="Image file">
 and has type <i>type<SUB>i</SUB></i>.  
A message assembled from such a  
communication buffer will consist of <i>n</i> values, of the types defined  
by <i>Typesig</i>.  
 <P> 
Most datatype constructors have replication count or block length arguments.  
Allowed values are non-negative integers. If the value is zero, no elements are  
generated in the type map and there is no effect on datatype bounds or  
extent.   
<P> 
We can use a handle to a general datatype as an argument in a send or  
receive operation, instead of a basic datatype argument.  The  
operation  
<font face="sans-serif"> MPI_SEND(buf, 1, datatype,<i>...</i>)</font> will use the send buffer  
defined by the base address <font face="sans-serif"> buf</font> and the general datatype  
associated with <font face="sans-serif"> datatype</font>; it will generate a message with the type  
signature determined by the <font face="sans-serif"> datatype</font> argument.  
<font face="sans-serif"> MPI_RECV(buf, 1, datatype,<i>...</i>)</font> will use the receive buffer  
defined by the base address <font face="sans-serif"> buf</font> and the general datatype  
associated with <font face="sans-serif"> datatype</font>.  
<P> 
General datatypes can be used in all send and receive  
operations.  We discuss, in Section <a href="node88.htm#Node88">Use of General Datatypes in Communication 
</a>, the  
case where the second argument <font face="sans-serif"> count</font> has value <i>&gt; 1</i>.  
<P> 
The basic datatypes presented in  
Section <a href="node48.htm#Node48">Message Data 
</a>  
are particular cases of a general datatype, and are predefined.  
Thus, <font face="sans-serif"> MPI_INT</font> is a predefined handle to a datatype with type  
map <img width=44 height=11 src="img13.gif" alt="Image file">
, with one entry of type <tt> int</tt> and  
displacement zero.  The other basic datatypes are similar.  
<P> 
The <b> extent</b> of a datatype is defined to  
be the span from the first byte to the last byte occupied by entries in this  
datatype, rounded up to satisfy alignment requirements.  
That is, if  
<p><i> 
Typemap = { (type<SUB>0</SUB>,disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</i><p>  
then  
<P><span id="node77.htm#Equation1"><img width=329 height=54 src="img14.gif" alt="Image file"></span><P>
If <i>type<SUB>j</SUB></i> requires alignment to a byte address that   
is  
a multiple  
of <i>k<SUB>j</SUB></i>,  
then <img width=3 height=5 src="img15.gif" alt="Image file">
 is the least non-negative increment needed to round  
<i>extent(Typemap)</i> to the next multiple of <img width=35 height=10 src="img16.gif" alt="Image file">
.  
In Fortran, it is implementation dependent whether the <font face="sans-serif"> MPI</font> implementation   
computes the alignments <i>k<SUB>j</SUB></i> according to the alignments   
used by the compiler in common blocks, <tt> SEQUENCE</tt> derived types,   
<tt> BIND(C)</tt> derived types,  
or derived types that are neither <tt> SEQUENCE</tt> nor <tt> BIND(C)</tt>.  
The complete definition of <b> extent</b> is given   
by Equation <a href="node77.htm#Equation1">1 
</a> Section <a href="node77.htm#Node77">Derived Datatypes 
</a>.  
<P> 
<br><b> Example</b>  
  
Assume that  
<img width=148 height=11 src="img17.gif" alt="Image file">
<P> 
(a <tt> double</tt> at  
displacement zero, followed by a <tt> char</tt> at displacement eight).  
Assume, furthermore, that  
doubles have to be strictly aligned at addresses that are multiples of eight.  
Then, the extent of this datatype is 16 (9 rounded to the next multiple of 8).  
A datatype that consists of a character immediately followed by a double will  
also have an extent of 16.  
  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The definition of extent is motivated by the assumption that  
the amount of padding added at the end of each structure in an array of  
structures is the least needed to fulfill alignment constraints.  
More explicit control of the extent is provided in  
Section <a href="node83.htm#Node83">Lower-Bound and Upper-Bound Markers 
</a>.  Such explicit control is needed  
in cases where the assumption does not hold, for example, where union types  
are used.  
In Fortran, structures can be expressed with several language features, e.g.,  
common blocks, <tt> SEQUENCE</tt> derived types, or <tt> BIND(C)</tt> derived types. The compiler may  
use different alignments, and therefore, it is recommended to use <font face="sans-serif"> MPI_TYPE_CREATE_RESIZED</font>  
for arrays of structures if an alignment may cause an alignment-gap at the end of   
a structure as described  
in Section <a href="node83.htm#Node83">Lower-Bound and Upper-Bound Markers 
</a> and  
in Section <a href="node425.htm#Node425">Fortran Derived Types 
</a>.  
 (<em> End of rationale.</em>) <br> 
<ul> 
</ul> 

<P>
<hr>
<a href="node76.htm#Node76"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="mpi31-report.htm#Node0"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node78.htm#Node78"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="mpi31-report.htm#Node0">Contents</a>
<b>Next: </b><a href="node78.htm#Node78"> Type Constructors with Explicit Addresses</a>
<b>Previous: </b><a href="node76.htm#Node76"> Datatypes</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
