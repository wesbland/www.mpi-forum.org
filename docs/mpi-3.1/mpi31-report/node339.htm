<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-io/io-2.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>File Consistency</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node339">304. File Consistency</span></h2>
<a href="node338.htm#Node338"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node338.htm#Node338"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node340.htm#Node340"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node338.htm#Node338"> Consistency and Semantics</a>
<b>Next: </b><a href="node340.htm#Node340"> Random Access vs. Sequential Files</a>
<b>Previous: </b><a href="node338.htm#Node338"> Consistency and Semantics</a>
<p>
  
Consistency semantics define the outcome of multiple accesses  
to a single file.  
All file accesses in <font face="sans-serif"> MPI</font> are relative to a specific file handle  
created from a collective open.  
<font face="sans-serif"> MPI</font> provides three levels of consistency:  
sequential consistency among all accesses using a single file handle,  
sequential consistency among all accesses  
using file handles created from a single collective open  
with atomic mode enabled,  
and  
user-imposed consistency among accesses other than the above.  
Sequential consistency means the behavior of a set of operations  
will be as if the operations were performed in some serial order  
consistent with program order; each access appears atomic,  
although the exact ordering of accesses is unspecified.  
User-imposed consistency may be obtained using program order  
and calls to <font face="sans-serif"> MPI_FILE_SYNC</font>.  
<P> 
Let <i>FH<SUB>1</SUB></i> be the set of file handles created  
from one particular collective open of the file <i>FOO</i>,  
and <i>FH<SUB>2</SUB></i> be the set of file handles created  
from a different collective open of <i>FOO</i>.  
Note that nothing restrictive is said about <i>FH<SUB>1</SUB></i> and <i>FH<SUB>2</SUB></i>:  
the sizes of <i>FH<SUB>1</SUB></i> and <i>FH<SUB>2</SUB></i> may be different,  
the groups of processes used for each open may or may not intersect,  
the file handles in <i>FH<SUB>1</SUB></i> may be destroyed  
before those in <i>FH<SUB>2</SUB></i> are created, etc.  
Consider the following three cases:  
a single file handle (e.g., <img width=50 height=10 src="img209.gif" alt="Image file">
),  
two file handles created from a single collective open  
  (e.g., <img width=55 height=10 src="img210.gif" alt="Image file">
 and <img width=54 height=10 src="img211.gif" alt="Image file">
), and  
two file handles from different collective opens  
  (e.g., <img width=50 height=10 src="img212.gif" alt="Image file">
 and <img width=51 height=10 src="img213.gif" alt="Image file">
).  
<P> 
For the purpose of consistency semantics, a matched   
pair (Section <a href="node330.htm#Node330">Split Collective Data Access Routines 
</a>) of split  
collective data access operations (e.g.,  
<font face="sans-serif"> MPI_FILE_READ_ALL_BEGIN</font> and  
<font face="sans-serif"> MPI_FILE_READ_ALL_END</font>) compose a single data access  
operation.  
Similarly, a nonblocking data access routine  
(e.g., <font face="sans-serif"> MPI_FILE_IREAD</font>) and the  
routine which completes the request  
(e.g., <font face="sans-serif"> MPI_WAIT</font>) also compose a single data  
access operation.  
For all cases below, these data access operations   
are subject to the same constraints as blocking data access operations.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
For an <font face="sans-serif"> MPI_FILE_IREAD</font> and <font face="sans-serif"> MPI_WAIT</font> pair,  
the operation begins when <font face="sans-serif"> MPI_FILE_IREAD</font> is called and  
ends when <font face="sans-serif"> MPI_WAIT</font> returns.  
 (<em> End of advice to users.</em>) <br> 
Assume that <i>A<SUB>1</SUB></i> and <i>A<SUB>2</SUB></i> are two data access operations.  
Let <i>D<SUB>1</SUB></i> (<i>D<SUB>2</SUB></i>) be the set of absolute byte displacements  
of every byte accessed in <i>A<SUB>1</SUB></i> (<i>A<SUB>2</SUB></i>).  
The two data accesses <em> overlap</em>  
if <img width=58 height=9 src="img214.gif" alt="Image file">
.  
The two data accesses <em> conflict</em>  
if they overlap and at least one is a write access.  
<P> 
Let <i>SEQ<SUB>fh</SUB></i> be a sequence of file operations on a single file handle,  
bracketed by <font face="sans-serif"> MPI_FILE_SYNC</font>s on that file handle.  
(Both opening and closing a file implicitly perform an <font face="sans-serif"> MPI_FILE_SYNC</font>.)  
<i>SEQ<SUB>fh</SUB></i> is a ``write sequence''  
if any of the data access operations in the sequence are writes  
or if any of the file manipulation operations in the sequence  
change the state of the file  
(e.g., <font face="sans-serif"> MPI_FILE_SET_SIZE</font> or <font face="sans-serif"> MPI_FILE_PREALLOCATE</font>).  
Given two sequences, <i>SEQ<SUB>1</SUB></i> and <i>SEQ<SUB>2</SUB></i>,  
we say they  
are not <em> concurrent</em>  
if one sequence is guaranteed to completely precede the other (temporally).  
<P> 
The requirements for guaranteeing sequential consistency among all  
accesses to a particular file are divided into the three cases given  
below.  If any of these requirements are not met, then the value of  
all data in that file is implementation dependent.  
<P> 
<P> 
Case 1: $fh_1 contained in FH_1$ All operations on <i>fh<SUB>1</SUB></i> are sequentially consistent if atomic mode  
is set.  If nonatomic mode is set, then all operations on <i>fh<SUB>1</SUB></i>   
are sequentially consistent if they are either nonconcurrent, nonconflicting,  
or both.  
<P> 
<P> 
Case 2: $fh_1a contained in FH_1$ and $fh_1b contained in FH_1$ Assume <i>A<SUB>1</SUB></i> is a data access operation using <i>fh<SUB>1a</SUB></i>,  
and    <i>A<SUB>2</SUB></i> is a data access operation using <i>fh<SUB>1b</SUB></i>.  
If for any access <i>A<SUB>1</SUB></i>, there is no access <i>A<SUB>2</SUB></i> that conflicts  
with <i>A<SUB>1</SUB></i>, then <font face="sans-serif"> MPI</font> guarantees sequential consistency.  
<P> 
However, unlike POSIX semantics, the default <font face="sans-serif"> MPI</font> semantics  
for conflicting accesses  
do not guarantee sequential consistency.  
If <i>A<SUB>1</SUB></i> and <i>A<SUB>2</SUB></i> conflict,  
sequential consistency can be guaranteed by either  
enabling atomic mode via the <font face="sans-serif"> MPI_FILE_SET_ATOMICITY</font> routine, or  
meeting the   
condition  
described in Case 3 below.  
<P> 
<P> 
Case 3: $fh_1 contained in FH_1$ and $fh_2 contained in FH_2$ Consider access to a single file using file handles from distinct  
collective opens.  
In order to guarantee sequential consistency, <font face="sans-serif"> MPI_FILE_SYNC</font>  
must be used (both opening and closing a file implicitly perform an  
<font face="sans-serif"> MPI_FILE_SYNC</font>).  
<P> 
Sequential consistency is guaranteed among accesses to a single file if  
for any write sequence <i>SEQ<SUB>1</SUB></i> to the file,  
there is no sequence <i>SEQ<SUB>2</SUB></i> to the file which  
is <em> concurrent</em> with  
<i>SEQ<SUB>1</SUB></i>.  
To guarantee sequential consistency when there are write sequences,  
<font face="sans-serif"> MPI_FILE_SYNC</font> must be used  
together with a mechanism that guarantees nonconcurrency of the sequences.  
<P> 
See the examples in Section <a href="node349.htm#Node349">Examples 
</a> for  
further clarification of some of these consistency semantics.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_SET_ATOMICITY(fh, flag)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN flag</TD><TD><font face="sans-serif">  true</font> to set atomic mode, <font face="sans-serif">  false</font> to set nonatomic mode (logical)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_File_set_atomicity(MPI_File fh, int flag) <br></tt>  
 <tt> MPI_File_set_atomicity(fh, flag, ierror) <br> TYPE(MPI_File), INTENT(IN) :: fh <br>LOGICAL, INTENT(IN) :: flag <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_FILE_SET_ATOMICITY(FH, FLAG, IERROR)<br> INTEGER FH, IERROR<br>LOGICAL FLAG <br></tt>  
  
<P> 
Let <i>FH</i> be the set of file handles created by one collective open.  
The consistency semantics for data access operations using <i>FH</i>  
is set by collectively calling <font face="sans-serif"> MPI_FILE_SET_ATOMICITY</font> on <i>FH</i>.  
<font face="sans-serif"> MPI_FILE_SET_ATOMICITY</font> is collective;  
all processes in the group must pass identical values for  
<font face="sans-serif"> fh</font> and <font face="sans-serif"> flag</font>.  
If <font face="sans-serif"> flag</font> is <font face="sans-serif">  true</font>, atomic mode is set;  
if <font face="sans-serif"> flag</font> is <font face="sans-serif">  false</font>, nonatomic mode is set.  
<P> 
Changing the consistency semantics for an open file only affects new  
data accesses.  All completed data accesses are guaranteed to abide  
by the consistency semantics in effect during their execution.  
Nonblocking data accesses  
and split collective operations  
that  
have not completed  
(e.g., via <font face="sans-serif"> MPI_WAIT</font>) are only guaranteed  
to abide by nonatomic mode consistency semantics.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Since the semantics guaranteed by atomic mode are stronger than  
those guaranteed by nonatomic mode, an implementation is  
free to adhere to the more stringent atomic mode semantics  
for outstanding requests.  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_GET_ATOMICITY(fh, flag)</TD></TR>  
<TR><TD> IN fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT flag</TD><TD><font face="sans-serif">  true</font> if atomic mode, <font face="sans-serif">  false</font> if nonatomic mode (logical)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_File_get_atomicity(MPI_File fh, int *flag) <br></tt>  
 <tt> MPI_File_get_atomicity(fh, flag, ierror) <br> TYPE(MPI_File), INTENT(IN) :: fh <br>LOGICAL, INTENT(OUT) :: flag <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_FILE_GET_ATOMICITY(FH, FLAG, IERROR)<br> INTEGER FH, IERROR<br>LOGICAL FLAG <br></tt>  
  
<P> 
<font face="sans-serif"> MPI_FILE_GET_ATOMICITY</font> returns  
the current consistency semantics for  
data access operations on  
the set of file handles created by one collective open.  
If <font face="sans-serif"> flag</font> is <font face="sans-serif">  true</font>, atomic mode is enabled;  
if <font face="sans-serif"> flag</font> is <font face="sans-serif">  false</font>, nonatomic mode is enabled.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_SYNC(fh)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_File_sync(MPI_File fh) <br></tt>  
 <tt> MPI_File_sync(fh, ierror) <br> TYPE(MPI_File), INTENT(IN) :: fh <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_FILE_SYNC(FH, IERROR)<br> INTEGER FH, IERROR <br></tt>  
  
<P> 
Calling <font face="sans-serif"> MPI_FILE_SYNC</font> with <font face="sans-serif"> fh</font> causes  
all previous writes to <font face="sans-serif"> fh</font> by the calling process   
to be transferred to the storage device.  
If other processes have made updates to the storage device,  
then all such updates become visible to  
subsequent reads of <font face="sans-serif"> fh</font> by the calling process.  
<font face="sans-serif"> MPI_FILE_SYNC</font>   
may be necessary to ensure sequential consistency in certain  
cases (see above).  
<P> 
<font face="sans-serif"> MPI_FILE_SYNC</font> is a collective operation.  
<P> 
The user is responsible for ensuring that all nonblocking requests  
and split collective operations  
on <font face="sans-serif"> fh</font> have been completed before calling  
<font face="sans-serif"> MPI_FILE_SYNC</font> --- otherwise, the call to  
<font face="sans-serif"> MPI_FILE_SYNC</font> is erroneous.  
<P> 

<P>
<hr>
<a href="node338.htm#Node338"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node338.htm#Node338"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node340.htm#Node340"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node338.htm#Node338"> Consistency and Semantics</a>
<b>Next: </b><a href="node340.htm#Node340"> Random Access vs. Sequential Files</a>
<b>Previous: </b><a href="node338.htm#Node338"> Consistency and Semantics</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
