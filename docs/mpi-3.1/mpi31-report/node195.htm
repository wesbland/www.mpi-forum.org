<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-topol/topol.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>Distributed Graph Constructor</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node195">183. Distributed Graph Constructor</span></h2>
<a href="node194.htm#Node194"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node191.htm#Node191"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node196.htm#Node196"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node191.htm#Node191"> Topology Constructors</a>
<b>Next: </b><a href="node196.htm#Node196"> Topology Inquiry Functions</a>
<b>Previous: </b><a href="node194.htm#Node194"> Graph Constructor</a>
<p>
  
  
  
<font face="sans-serif"> MPI_GRAPH_CREATE</font> requires that each process passes the  
full (global) communication graph to the call. This limits the  
scalability of this constructor. With the distributed graph interface,  
the communication graph is specified in a fully distributed  
fashion. Each process specifies only the part of the communication  
graph of which it is aware. Typically, this could be the set of  
processes from which the process will eventually receive or get data,  
or the set of processes to which the process will send or put data, or  
some combination of such edges.  Two different interfaces can be used  
to create a distributed graph  
topology. <font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> creates a  
distributed graph communicator with each process specifying each of its  
incoming and outgoing (adjacent) edges in the logical communication  
graph and thus requires minimal communication during  
creation. <font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font>  
provides full flexibility such that any process can indicate that  
communication will occur between any pair of processes in the graph.  
<P> 
To provide better possibilities for optimization by the <font face="sans-serif"> MPI</font> library,  
the distributed graph constructors permit weighted communication edges  
and take an <font face="sans-serif"> info</font> argument that can further influence process  
reordering or other optimizations performed by the <font face="sans-serif"> MPI</font> library. For  
example, hints can be provided on how edge weights are to be  
interpreted, the quality of the reordering, and/or the time permitted  
for the <font face="sans-serif"> MPI</font> library to process the graph.  
<P> 
<P><img width=402 height=421 src="img167.gif" alt="Image file"><P>
 <tt> int MPI_Dist_graph_create_adjacent(MPI_Comm comm_old, int indegree, const int sources[], const int sourceweights[], int outdegree, const int destinations[], const int destweights[], MPI_Info info, int reorder, MPI_Comm *comm_dist_graph) <br></tt>  
<P> 
 <tt> MPI_Dist_graph_create_adjacent(comm_old, indegree, sources, sourceweights, outdegree, destinations, destweights, info, reorder, comm_dist_graph, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm_old <br>INTEGER, INTENT(IN) :: indegree, sources(indegree), outdegree, <br>    destinations(outdegree) <br>INTEGER, INTENT(IN) :: sourceweights(*), destweights(*) <br>TYPE(MPI_Info), INTENT(IN) :: info <br>LOGICAL, INTENT(IN) :: reorder <br>TYPE(MPI_Comm), INTENT(OUT) :: comm_dist_graph <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_DIST_GRAPH_CREATE_ADJACENT(COMM_OLD, INDEGREE, SOURCES, SOURCEWEIGHTS, OUTDEGREE, DESTINATIONS, DESTWEIGHTS, INFO, REORDER, COMM_DIST_GRAPH, IERROR)<br> INTEGER COMM_OLD, INDEGREE, SOURCES(*), SOURCEWEIGHTS(*), OUTDEGREE, <br>    DESTINATIONS(*), DESTWEIGHTS(*), INFO, COMM_DIST_GRAPH, IERROR <br>LOGICAL REORDER <br></tt>  
<P> 
  
<P> 
  
<P> 
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> returns a handle to a new  
communicator to which the distributed graph topology information is  
attached.  Each process passes all information about its incoming and  
outgoing edges in the virtual distributed graph topology.  The calling  
processes must ensure that each edge of the graph is described in the  
source and in the destination process with the same weights. If there  
are multiple edges for a given <font face="sans-serif"> (source,dest)</font> pair, then the sequence  
of the weights of these edges does not matter. The complete  
communication topology is the combination of all edges shown in the  
<font face="sans-serif"> sources</font> arrays of all processes in <font face="sans-serif"> comm_old</font>, which must be  
identical to the combination of all edges shown in the  
<font face="sans-serif"> destinations</font> arrays.  Source and destination ranks must be  
process ranks of <font face="sans-serif"> comm_old</font>. This allows a fully distributed  
specification of the communication graph.  Isolated processes (i.e.,  
processes with no outgoing or incoming edges, that is, processes that  
have specified <font face="sans-serif"> indegree</font> and <font face="sans-serif"> outdegree</font> as zero and  
thus do not occur as source or destination rank in the graph  
specification) are allowed.  
<P> 
The call creates a new communicator <font face="sans-serif"> comm_dist_graph</font> of  
distributed graph topology type to which topology information has been  
attached. The number of processes in <font face="sans-serif"> comm_dist_graph</font> is  
identical to the number of processes in <font face="sans-serif"> comm_old</font>. The call to  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> is collective.  
<P> 
Weights are specified as non-negative integers and can be used to  
influence the process remapping strategy and other internal <font face="sans-serif"> MPI</font>  
optimizations. For instance, approximate count arguments of later  
communication calls along specific edges could be used as their edge  
weights. Multiplicity of edges can likewise indicate more intense  
communication between pairs of processes. However, the exact meaning  
of edge weights is not specified by the <font face="sans-serif"> MPI</font> standard and is left to  
the implementation. In C or Fortran, an application can supply the  
special value <font face="sans-serif">  MPI_UNWEIGHTED</font> for the weight array to indicate  
that all edges have the same (effectively no) weight. It is erroneous to supply  
<font face="sans-serif">  MPI_UNWEIGHTED</font> for some but not all processes of  
<font face="sans-serif"> comm_old</font>.   
If the graph is weighted but  
<font face="sans-serif"> indegree</font> or <font face="sans-serif"> outdegree</font> is zero, then <font face="sans-serif">  MPI_WEIGHTS_EMPTY</font> or any  
arbitrary array may be passed to <font face="sans-serif"> sourceweights</font> or  
<font face="sans-serif"> destweights</font> respectively. Note that <font face="sans-serif">  MPI_UNWEIGHTED</font> and  
<font face="sans-serif">  MPI_WEIGHTS_EMPTY</font> are not special weight values; rather they  
are special values for the total array argument.  In Fortran,  
<font face="sans-serif">  MPI_UNWEIGHTED</font> and <font face="sans-serif">  MPI_WEIGHTS_EMPTY</font> are objects like  
<font face="sans-serif">  MPI_BOTTOM</font> (not usable for initialization or assignment).  
See Section <a href="node28.htm#Node28">Named Constants 
</a>.  
 
<br> 
<em> Advice to users.</em>  
<P> 
In the case of an empty weights array argument passed while constructing  
a weighted graph, one should not pass <font face="sans-serif">  NULL</font> because the value of  
<font face="sans-serif">  MPI_UNWEIGHTED</font> may be equal to <font face="sans-serif">  NULL</font>. The value of this argument  
would then be indistinguishable from <font face="sans-serif">  MPI_UNWEIGHTED</font> to the  
implementation. In this case <font face="sans-serif">  MPI_WEIGHTS_EMPTY</font> should be used  
instead.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
It is recommended that <font face="sans-serif">  MPI_UNWEIGHTED</font> not be implemented as  
<font face="sans-serif">  NULL</font>.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
To ensure backward compatibility, <font face="sans-serif">  MPI_UNWEIGHTED</font> may still be  
implemented as NULL. See subsec:22to30.  
 (<em> End of rationale.</em>) <br> 
The meaning of the <font face="sans-serif"> info</font> and <font face="sans-serif"> reorder</font> arguments is defined  
in the description of the following routine.  
<P> 
<P><img width=379 height=376 src="img168.gif" alt="Image file"><P>
 <tt> int MPI_Dist_graph_create(MPI_Comm comm_old, int n, const int sources[], const int degrees[], const int destinations[], const int weights[], MPI_Info info, int reorder, MPI_Comm *comm_dist_graph) <br></tt>  
<P> 
 <tt> MPI_Dist_graph_create(comm_old, n, sources, degrees, destinations, weights, info, reorder, comm_dist_graph, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: comm_old <br>INTEGER, INTENT(IN) :: n, sources(n), degrees(n), destinations(*) <br>INTEGER, INTENT(IN) :: weights(*) <br>TYPE(MPI_Info), INTENT(IN) :: info <br>LOGICAL, INTENT(IN) :: reorder <br>TYPE(MPI_Comm), INTENT(OUT) :: comm_dist_graph <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_DIST_GRAPH_CREATE(COMM_OLD, N, SOURCES, DEGREES, DESTINATIONS, WEIGHTS, INFO, REORDER, COMM_DIST_GRAPH, IERROR)<br> INTEGER COMM_OLD, N, SOURCES(*), DEGREES(*), DESTINATIONS(*),<br>    WEIGHTS(*), INFO, COMM_DIST_GRAPH, IERROR <br>LOGICAL REORDER <br></tt>  
<P> 
  
<P> 
  
<P> 
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> returns a handle to a new  
communicator to which the distributed graph topology information is  
attached. Concretely, each process calls the constructor with a set of  
directed <font face="sans-serif"> (source,destination)</font> communication edges as  
described below. Every process passes an array of <font face="sans-serif"> n</font> source  
nodes in the <font face="sans-serif"> sources</font> array.  For each source node, a  
non-negative number of destination nodes is specified in the  
<font face="sans-serif"> degrees</font> array. The destination nodes are stored in the  
corresponding consecutive segment of the <font face="sans-serif"> destinations</font>  
array. More precisely, if the <font face="sans-serif"> i</font>-th node in <font face="sans-serif"> sources</font> is  
<font face="sans-serif"> s</font>, this specifies <font face="sans-serif"> degrees[i]</font> edges <font face="sans-serif"> (s,d)</font>  
with <font face="sans-serif"> d</font> of the <font face="sans-serif"> j</font>-th such edge stored in  
<font face="sans-serif"> destinations[degrees[0]+<i>...</i>+degrees[i-1]+j]</font>. The weight of  
this edge is stored in  
<font face="sans-serif"> weights[degrees[0]+<i>...</i>+degrees[i-1]+j]</font>.  Both the  
<font face="sans-serif"> sources</font> and the <font face="sans-serif"> destinations</font> arrays may contain the  
same node more than once, and the order in which nodes are listed as  
destinations or sources is not significant. Similarly, different  
processes may specify edges with the same source and destination  
nodes.  Source and destination nodes must be process ranks of  
<font face="sans-serif"> comm_old</font>. Different processes may specify different numbers  
of source and destination nodes, as well as different source to  
destination edges.  This allows a fully distributed specification of  
the communication graph.  Isolated processes (i.e., processes with no  
outgoing or incoming edges, that is, processes that do not occur as  
source or destination node in the graph specification) are allowed.  
<P> 
The call creates a new communicator <font face="sans-serif"> comm_dist_graph</font> of  
distributed graph topology type to which topology information has been  
attached. The number of processes in <font face="sans-serif"> comm_dist_graph</font> is  
identical to the number of processes in <font face="sans-serif"> comm_old</font>. The call to  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> is collective.  
<P> 
If <font face="sans-serif"> reorder = false</font>, all processes will have the same rank in  
<font face="sans-serif"> comm_dist_graph</font> as in <font face="sans-serif"> comm_old</font>. If  
<font face="sans-serif"> reorder = true</font> then the <font face="sans-serif"> MPI</font> library is free to remap to  
other processes (of <font face="sans-serif"> comm_old</font>) in order to improve  
communication on the edges of the communication graph. The weight  
associated with each edge is a hint to the <font face="sans-serif"> MPI</font> library about the  
amount or intensity of communication on that edge, and may be used to  
compute a ``best'' reordering.  
<P> 
Weights are specified as non-negative integers and can be used to  
influence the process remapping strategy and other internal <font face="sans-serif"> MPI</font>  
optimizations. For instance, approximate count arguments of later  
communication calls along specific edges could be used as their edge  
weights. Multiplicity of edges can likewise indicate more intense  
communication between pairs of processes. However, the exact meaning  
of edge weights is not specified by the <font face="sans-serif"> MPI</font> standard and is left to  
the implementation. In C or Fortran, an application can supply the  
special value <font face="sans-serif">  MPI_UNWEIGHTED</font> for the weight array to indicate  
that all edges have the same (effectively no) weight. It is erroneous to supply <font face="sans-serif">  MPI_UNWEIGHTED</font> for some but not all processes of  
<font face="sans-serif"> comm_old</font>.   
If the graph is weighted but <font face="sans-serif"> n</font> = 0, then  
<font face="sans-serif">  MPI_WEIGHTS_EMPTY</font> or any arbitrary array may be passed to  
weights. Note that <font face="sans-serif">  MPI_UNWEIGHTED</font> and  
<font face="sans-serif">  MPI_WEIGHTS_EMPTY</font> are not special weight values; rather  
they are special values for the total array argument. In Fortran,  
<font face="sans-serif">  MPI_UNWEIGHTED</font> and <font face="sans-serif">  MPI_WEIGHTS_EMPTY</font> are objects like  
<font face="sans-serif">  MPI_BOTTOM</font> (not usable for initialization or assignment).  
See Section <a href="node28.htm#Node28">Named Constants 
</a>.  
 
<br> 
<em> Advice to users.</em>  
<P> 
In the case of an empty weights array argument passed while constructing  
a weighted graph, one should not pass <font face="sans-serif">  NULL</font> because the value of  
<font face="sans-serif">  MPI_UNWEIGHTED</font> may be equal to <font face="sans-serif">  NULL</font>. The value of this argument  
would then be indistinguishable from <font face="sans-serif">  MPI_UNWEIGHTED</font> to the  
implementation. <font face="sans-serif">  MPI_WEIGHTS_EMPTY</font> should be used  
instead.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
It is recommended that <font face="sans-serif">  MPI_UNWEIGHTED</font> not be implemented as  
<font face="sans-serif">  NULL</font>.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
To ensure backward compatibility, <font face="sans-serif">  MPI_UNWEIGHTED</font> may still be  
implemented as NULL. See subsec:22to30.  
 (<em> End of rationale.</em>) <br> 
The meaning of the <font face="sans-serif"> weights</font> argument can be influenced by the  
<font face="sans-serif"> info</font> argument. Info arguments can be used to guide the  
mapping; possible options include minimizing the maximum number of  
edges between processes on different SMP nodes, or minimizing the sum  
of all such edges.  An <font face="sans-serif"> MPI</font> implementation is not obliged to follow  
specific hints, and it is valid for an <font face="sans-serif"> MPI</font> implementation not to do  
any reordering.  An <font face="sans-serif"> MPI</font> implementation may specify more <font face="sans-serif"> info</font>  
key-value pairs. All processes must specify the same set of key-value  
<font face="sans-serif"> info</font> pairs.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
<font face="sans-serif"> MPI</font> implementations must document any additionally supported key-value  
<font face="sans-serif"> info</font> pairs. <font face="sans-serif">  MPI_INFO_NULL</font> is always valid, and may  
indicate the default creation of the distributed graph topology to the  
<font face="sans-serif"> MPI</font> library.  
<P> 
An implementation does not explicitly need to construct the topology  
from its distributed parts. However, all processes can construct the  
full topology from the distributed specification and use this in a  
call to <font face="sans-serif"> MPI_GRAPH_CREATE</font> to create the topology.  This may serve  
as a reference implementation of the functionality, and may be  
acceptable for small communicators. However, a scalable high-quality  
implementation would save the topology graph in a distributed way.  
 (<em> End of advice to implementors.</em>) <br> 
<br><b> Example</b>  
  
As for Example <a href="node194.htm#Node194">Graph Constructor 
</a>,assume there are four processes 0, 1, 2, 3 with the following adjacency matrix and   
unit edge weights:  
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT"> neighbors </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT"> 1, 3      </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT"> 0         </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT"> 3         </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT"> 0, 2      </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
</div>  
With <font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font>, this graph could be  
constructed in many different ways. One way would be that each process  
specifies its outgoing edges. The arguments per process would be:  
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT">  <font face="sans-serif"> n</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> sources</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> degrees</font></TD><TD ALIGN="LEFT">   
<font face="sans-serif"> destinations</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> weights</font> </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 0</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 1,3</TD><TD ALIGN="LEFT"> 1,1     </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 0</TD><TD ALIGN="LEFT"> 1       </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 3</TD><TD ALIGN="LEFT"> 1       </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 3</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 0,2</TD><TD ALIGN="LEFT"> 1,1     </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
</div>  
<P> 
Another way would be to pass the whole graph on process 0, which could be  
done with the following arguments per process:  
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT">  <font face="sans-serif"> n</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> sources</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> degrees</font></TD><TD ALIGN="LEFT">   
<font face="sans-serif"> destinations</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> weights</font>     </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT">  4</TD><TD ALIGN="LEFT"> 0,1,2,3</TD><TD ALIGN="LEFT"> 2,1,1,2</TD><TD ALIGN="LEFT"> 1,3,0,3,0,2</TD><TD ALIGN="LEFT"> 1,1,1,1,1,1 </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT">  0</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -           </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT">  0</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -           </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT">  0</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT">             </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
</div>  
<P> 
In both cases above, the application could supply <font face="sans-serif">  MPI_UNWEIGHTED</font>  
instead of explicitly providing identical weights.  
<P> 
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> could be used to specify  
this graph using the following arguments:  
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT">  <font face="sans-serif"> indegree</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> sources</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> sourceweights</font></TD><TD ALIGN="LEFT">   
<font face="sans-serif"> outdegree</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> destinations</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> destweights</font>    </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT">  2</TD><TD ALIGN="LEFT"> 1,3</TD><TD ALIGN="LEFT"> 1,1</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 1,3</TD><TD ALIGN="LEFT"> 1,1            </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 0</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 0</TD><TD ALIGN="LEFT"> 1              </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 3</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 3</TD><TD ALIGN="LEFT"> 1              </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT">  2</TD><TD ALIGN="LEFT"> 0,2</TD><TD ALIGN="LEFT"> 1,1</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 0,2</TD><TD ALIGN="LEFT"> 1,1            </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
</div>  
  
<P> 
<br><b> Example</b>  
  
A two-dimensional PxQ torus where all processes communicate along the  
dimensions and along the diagonal edges. This cannot be modeled with  
Cartesian topologies, but can easily be captured with  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> as shown in the following code. In this  
example, the communication along the dimensions is twice as heavy as  
the communication along the diagonals:  
<P> 
<br> 
<pre><tt>/* 
Input:     dimensions P, Q 
Condition: number of processes equal to P*Q; otherwise only  
           ranks smaller than P*Q participate 
*/ 
int rank, x, y; 
int sources[1], degrees[1]; 
int destinations[8], weights[8]; 
MPI_Comm comm_dist_graph; 
 
MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); 
 
/* get x and y dimension */ 
y=rank/P; x=rank%P; 
 
/* get my communication partners along x dimension */ 
destinations[0] = P*y+(x+1)%P; weights[0] = 2; 
destinations[1] = P*y+(P+x-1)%P; weights[1] = 2; 
 
/* get my communication partners along y dimension */ 
destinations[2] = P*((y+1)%Q)+x; weights[2] = 2; 
destinations[3] = P*((Q+y-1)%Q)+x; weights[3] = 2; 
 
/* get my communication partners along diagonals */ 
destinations[4] = P*((y+1)%Q)+(x+1)%P; weights[4] = 1; 
destinations[5] = P*((Q+y-1)%Q)+(x+1)%P; weights[5] = 1; 
destinations[6] = P*((y+1)%Q)+(P+x-1)%P; weights[6] = 1; 
destinations[7] = P*((Q+y-1)%Q)+(P+x-1)%P; weights[7] = 1; 
 
sources[0] = rank; 
degrees[0] = 8; 
MPI_Dist_graph_create(MPI_COMM_WORLD, 1, sources, degrees, destinations, 
                      weights, MPI_INFO_NULL, 1, &amp;comm_dist_graph); 
</tt></pre> 
  
<P> 

<P>
<hr>
<a href="node194.htm#Node194"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node191.htm#Node191"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node196.htm#Node196"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node191.htm#Node191"> Topology Constructors</a>
<b>Next: </b><a href="node196.htm#Node196"> Topology Inquiry Functions</a>
<b>Previous: </b><a href="node194.htm#Node194"> Graph Constructor</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
