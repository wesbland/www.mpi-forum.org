<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml -default -basedef mpi3defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi3-forum-tail.htm -Wnoredef -o mpi31-report.tex mpi-report.tex 
-->
<title>True Extent of Datatypes</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node85">80. True Extent of Datatypes</span></h2>
<a href="node84.htm#Node84"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node77.htm#Node77"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node86.htm#Node86"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node77.htm#Node77"> Derived Datatypes</a>
<b>Next: </b><a href="node86.htm#Node86"> Commit and Free</a>
<b>Previous: </b><a href="node84.htm#Node84"> Extent and Bounds of Datatypes</a>
<p>
  
  
  
<P> 
Suppose we implement gather   
(see also Section <a href="node103.htm#Node103">Gather 
</a>)   
as a spanning tree implemented on top of  
point-to-point routines.  Since the receive buffer is only valid on the  
root process, one will need to allocate some temporary space for  
receiving data on intermediate nodes.  However, the datatype extent  
cannot be used as an estimate of the amount of space that needs to be  
allocated, if the user has modified the extent, for example by  
using <font face="sans-serif"> MPI_TYPE_CREATE_RESIZED</font>.  
The functions <font face="sans-serif"> MPI_TYPE_GET_TRUE_EXTENT</font> and <font face="sans-serif"> MPI_TYPE_GET_TRUE_EXTENT_X</font> are  provided which return  
the true extent of the datatype.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_GET_TRUE_EXTENT(datatype, true_lb, true_extent)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype to get information on (handle)</TD></TR>  
<TR><TD> OUT true_lb</TD><TD>true lower bound of datatype (integer)</TD></TR>  
<TR><TD> OUT true_extent</TD><TD>true size of datatype (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_get_true_extent(MPI_Datatype datatype, MPI_Aint *true_lb, MPI_Aint *true_extent) <br></tt>  
<P> 
 <tt> MPI_Type_get_true_extent(datatype, true_lb, true_extent, ierror) <br> TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: true_lb, true_extent <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_GET_TRUE_EXTENT(DATATYPE, TRUE_LB, TRUE_EXTENT, IERROR)<br> INTEGER DATATYPE,  IERROR<br>INTEGER(KIND=MPI_ADDRESS_KIND) TRUE_LB, TRUE_EXTENT <br></tt>  
<P> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_GET_TRUE_EXTENT_X(datatype, true_lb, true_extent)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype to get information on (handle)</TD></TR>  
<TR><TD> OUT true_lb</TD><TD>true lower bound of datatype (integer)</TD></TR>  
<TR><TD> OUT true_extent</TD><TD>true size of datatype (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_get_true_extent_x(MPI_Datatype datatype, MPI_Count *true_lb, MPI_Count *true_extent) <br></tt>  
<P> 
 <tt> MPI_Type_get_true_extent_x(datatype, true_lb, true_extent, ierror) <br> TYPE(MPI_Datatype), INTENT(IN) :: datatype <br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: true_lb, true_extent <br>INTEGER, OPTIONAL, INTENT(OUT) :: ierror <br></tt>  
 <tt> MPI_TYPE_GET_TRUE_EXTENT_X(DATATYPE, TRUE_LB, TRUE_EXTENT, IERROR)<br> INTEGER DATATYPE,  IERROR<br>INTEGER(KIND=MPI_COUNT_KIND) TRUE_LB, TRUE_EXTENT <br></tt>  
<P> 
<font face="sans-serif"> true_lb</font> returns the offset of the lowest unit of store which  
is addressed by the datatype, i.e., the lower bound of the  
corresponding typemap, ignoring explicit lower bound markers.  
<font face="sans-serif"> true_extent</font> returns the  
true size of  
the datatype, i.e., the extent of the corresponding typemap, ignoring  
explicit lower bound and upper bound markers, and performing no  
rounding for alignment.  If the typemap associated with  
<font face="sans-serif"> datatype</font> is  
<p><i> 
Typemap = { (type<SUB>0</SUB>, disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>)} 
</i><p>  
Then  
<p><i> 
true_lb(Typemap) = min<SUB>j</SUB>  { disp<SUB>j</SUB> ~:~ type<SUB>j</SUB> ne mpiublblb_marker, mpiublbub_marker }, 
</i><p>  
<p><i> 
true_ub (Typemap) = max<SUB>j</SUB> {disp<SUB>j</SUB> + sizeof(type<SUB>j</SUB>) ~:~ type<SUB>j</SUB> ne 
mpiublblb_marker, mpiublbub_marker} , 
</i><p>  
and  
<p><i> 
true_extent (Typemap) = true_ub(Typemap) - true_lb(typemap). 
</i><p>  
(Readers should compare this with the definitions in   
Section <a href="node83.htm#Node83">Lower-Bound and Upper-Bound Markers 
</a> and  
Section <a href="node84.htm#Node84">Extent and Bounds of Datatypes 
</a>,  
which describe the function   
<font face="sans-serif"> MPI_TYPE_GET_EXTENT</font>.)  
<P> 
The <font face="sans-serif"> true_extent</font> is the minimum number of bytes of  
memory necessary to hold a datatype, uncompressed.  
<P> 
For both functions, if either  OUT parameter cannot express the value to  
be returned (e.g., if the parameter is too small to hold the output  
value), it is set to <font face="sans-serif">  MPI_UNDEFINED</font>.  
<P> 

<P>
<hr>
<a href="node84.htm#Node84"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node77.htm#Node77"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node86.htm#Node86"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node77.htm#Node77"> Derived Datatypes</a>
<b>Next: </b><a href="node86.htm#Node86"> Commit and Free</a>
<b>Previous: </b><a href="node84.htm#Node84"> Extent and Bounds of Datatypes</a>
<p>
<HR>
Return to <A HREF="node523.htm">MPI-3.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-3.1 of June 4, 2015<BR>
HTML Generated on June 4, 2015
</FONT>
</body>
</html>
