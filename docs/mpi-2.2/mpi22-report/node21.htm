<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-terms/terms-2.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Opaque Objects</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node21">21. Opaque Objects</a></H2>
<A HREF="node20.htm#Node20"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node20.htm#Node20"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node22.htm#Node22"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node20.htm#Node20"> Data Types</a>
<b>Next: </b><A HREF="node22.htm#Node22"> Array Arguments</a>
<b>Previous: </b><A HREF="node20.htm#Node20"> Data Types</a>
<P>
  
<P> 
<font face="sans-serif"> MPI</font> manages <b> system memory</b> that is used for buffering  
messages and for storing internal representations of various <font face="sans-serif"> MPI</font> objects  
such as groups, communicators, datatypes, etc.    
This memory is not directly accessible to the user, and objects stored  
there are <b> opaque</b>: their size and shape is not visible to the  
user.  Opaque objects are accessed via <b> handles</b>, which exist in  
user space.  <font face="sans-serif"> MPI</font> procedures that operate on opaque objects are  
passed handle arguments to access these objects.   
In addition to their use by <font face="sans-serif"> MPI</font> calls for object access, handles can  
participate in assignments and comparisons.  
<P> 
In Fortran, all handles have type <tt> INTEGER</tt>.  In C and C++, a  
different handle type is defined for each category of objects.  In  
addition, handles themselves are distinct objects in C++.  The C and  
C++ types must support the use of the assignment and equality  
operators.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
In Fortran, the handle can be an index into a table of opaque objects  
in a system table; in C it can be such an index or a pointer to the  
object.  C++ handles can simply ``wrap up'' a table index or pointer.  
<P> 
 (<em> End of advice to implementors.</em>) <BR> 
Opaque objects are allocated and deallocated  
by calls that are specific to each object type.  
These are listed in the sections where the objects are described.  
The calls accept a handle argument of matching type.  
In an allocate call this is an <font face="sans-serif">  OUT</font> argument that   
returns a valid reference to the object.  
In a call to deallocate this is an <font face="sans-serif">  INOUT</font> argument which returns   
with an ``invalid handle'' value.  
<font face="sans-serif"> MPI</font> provides an ``invalid handle'' constant  
for each object type.  Comparisons to this constant are used to test for  
validity of the handle.  
<P> 
A call to a deallocate routine invalidates the handle and marks the  
object for deallocation.  The object is not accessible to the user  
after the call.  However, <font face="sans-serif"> MPI</font> need not deallocate the object  
immediately.  Any operation pending (at the time of the deallocate)  
that involves this object will complete normally; the object will be  
deallocated afterwards.  
<P> 
An opaque object and its handle are significant only at the process  
where the object was created and cannot be transferred to another  
process.  
<P> 
<font face="sans-serif"> MPI</font> provides certain predefined opaque objects and predefined,  
static handles to these objects.    
The user must not free such objects.  
In C++, this is enforced by declaring the handles to these predefined  
objects to be <tt> static const</tt>.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
This design  
hides the internal representation used for <font face="sans-serif"> MPI</font> data structures,  
thus allowing similar calls in C, C++, and Fortran. It also avoids conflicts  
with the typing rules   
in these languages, and easily allows future extensions of  
functionality.  
The mechanism for opaque objects used here loosely follows the POSIX Fortran  
binding standard.  
<P> 
The explicit separation of handles in user space and objects  
in system space allows space-reclaiming and deallocation  
calls to be made at appropriate points in the user program.  If the  
opaque objects were in user space, one would have to be very careful not  
to go out of scope before any pending operation requiring that object  
completed.  The specified design allows an object to be marked for  
deallocation, the user program can then go out of scope, and the object  
itself still persists until any pending operations are complete.  
<P> 
The requirement that handles support   
assignment/comparison is made since   
such operations are common.  
This restricts the domain of possible implementations.  
The alternative would have been  
to allow handles to have been an arbitrary, opaque type.  This would  
force the introduction of routines to do assignment and comparison, adding  
complexity, and was therefore ruled out.  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
A user may accidently create a dangling reference by assigning to a  
handle the value of another handle, and then deallocating the object  
associated with these handles.  Conversely, if a handle variable is  
deallocated before the associated object is freed, then the object  
becomes inaccessible (this may occur, for example, if the handle is a  
local variable within a subroutine, and the subroutine is exited  
before the associated object is deallocated).  It is the user's  
responsibility to avoid adding or deleting references to opaque  
objects, except as a result of <font face="sans-serif"> MPI</font> calls that allocate or deallocate  
such objects.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
The intended semantics of opaque objects is that opaque objects are separate  
from one another; each call to allocate such an object copies all the information  
required for the object.   Implementations may avoid excessive copying by  
substituting referencing for copying.  For example, a derived datatype   
may contain  
references to its components, rather then copies of its components; a call to  
<font face="sans-serif"> MPI_COMM_GROUP</font> may return a reference to the group associated with  
the communicator, rather than a copy of this group.  In such cases, the  
implementation must maintain reference counts, and allocate and deallocate  
objects in such a way that the visible effect is as if the objects were copied.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node20.htm#Node20"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node20.htm#Node20"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node22.htm#Node22"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node20.htm#Node20"> Data Types</a>
<b>Next: </b><A HREF="node22.htm#Node22"> Array Arguments</a>
<b>Previous: </b><A HREF="node20.htm#Node20"> Data Types</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
