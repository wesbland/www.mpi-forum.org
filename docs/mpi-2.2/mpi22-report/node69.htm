<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Derived Datatypes</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node69">68. Derived Datatypes</a></H1>
<A HREF="node68.htm#Node68"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node70.htm#Node70"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node70.htm#Node70"> Type Constructors with Explicit Addresses</a>
<b>Previous: </b><A HREF="node68.htm#Node68"> Datatypes</a>
<P>
  
<P> 
Up to here, all point to point communication have involved only   
buffers containing a sequence of identical basic datatypes.  
This is too constraining on two accounts.  One often wants to pass  
messages that contain values with different datatypes (e.g., an integer count,  
followed by a sequence of real numbers); and one often wants to send  
noncontiguous data (e.g., a sub-block of a matrix).  One solution is to  
pack noncontiguous data into a contiguous buffer  
at the sender site and unpack it   
at the receiver site.   This has  
the disadvantage of requiring additional memory-to-memory copy operations  
at both sites, even when the communication  
subsystem has scatter-gather capabilities.   Instead, <font face="sans-serif"> MPI</font> provides  
mechanisms to specify more general, mixed, and noncontiguous  
communication buffers. It is up to the implementation to decide  
whether data should be first packed in a contiguous buffer before being  
transmitted, or whether it can be collected directly from where it  
resides.  
<P> 
The general mechanisms provided here allow one to transfer directly,  
without copying, objects of various shape and size.  It is not assumed  
that the <font face="sans-serif"> MPI</font> library is cognizant of the objects declared in the host  
language. Thus, if one wants to transfer a structure, or an array  
section, it will be necessary to provide in <font face="sans-serif"> MPI</font> a definition of a  
communication buffer that mimics the definition of the structure or  
array section in question.  These facilities can be used by library  
designers to define communication functions that can transfer objects  
defined in the host language --- by decoding their definitions as  
available in a symbol table or a dope vector.  Such higher-level  
communication functions are not part of <font face="sans-serif"> MPI</font>.  
<P> 
More general communication buffers are specified by replacing the  
basic datatypes that have been used so far with derived datatypes that  
are constructed from basic datatypes using the constructors described  
in this section.  These methods of constructing derived datatypes can  
be applied recursively.  
<P> 
A <b> general datatype</b> is an opaque object that specifies two  
things:  
<ul> 
 
<li>A sequence of basic datatypes  
 
<li>A sequence of integer (byte) displacements  
</ul> 
<BR> 
The displacements are not required to be positive, distinct, or  
in increasing order. Therefore, the order of items need not  
coincide with their order in store, and an item may appear more than  
once.  
We call such a pair of sequences (or sequence of pairs) a <b> type map</b>.  
The sequence of basic datatypes (displacements ignored) is the <b>  
type signature</b> of the datatype.  
<P> 
<P> 
Let  
<p><I> 
Typemap = { (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I><p>  
be such a type map, where <I>type<SUB>i</SUB></I> are basic types, and  
<I>disp<SUB>i</SUB></I> are  displacements.  
Let  
<p><I> 
Typesig = { type<SUB>0</SUB> , ... , type<SUB>n-1</SUB> } 
</I><p>  
be the associated type signature.  
This type map, together with a base address <em> buf</em>,  
specifies a communication buffer: the communication buffer that consists of <I>n</I>  
entries, where the <I>i</I>-th entry is at address <I>buf + 
disp<SUB>i</SUB></I> and has type <I>type<SUB>i</SUB></I>.  
A message assembled from such a  
communication buffer will consist of <I>n</I> values, of the types defined  
by <I>Typesig</I>.  
 <P> 
Most datatype constructors have replication count or block length arguments.  
Allowed values are <font color="red">non-negative<font color="black"> integers. If the value is zero, no elements are  
generated in the type map and there is no effect on datatype bounds or  
extent.   
  
We can use a handle to a general datatype as an argument in a send or  
receive operation, instead of a basic datatype argument.  The  
operation  
<font face="sans-serif"> MPI_SEND(buf, 1, datatype,...)</font> will use the send buffer  
defined by the base address <font face="sans-serif"> buf</font> and the general datatype  
associated with <font face="sans-serif"> datatype</font>; it will generate a message with the type  
signature determined by the <font face="sans-serif"> datatype</font> argument.  
<font face="sans-serif"> MPI_RECV(buf, 1, datatype,...)</font> will use the receive buffer  
defined by the base address <font face="sans-serif"> buf</font> and the general datatype  
associated with <font face="sans-serif"> datatype</font>.  
<P> 
General datatypes can be used in all send and receive  
operations.  We discuss, in Section <a href="node80.htm#Node80">Use of General Datatypes in Communication 
</a>, the  
case where the second argument <font face="sans-serif"> count</font> has value <I>&gt; 1</I>.  
<P> 
The basic datatypes presented in  
Section <a href="node44.htm#Node44">Message Data 
</a>  
are particular cases of a general datatype, and are predefined.  
Thus, <font face="sans-serif"> MPI_INT</font> is a predefined handle to a datatype with type  
map <I>{ ( 
int, 0) }</I>, with one entry of type <font face="sans-serif"> int</font> and  
displacement zero.  The other basic datatypes are similar.  
<P> 
The <b> extent</b> of a datatype is defined to  
be the span from the first byte to the last byte occupied by entries in this  
datatype, rounded up to satisfy alignment requirements.  
That is, if  
<p><I> 
Typemap = { (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I><p>  
then  
  
<P><A NAME="node69.htm#Equation1"><IMG WIDTH=330 HEIGHT=54 SRC="img9.gif"></a><P>
If <I>type<SUB>i</SUB></I> requires alignment to a byte address that   
is  
a multiple  
of <I>k<SUB>i</SUB></I>,  
then <IMG WIDTH=4 HEIGHT=5 SRC="img10.gif">
 is the least <font color="red">non-negative<font color="black"> increment needed to round  
<I>extent(Typemap)</I> to the next multiple of <IMG WIDTH=34 HEIGHT=8 SRC="img11.gif">
.  
The complete definition of <b> extent</b> is given on page <a href="node75.htm#Node75">Lower-Bound and Upper-Bound Markers 
</a>.  
<P> 
  
<P> 
<P> 
<BR><b> Example</b>   
  
Assume that  
<I>Type = { ( double,0), ( char, 8) }</I><P> 
(a <font face="sans-serif"> double</font> at  
displacement zero, followed by a <font face="sans-serif"> char</font> at displacement eight).  
Assume, furthermore, that  
doubles have to be strictly aligned at addresses that are multiples of eight.  
Then, the extent of this datatype is 16 (9 rounded to the next multiple of 8).  
A datatype that consists of a character immediately followed by a double will  
also have an extent of 16.  
   
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The definition of extent is motivated by the assumption that  
the amount of padding added at the end of each structure in an array of  
structures is the least needed to fulfill alignment constraints.  
More explicit control of the extent is provided in  
Section <a href="node75.htm#Node75">Lower-Bound and Upper-Bound Markers 
</a>.  Such explicit control is needed  
in cases where the assumption does not hold, for example, where union types  
are used.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
  
<P> 
  
<menu> 
</menu> 

<P>
<HR>
<A HREF="node68.htm#Node68"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node70.htm#Node70"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node70.htm#Node70"> Type Constructors with Explicit Addresses</a>
<b>Previous: </b><A HREF="node68.htm#Node68"> Datatypes</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
