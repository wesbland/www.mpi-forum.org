<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Nonblocking Communication</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node57">56. Nonblocking Communication</a></H1>
<A HREF="node56.htm#Node56"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node58.htm#Node58"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node58.htm#Node58"> Communication Request Objects</a>
<b>Previous: </b><A HREF="node56.htm#Node56"> Model Implementation of Buffered Mode</a>
<P>
  
<P> 
One can improve performance on many systems by overlapping  
communication and computation.  This is especially true on systems  
where communication can be executed autonomously by an intelligent  
communication controller.  Light-weight threads are one mechanism for  
achieving such overlap.  An alternative mechanism that often leads to  
better performance is to use <b> nonblocking communication</b>.  A  
nonblocking <b> send start</b> call initiates the send operation, but does not  
complete it.  The send start call   
can   
return before the message was copied out of the send buffer.  
A separate <b> send complete</b>  
call is needed to complete the communication, i.e., to verify that the  
data has been copied out of the send buffer.  With  
suitable hardware, the transfer of data out of the sender memory  
may proceed concurrently with computations done at the sender after  
the send was initiated and before it completed.  
Similarly, a nonblocking <b> receive start call</b> initiates the receive  
operation, but does not complete it.  The call   
can   
return before  
a message is stored into the receive buffer.  A separate <b> receive  
complete</b> call  
is needed to complete the receive operation and verify that the data has  
been received into the receive buffer.  
With suitable hardware, the transfer of data into the receiver memory  
may proceed concurrently with computations done after the receive was  
initiated and before it completed.  The use of nonblocking receives may also  
avoid system buffering and memory-to-memory copying, as information is provided  
early on the location of the receive buffer.  
<P> 
Nonblocking send start calls can use the same four modes as blocking sends:  
<font face="sans-serif"> standard</font>, <font face="sans-serif"> buffered</font>, <font face="sans-serif"> synchronous</font> and <font face="sans-serif"> ready</font>.  These carry  
the same meaning.  
Sends of all modes, <font face="sans-serif"> ready</font> excepted, can be started whether a matching  
receive has been posted or not; a nonblocking <font face="sans-serif"> ready</font>  
send can be started only if  
a matching receive is posted.   In all cases, the send start call  
is local: it returns immediately, irrespective of the  
status of other processes.  
If the call causes some system resource to be exhausted, then it will  
fail and return an error code.  Quality  
implementations of <font face="sans-serif"> MPI</font> should ensure that this happens only  
in ``pathological'' cases.  That is, an <font face="sans-serif"> MPI</font> implementation  
should be able to support a  
large number of pending nonblocking operations.  
<P> 
The send-complete call returns when data has been copied out of the  
send buffer.  
It may carry additional meaning, depending on the send mode.  
<P> 
If the send mode is <font face="sans-serif"> synchronous</font>, then the  
send can complete only if a matching receive has started.  That  
is, a receive has  
been posted, and has been matched with the send.  In this case,  
the send-complete call is non-local.  Note that a synchronous,  
nonblocking send may complete, if matched by a nonblocking receive, before  
the receive complete call occurs.  (It can complete as soon as the sender  
``knows'' the transfer will complete, but before the receiver ``knows'' the  
transfer will complete.)  
<P> 
If the send mode is <font face="sans-serif"> buffered</font> then the  
message must be buffered if there is no pending receive.  In this case,  
the send-complete  
call is local, and must succeed irrespective of the status of a matching  
receive.  
<P> 
If the send mode is <font face="sans-serif"> standard</font> then the send-complete call may  
return before a matching receive   
is posted,   
if the message is buffered.  On the other hand, the  
send-complete may not complete until a matching receive   
is posted,   
and the message was copied into the receive buffer.  
<P> 
Nonblocking sends can be matched with blocking receives, and  
vice-versa.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
The completion of a send operation may be delayed, for standard mode, and must  
be delayed, for synchronous mode, until a matching receive is posted.  
The use of nonblocking sends in these two cases allows the sender to proceed  
ahead of the receiver, so that the computation is more tolerant  
of fluctuations in the speeds of the two processes.  
<P> 
  
2.2  
<font color="red">  
Nonblocking sends in the buffered and ready modes have a more limited   
impact, e.g., the blocking version of buffered send is capable of   
completing regardless of when a matching receive call is made. However,   
separating the start from the completion of these sends still gives   
some opportunity for optimization within the <font face="sans-serif"> MPI</font> library. For example,   
starting a buffered send gives an implementation more flexibility in   
determining if and how the message is buffered. There are also advantages   
for both nonblocking buffered and ready modes when data copying can   
be done concurrently with computation.  
<font color="black">  
<P> 
The message-passing model implies that communication is initiated by  
the sender.  
The communication will generally have lower overhead if a receive is  
already posted when the sender initiates the communication  (data can be moved  
directly to the receive buffer, and there is no need to queue a pending send  
request).  However,  
a receive operation can complete only after the matching send has occurred.  
The use of nonblocking receives allows one to achieve lower communication overheads  
without blocking the receiver while it waits for the send.  
 (<em> End of advice to users.</em>) <BR> 
<menu> 
</menu> 

<P>
<HR>
<A HREF="node56.htm#Node56"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node58.htm#Node58"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node58.htm#Node58"> Communication Request Objects</a>
<b>Previous: </b><A HREF="node56.htm#Node56"> Model Implementation of Buffered Mode</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
