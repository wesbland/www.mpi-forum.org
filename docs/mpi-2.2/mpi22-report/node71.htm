<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Datatype Constructors</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node71">70. Datatype Constructors</a></H2>
<A HREF="node70.htm#Node70"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node69.htm#Node69"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node72.htm#Node72"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node69.htm#Node69"> Derived Datatypes</a>
<b>Next: </b><A HREF="node72.htm#Node72"> Subarray Datatype Constructor</a>
<b>Previous: </b><A HREF="node70.htm#Node70"> Type Constructors with Explicit Addresses</a>
<P>
  
<P> 
<P> 
Contiguous The simplest datatype constructor is  
<font face="sans-serif"> MPI_TYPE_CONTIGUOUS</font> which  
allows replication of a datatype into contiguous locations.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CONTIGUOUS(count, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>replication count (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_contiguous(int count, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CONTIGUOUS(COUNT, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER  COUNT, OLDTYPE, NEWTYPE, IERROR <BR></tt>  
 <font color="red">{<font color="black"> MPI::Datatype MPI::Datatype::Create_contiguous(int count) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
<font face="sans-serif"> newtype</font> is the datatype obtained by concatenating  
<font face="sans-serif"> count</font> copies of  
<font face="sans-serif"> oldtype</font>.   Concatenation is defined using <em> extent</em> as the size of  
the concatenated copies.  
<P> 
<BR><b> Example</b>   
  
Let <font face="sans-serif"> oldtype</font> have type map  
<I> 
{ ( double, 0), ( char, 8) } , 
</I>  
with extent 16,  
and let <IMG WIDTH=45 HEIGHT=7 SRC="img12.gif">
.  The type map of  
the datatype returned by <font face="sans-serif"> newtype</font> is  
<I> 
{ ( double, 0), ( char, 8), ( double, 16), ( 
char, 24), ( double, 32), ( char, 40) } ; 
</I>  
i.e., alternating <font face="sans-serif"> double</font> and <font face="sans-serif"> char</font> elements, with displacements  
<I>0, 8, 16, 24, 32, 40</I>.  
   
<P> 
  
In general,  
assume that the type map of <font face="sans-serif"> oldtype</font> is  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <I>ex</I>.  
Then <font face="sans-serif"> newtype</font> has a type map with <I> count &#183; n</I> entries  
defined by:  
<I> 
{ (type<SUB>0</SUB>, disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>), (type<SUB>0</SUB>, disp<SUB>0</SUB> 
+ex), ... ,(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> + ex) , 
</I>  
<I> 
...,(type<SUB>0</SUB>, disp<SUB>0</SUB> +ex &#183;( count-1) ), ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ex &#183; ( count-1)) } . 
</I>  
  
<P> 
<P> 
Vector The function  
<font face="sans-serif"> MPI_TYPE_VECTOR</font> is a more general constructor that  
allows replication of a datatype  
into locations that consist of equally spaced blocks.  Each block  
is obtained by concatenating the same number of copies of the old datatype.  
The spacing between blocks is a multiple of the extent of the old datatype.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_VECTOR( count, blocklength, stride, oldtype,  
newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>number of elements in each block  
(<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> IN stride</TD><TD>number of elements between start of each block (integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_vector(int count, int blocklength, int stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_VECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER  COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR <BR></tt>  
 <font color="red">{<font color="black"> MPI::Datatype MPI::Datatype::Create_vector(int count, int blocklength, int stride) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
<BR><b> Example</b>   
  
Assume, again, that <font face="sans-serif"> oldtype</font> has type map  
<I> 
{ ( double, 0), ( char, 8) } , 
</I>  
with extent 16.  
A call to <font face="sans-serif"> MPI_TYPE_VECTOR( 2, 3, 4, oldtype, newtype)</font> will  
create the datatype with type map,  
<I> 
{ 
( double, 0), ( char, 8), ( double, 16), ( char, 
24), ( double, 32), ( char, 40), 
</I>  
<I> 
( double, 64), ( char, 72), ( double, 80), ( char, 
88), ( double, 96), ( char, 104) 
} . 
</I>  
That is, two blocks with three copies each of the old  
type, with a stride of 4 elements (<I>4 &#183; 16</I> bytes) between the blocks.  
   
<P> 
<BR><b> Example</b>   
  
A call to <font face="sans-serif"> MPI_TYPE_VECTOR(3, 1, -2, oldtype, newtype)</font> will create  
the datatype,  
<I> 
{ 
( double, 0), ( char, 8), ( double, -32), ( char, 
-24), ( double, -64), ( char, -56) 
} . 
</I>  
   
<P> 
  
In general, assume that <font face="sans-serif"> oldtype</font> has type map,  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <I>ex</I>.  Let <font face="sans-serif"> bl</font> be the <font face="sans-serif"> blocklength</font>.  
The newly created  datatype has a type map with  
<I> count &#183;  bl &#183; n</I><P> 
entries:  
<I> 
{ 
(type<SUB>0</SUB>, disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB>), 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> + ex) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ex ), ..., 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> + ( bl -1) &#183; ex 
) , ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ( bl -1) &#183; ex ) , 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> +  stride &#183; ex ) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> +  stride &#183; ex ), ... , 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> + ( stride +  bl -1) &#183; ex ) , ... , 
(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> + ( stride +  bl -1) &#183; 
ex ) , ...., 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> +  stride &#183; ( count-1) &#183; ex ) , ... , 
</I>  
<I> 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> +  stride &#183; ( count -1) &#183; 
ex ) 
, ... , 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> + ( stride &#183; ( count -1) 
+  bl -1) &#183; ex ) , ... , 
</I>  
<I> 
(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> + ( stride &#183; ( count -1) 
+  bl -1) &#183; ex ) 
} . 
</I>  
  
<P> 
A call to <font face="sans-serif"> MPI_TYPE_CONTIGUOUS(count, oldtype, newtype)</font> is  
equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_VECTOR(count, 1, 1, oldtype, newtype)</font>, or to a call to  
<font face="sans-serif"> MPI_TYPE_VECTOR(1, count, n, oldtype, newtype)</font>, <font face="sans-serif"> n</font> arbitrary.  
<P> 
<P> 
Hvector The function   
<font face="sans-serif"> MPI_TYPE_CREATE_HVECTOR</font>   
is identical to  
<font face="sans-serif"> MPI_TYPE_VECTOR</font>, except that <font face="sans-serif"> stride</font> is given in bytes,  
rather than in elements.  The use for both types of vector  
constructors is illustrated in Section <a href="node83.htm#Node83">Examples 
</a>.  
(<font face="sans-serif"> H</font> stands for ``heterogeneous'').  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HVECTOR( count, blocklength, stride,  
oldtype, newtype)</TD></TR> <TR><TD> IN count</TD><TD>number of blocks (<font color="red">non-negative<font color="black">  
integer)</TD></TR> <TR><TD> IN blocklength</TD><TD>number of elements in each block  
(<font color="red">non-negative<font color="black"> integer)</TD></TR> <TR><TD> IN stride</TD><TD>number of bytes between start  
of each block (integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_hvector(int count, int blocklength, MPI_Aint stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_HVECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, BLOCKLENGTH, OLDTYPE, NEWTYPE, IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) STRIDE <BR></tt>  
  
 <font color="red">{<font color="black"> MPI::Datatype MPI::Datatype::Create_hvector(int count, int blocklength, MPI::Aint stride) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
This function replaces <font face="sans-serif"> MPI_TYPE_HVECTOR</font>, whose use is deprecated. See also Chapter <a href="node326.htm#Node326">Deprecated Functions 
</a>.   
  
<P> 
  
Assume that <font face="sans-serif"> oldtype</font> has type map,  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <I>ex</I>.  Let <font face="sans-serif"> bl</font> be the <font face="sans-serif"> blocklength</font>.  
The newly created  datatype has a type map with  
<I> count &#183;  bl &#183; n</I><P> 
entries:  
<I> 
{ 
(type<SUB>0</SUB>, disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB>), 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> + ex) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ex ), ..., 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> + ( bl -1) &#183; ex 
) , ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ( bl -1) &#183; ex ) , 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> +  stride  ) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> +  stride ) , ... , 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> +  stride + (  bl -1) &#183; ex 
) , ... , 
</I>  
<I> 
(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> +  stride + ( bl -1) &#183; 
ex ) , 
...., 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> +  stride &#183; ( count-1) ) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> +  stride &#183; ( count -1)  ) 
, ... , 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> +  stride &#183; ( count -1) 
+ ( bl -1) &#183; ex ) , ... , 
</I>  
<I> 
(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> +  stride &#183; ( count -1) 
+ ( bl -1) &#183; ex ) 
} . 
</I>  
  
<P> 
<P> 
Indexed The function  
<font face="sans-serif"> MPI_TYPE_INDEXED</font> allows  
replication of an old datatype into a sequence of blocks (each block is  
a concatenation of the old datatype), where  
each block can contain a different number of copies and have a different  
displacement.  All block displacements are multiples of the old type  
extent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_INDEXED( count, array_of_blocklengths,  
array_of_displacements, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks -- also number of entries in  
<BR><font face="sans-serif"> array_of_displacements</font> and  
<font face="sans-serif"> array_of_blocklengths</font> (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> IN array_of_blocklengths</TD><TD>number of elements per block  
(array of <font color="red">non-negative<font color="black"> integers)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>displacement for each block,  
in multiples of <font face="sans-serif"> oldtype</font> extent (array of integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_indexed(int count, int *array_of_blocklengths, int *array_of_displacements, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_INDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_DISPLACEMENTS(*), OLDTYPE, NEWTYPE, IERROR <BR></tt>  
 <font color="red">{<font color="black"> MPI::Datatype MPI::Datatype::Create_indexed(int count, const int array_of_blocklengths[], const int array_of_displacements[]) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
<BR><b> Example</b>   
  
  
Let <font face="sans-serif"> oldtype</font> have type map  
<I> 
{ ( double, 0), ( char, 8) } , 
</I>  
with extent 16.  
Let  <font face="sans-serif"> B = (3, 1)</font> and let <font face="sans-serif"> D = (4, 0)</font>.  A call to  
<font face="sans-serif"> MPI_TYPE_INDEXED(2, B, D, oldtype, newtype)</font> returns a datatype with  
type map,  
<I> 
{ 
( double, 64), ( char, 72), ( double, 80), ( char, 
88), ( double, 96), ( char, 104), 
</I>  
<I> 
( double, 0), ( char, 8) 
} . 
</I>  
That is, three copies of the old type starting at displacement  
64, and one copy starting at displacement 0.  
   
<P> 
  
In general,  
assume that <font face="sans-serif"> oldtype</font> has type map,  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <em> ex</em>.  
Let <font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklength</font> argument and  
<font face="sans-serif"> D</font> be the  
<BR>  
<font face="sans-serif"> array_of_displacements</font> argument. The newly created datatype  
has <IMG WIDTH=73 HEIGHT=13 SRC="img13.gif">
 entries:  
<IMG WIDTH=293 HEIGHT=11 SRC="img14.gif">
  
<IMG WIDTH=408 HEIGHT=11 SRC="img15.gif">
  
<IMG WIDTH=347 HEIGHT=11 SRC="img16.gif">
  
<IMG WIDTH=249 HEIGHT=11 SRC="img17.gif">
  
<IMG WIDTH=263 HEIGHT=12 SRC="img18.gif">
  
  
<P> 
A call to <font face="sans-serif"> MPI_TYPE_VECTOR(count, blocklength, stride, oldtype,  
newtype)</font> is equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_INDEXED(count, B, D, oldtype, newtype)</font> where  
<IMG WIDTH=168 HEIGHT=11 SRC="img19.gif">
  
and  
<IMG WIDTH=181 HEIGHT=11 SRC="img20.gif">
  
<P> 
<P> 
Hindexed The function   
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font>   
is identical to  
<font face="sans-serif"> MPI_TYPE_INDEXED</font>, except that block displacements in  
<font face="sans-serif"> array_of_displacements</font> are specified in  
bytes, rather than in multiples of the <font face="sans-serif"> oldtype</font> extent.  
  
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HINDEXED( count,  
array_of_blocklengths, array_of_displacements, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks --- also number of entries in  
<BR><font face="sans-serif"> array_of_displacements</font> and <font face="sans-serif"> array_of_blocklengths</font>   
(<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> IN array_of_blocklengths</TD><TD>number of elements in each block  
(array of <font color="red">non-negative<font color="black"> integers)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>byte displacement of each block  
(array of integer)</TD></TR> <TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_hindexed(int count, int array_of_blocklengths[], MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_HINDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), OLDTYPE, NEWTYPE, IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*) <BR></tt>  
<P> 
 <font color="red">{<font color="black"> MPI::Datatype MPI::Datatype::Create_hindexed(int count, const int array_of_blocklengths[], const MPI::Aint array_of_displacements[]) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
This function replaces <font face="sans-serif"> MPI_TYPE_HINDEXED</font>, whose use is deprecated. See also Chapter <a href="node326.htm#Node326">Deprecated Functions 
</a>.   
  
  
Assume that <font face="sans-serif"> oldtype</font> has type map,  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <I>ex</I>.  
Let <font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklength</font> argument and  
<font face="sans-serif"> D</font> be the  
<font face="sans-serif"> array_of_displacements</font> argument. The newly created datatype  
has a type map with  
<IMG WIDTH=73 HEIGHT=13 SRC="img21.gif">
 entries:  
<IMG WIDTH=255 HEIGHT=11 SRC="img22.gif">
  
<IMG WIDTH=191 HEIGHT=11 SRC="img23.gif">
  
<IMG WIDTH=214 HEIGHT=11 SRC="img24.gif">
  
<IMG WIDTH=308 HEIGHT=11 SRC="img25.gif">
  
<IMG WIDTH=249 HEIGHT=11 SRC="img26.gif">
  
<IMG WIDTH=263 HEIGHT=12 SRC="img27.gif">
  
  
  
<P> 
Indexed_block   
<P> 
This function is the same as <font face="sans-serif"> MPI_TYPE_INDEXED</font> except that the  
blocklength is the same for all blocks.  
There are many codes using indirect addressing arising from  
unstructured grids where the blocksize is always 1 (gather/scatter).  The  
following convenience function allows for constant blocksize and arbitrary  
displacements.  
<P> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_INDEXED_BLOCK(count, blocklength, array_of_displacements, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>length of array of displacements (non-negative   
        integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>size of block (non-negative   
        integer)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>array of displacements (array of integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_indexed_block(int count, int blocklength, int array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_INDEXED_BLOCK(COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <BR> INTEGER COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS(*), OLDTYPE, NEWTYPE, IERROR <BR></tt>  
<P> 
  
<P> 
  
<P> 
  
 <font color="red">{<font color="black"> MPI::Datatype MPI::Datatype::Create_indexed_block(int count, int blocklength, const int array_of_displacements[]) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
  
  
<P> 
<P> 
Struct <font face="sans-serif"> MPI_TYPE_STRUCT</font> is the most general type constructor.  
It further generalizes  
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font>   
in that it allows each block to consist of replications of  
different datatypes.  
  
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_STRUCT(count, array_of_blocklengths,  
array_of_displacements,  array_of_types, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks   
(<font color="red">non-negative<font color="black"> integer)  
--- also number of entries  
in arrays <font face="sans-serif"> array_of_types</font>, <font face="sans-serif"> array_of_displacements</font> and  
<font face="sans-serif"> array_of_blocklengths</font></TD></TR>  
<TR><TD> IN array_of_blocklength</TD><TD>number of elements in each block  
(array of <font color="red">non-negative<font color="black"> integer)</TD></TR>   
<TR><TD> IN array_of_displacements</TD><TD>byte  
displacement of each block (array of integer)</TD></TR>  
<TR><TD> IN array_of_types</TD><TD>type of elements in each block (array of  
handles to datatype objects)</TD></TR> <TR><TD> OUT newtype</TD><TD>new datatype  
(handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_struct(int count, int array_of_blocklengths[], MPI_Aint array_of_displacements[], MPI_Datatype array_of_types[], MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_STRUCT(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, ARRAY_OF_TYPES, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_TYPES(*), NEWTYPE, IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*) <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> static MPI::Datatype MPI::Datatype::Create_struct(int count, const int array_of_blocklengths[], const MPI::Aint array_of_displacements[], const MPI::Datatype array_of_types[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
  
This function replaces <font face="sans-serif"> MPI_TYPE_STRUCT</font>, whose use is deprecated. See also Chapter <a href="node326.htm#Node326">Deprecated Functions 
</a>.   
  
<BR><b> Example</b>   
  
Let <font face="sans-serif"> type1</font> have type map,  
<p><I> 
{ ( double, 0), ( char, 8) } , 
</I><p>  
with extent 16.  
Let <font face="sans-serif"> B = (2, 1, 3)</font>, <font face="sans-serif"> D = (0, 16, 26)</font>,  
and <font face="sans-serif"> T = (MPI_FLOAT, type1, MPI_CHAR)</font>.  Then a call to  
<font face="sans-serif"> MPI_TYPE_STRUCT(3, B, D, T, newtype)</font> returns  
a datatype with type map,  
<I> 
{ 
( float, 0), ( float, 4), ( double, 16), ( char, 
24), ( char, 26), ( char, 27), ( char, 28) 
} . 
</I>  
That is, two copies of <font face="sans-serif"> MPI_FLOAT</font> starting at 0, followed by  
one copy of <font face="sans-serif"> type1</font> starting at 16, followed by three copies of  
<font face="sans-serif"> MPI_CHAR</font>, starting at 26.  
(We assume that a float occupies four bytes.)  
   
<P> 
  
In general,  
let <font face="sans-serif"> T</font> be the <font face="sans-serif"> array_of_types</font> argument, where <font face="sans-serif"> T[i]</font>  
is a handle to,  
<I> 
typemap<SUB>i</SUB> = { (type<SUB>0</SUB><SUP>i</SUP> , disp<SUB>0</SUB><SUP>i</SUP> ) , ... , (type<SUB>n<SUB>i</SUB>-1</SUB><SUP>i</SUP> , 
disp<SUB>n<SUB>i</SUB>-1</SUB><SUP>i</SUP> ) } , 
</I>  
with extent <I>ex<SUB>i</SUB></I>.  
Let  
<font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklength</font> argument and <font face="sans-serif"> D</font> be  
the <font face="sans-serif"> array_of_displacements</font> argument.Let <font face="sans-serif"> c</font> be the  
<font face="sans-serif"> count</font> argument.  
Then the newly created datatype has a type map with  
<IMG WIDTH=60 HEIGHT=13 SRC="img28.gif">
<P> 
entries:  
<IMG WIDTH=241 HEIGHT=13 SRC="img29.gif">
  
<IMG WIDTH=394 HEIGHT=13 SRC="img30.gif">
  
<IMG WIDTH=313 HEIGHT=14 SRC="img31.gif">
  
<IMG WIDTH=244 HEIGHT=13 SRC="img32.gif">
  
<IMG WIDTH=253 HEIGHT=14 SRC="img33.gif">
  
  
<P> 
A call to   
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED(count, B, D, oldtype, newtype)</font>  
is equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT(count, B, D, T, newtype)</font>,   
where each entry of <font face="sans-serif"> T</font> is equal to <font face="sans-serif"> oldtype</font>.  
  
  

<P>
<HR>
<A HREF="node70.htm#Node70"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node69.htm#Node69"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node72.htm#Node72"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node69.htm#Node69"> Derived Datatypes</a>
<b>Next: </b><A HREF="node72.htm#Node72"> Subarray Datatype Constructor</a>
<b>Previous: </b><A HREF="node70.htm#Node70"> Type Constructors with Explicit Addresses</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
