<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-context/context.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Communicator Constructors</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node134">132. Communicator Constructors</a></H2>
<A HREF="node133.htm#Node133"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node132.htm#Node132"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node135.htm#Node135"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node132.htm#Node132"> Communicator Management</a>
<b>Next: </b><A HREF="node135.htm#Node135"> Communicator Destructors</a>
<b>Previous: </b><A HREF="node133.htm#Node133"> Communicator Accessors</a>
<P>
  
The following are collective functions that are invoked by all processes in the  
group or groups associated with <font face="sans-serif"> comm</font>.  
  
 
<BR> 
<em> Rationale.</em>  
<P> 
Note that there is a chicken-and-egg aspect to <font face="sans-serif"> MPI</font> in that a  
communicator is needed to create a new communicator.  The base  
communicator for all <font face="sans-serif"> MPI</font> communicators is predefined outside of <font face="sans-serif"> MPI</font>,  
and is <font face="sans-serif">  MPI_COMM_WORLD</font>.  This model was arrived at after  
considerable debate, and was chosen to increase ``safety'' of programs  
written in <font face="sans-serif"> MPI</font>.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
The <font face="sans-serif"> MPI</font> interface provides four communicator construction routines that  
apply to both intracommunicators and intercommunicators. The construction routine  
<font face="sans-serif"> MPI_INTERCOMM_CREATE</font> (discussed later) applies only to intercommunicators.  
<P> 
An intracommunicator involves a single group while an intercommunicator   
involves two groups.  
Where the following discussions address intercommunicator semantics,   
the two groups in an intercommunicator are  
called the <em> left</em> and <em> right</em> groups.  A process in an  
intercommunicator is a member of either the left or the right group.  From the  
point of view of that process, the  
group that the process is a member of is called the <em> local</em> group; the  
other group (relative to that process) is the <em> remote</em> group.  
The left and right group labels give us a way to describe the two groups in  
an intercommunicator that is not relative to any particular process (as the  
local and remote groups are).  
  
<TABLE><TR><TD COLSPAN=2>MPI_COMM_DUP(comm, newcomm)</TD></TR>  
<TR><TD> IN comm</TD><TD> communicator (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD> copy of <font face="sans-serif"> comm</font> (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_dup(MPI_Comm comm, MPI_Comm *newcomm) <BR></tt>  
<P> 
 <tt> MPI_COMM_DUP(COMM, NEWCOMM, IERROR)<BR> INTEGER COMM, NEWCOMM, IERROR <BR></tt>  
 <font color="red">{<font color="black"> MPI::Intracomm MPI::Intracomm::Dup() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> MPI::Intercomm MPI::Intercomm::Dup() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> MPI::Cartcomm MPI::Cartcomm::Dup() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> MPI::Graphcomm MPI::Graphcomm::Dup() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<font color="red">  
 <font color="red">{<font color="black"> MPI::Distgraphcomm MPI::Distgraphcomm::Dup() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<font color="black">  
 <font color="red">{<font color="black"> MPI::Comm&amp; MPI::Comm::Clone() const = 0 <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> MPI::Intracomm&amp; MPI::Intracomm::Clone() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> MPI::Intercomm&amp; MPI::Intercomm::Clone() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> MPI::Cartcomm&amp; MPI::Cartcomm::Clone() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> MPI::Graphcomm&amp; MPI::Graphcomm::Clone() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<font color="red">  
 <font color="red">{<font color="black"> MPI::Distgraphcomm&amp; MPI::Distgraphcomm::Clone() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<font color="black">  
  
<font face="sans-serif"> MPI_COMM_DUP</font> Duplicates the existing communicator <font face="sans-serif"> comm</font> with  
associated key values.  For each key value, the respective copy callback  
function determines the attribute value associated with this key in the  
new communicator; one particular action that a copy callback may take  
is to delete the attribute from the new communicator.  
Returns in <font face="sans-serif"> newcomm</font> a new  
communicator with the same group or groups, any copied cached information,  
but a new context (see Section <a href="node150.htm#Node150">Functionality 
</a>).  
Please see Section <a href="node337.htm#Node337">Communicators 
</a> on page <a href="node337.htm#Node337">Communicators 
</a> for further discussion   
about the C++ bindings for <font face="sans-serif"> Dup()</font> and <font face="sans-serif"> Clone()</font>.   
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
This operation is used to provide a parallel library call with a duplicate  
communication  
space that has the same properties as the original communicator.  This  
includes any attributes (see below), and topologies (see  
Chapter <a href="node163.htm#Node163">Process Topologies 
</a>).  This call is valid even if there are  
pending point-to-point communications involving the communicator  
<font face="sans-serif"> comm</font>.  A typical call might involve a <font face="sans-serif"> MPI_COMM_DUP</font>  
at the beginning of the parallel call, and an <font face="sans-serif"> MPI_COMM_FREE</font> of  
that duplicated communicator at the end of the call.  Other models  
of communicator management are also possible.  
<P> 
This call applies to both intra- and inter-communicators.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
One need not actually copy the group information, but only add a new reference  
and increment the reference count.  Copy on write can be used for the cached  
information. (<em> End of advice to implementors.</em>) <BR> 
  
<TABLE><TR><TD COLSPAN=2>MPI_COMM_CREATE(comm, group, newcomm)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN group</TD><TD> Group, which is a subset of the group of  
<font face="sans-serif"> comm</font> (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD> new communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_create(MPI_Comm comm, MPI_Group group, MPI_Comm *newcomm) <BR></tt>  
<P> 
 <tt> MPI_COMM_CREATE(COMM, GROUP, NEWCOMM, IERROR)<BR> INTEGER COMM, GROUP, NEWCOMM, IERROR <BR></tt>  
  
 <font color="red">{<font color="black"> MPI::Intercomm MPI::Intercomm::Create(const MPI::Group&amp; group) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
 <font color="red">{<font color="black"> MPI::Intracomm MPI::Intracomm::Create(const MPI::Group&amp; group) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
  
  
2.2  
<P> 
<font color="red">  
 If <font face="sans-serif"> comm</font> is an intracommunicator, this function returns a new communicator <font face="sans-serif"> newcomm</font> with  
communication group defined by the <font face="sans-serif"> group</font> argument. No cached information propagates from  
<font face="sans-serif"> comm</font> to <font face="sans-serif"> newcomm</font>. Each process must call with a <font face="sans-serif"> group</font> argument that is a subgroup   
of the <font face="sans-serif"> group</font> associated with <font face="sans-serif"> comm</font>; this could be <font face="sans-serif">  MPI_GROUP_EMPTY</font>. The processes   
may specify different values for the <font face="sans-serif"> group</font> argument. If a process calls with a non-empty <font face="sans-serif"> group</font>  
then all processes in that <font face="sans-serif"> group</font> must call the function with the same <font face="sans-serif"> group</font> as argument,   
that is the same processes in the same order. Otherwise the call is erroneous. This implies that the set of   
groups specified across the processes must be disjoint. If the calling process is a member of the group   
given as <font face="sans-serif"> group</font> argument, then <font face="sans-serif"> newcomm</font> is a communicator with <font face="sans-serif"> group</font> as its associated group. In the case   
that a process calls with a <font face="sans-serif"> group</font> to which it does not belong, e.g., <font face="sans-serif">  MPI_GROUP_EMPTY</font>, then <font face="sans-serif">  MPI_COMM_NULL</font>   
is returned as <font face="sans-serif"> newcomm</font>. The function is collective and must be called by all processes in the group of <font face="sans-serif"> comm</font>.  
<P> 
 
<BR> 
<em> Rationale.</em>  
 <P> 
The interface supports the original mechanism from MPI-1.1, which required the same <font face="sans-serif"> group</font> in all   
processes of <font face="sans-serif"> comm</font>. It was extended in MPI-2.2 to allow the use of disjoint subgroups in order to allow   
implementations to eliminate unnecessary communication that  <font face="sans-serif"> MPI_COMM_SPLIT</font> would incur when the user already   
knows the membership of the disjoint subgroups.   
 (<em> End of rationale.</em>) <BR> 
<font color="black">  
<P> 
  
 
<BR> 
<em> Rationale.</em>  
<P> 
The requirement that the entire group of <font face="sans-serif"> comm</font> participate in the call  
stems from the following considerations:  
<ul> 
 
<li>It allows the implementation to layer <font face="sans-serif"> MPI_COMM_CREATE</font> on top of  
regular collective communications.  
 
<li>It provides additional safety, in particular in the case where partially  
overlapping groups are used to create new communicators.  
 
<li>It permits implementations sometimes to avoid communication related to context  
creation.  
</ul> 
<BR> 
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_COMM_CREATE</font> provides a means to subset a group of processes for the  
purpose of separate MIMD computation, with separate communication space.  
<font face="sans-serif"> newcomm</font>, which emerges from <font face="sans-serif"> MPI_COMM_CREATE</font> can be used in  
subsequent calls to <font face="sans-serif"> MPI_COMM_CREATE</font> (or other communicator  
constructors) further to subdivide a computation into parallel  
sub-computations.  A more general service is provided by  
<font face="sans-serif"> MPI_COMM_SPLIT</font>, below.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
<font color="red">When calling <font face="sans-serif"> MPI_COMM_DUP</font>, all processes call with the same <font face="sans-serif"> group</font>   
(the <font face="sans-serif"> group</font> associated with the communicator).   
When calling <font face="sans-serif"> MPI_COMM_CREATE</font>, the processes provide the   
same <font face="sans-serif"> group</font> or disjoint subgroups. For both calls, it is theoretically possible   
to agree on a group-wide unique context with no communication.   
<font color="black">However, local execution of these functions requires  
use of a larger context name space and reduces error checking.  
Implementations may strike various compromises between these  
conflicting goals, such as bulk allocation of multiple contexts in one  
collective operation.  
<P> 
Important: If new communicators are created without synchronizing the  
processes involved then the communication system should be able to cope with  
messages arriving in a context that has not yet been allocated at the  
receiving process.  
 (<em> End of advice to implementors.</em>) <BR> 
  
 If <font face="sans-serif"> comm</font> is an  
intercommunicator, then the output communicator is also an intercommunicator  
where the local group consists only of those processes contained in  
<font face="sans-serif"> group</font> (see Figure <a href="node134.htm#Figure13">13 
</a>).  The <font face="sans-serif"> group</font>   
argument should only contain those processes in the local group of the input  
intercommunicator that are to be a part of <font face="sans-serif"> newcomm</font>.   
<font color="red">All processes in the same local group of <font face="sans-serif"> comm</font> must specify the same value for   
<font face="sans-serif"> group</font>, i.e., the same members in the same order.  
<font color="black">If either  
<font face="sans-serif"> group</font> does not specify at least one process in the local group of  
the intercommunicator, or if the calling process is not included in the  
<font face="sans-serif"> group</font>, <font face="sans-serif">  MPI_COMM_NULL</font> is returned.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
In the case where either the left or right group is empty, a null communicator  
is returned instead of an intercommunicator with <font face="sans-serif">  MPI_GROUP_EMPTY</font>  
because the side with the empty group must return <font face="sans-serif">  MPI_COMM_NULL</font>.  
 (<em> End of rationale.</em>) <BR> 
  
  <CENTER><P><IMG WIDTH=481 HEIGHT=459 SRC="collective-create.gif"><P>
</CENTER>  
  <BR> 
<b>Figure 13: </b><A NAME="Figure13">Intercommunicator create using <font face="sans-serif"> MPI_COMM_CREATE</font>
extended to intercommunicators.  The input groups are those in the grey
circle.</a><P> 
  
    
<BR><b> Example</b>  
The following example illustrates how the first node in the left  
side of an intercommunicator could be joined with all members on the  
right side of an intercommunicator to form a new  
intercommunicator.  
  
  
  
  
  
<BR> 
<pre><tt>        MPI_Comm  inter_comm, new_inter_comm; 
        MPI_Group local_group, group; 
        int       rank = 0; /* rank on left side to include in  
                               new inter-comm */ 
 
        /* Construct the original intercommunicator: "inter_comm" */ 
        ... 
 
        /* Construct the group of processes to be in new  
           intercommunicator */ 
        if (/* I'm on the left side of the intercommunicator */) { 
          MPI_Comm_group ( inter_comm, &amp;local_group ); 
          MPI_Group_incl ( local_group, 1, &amp;rank, &amp;group ); 
          MPI_Group_free ( &amp;local_group ); 
        } 
        else  
          MPI_Comm_group ( inter_comm, &amp;group ); 
 
        MPI_Comm_create ( inter_comm, group, &amp;new_inter_comm ); 
        MPI_Group_free( &amp;group ); 
</tt></pre> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_COMM_SPLIT(comm, color, key, newcomm)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN color</TD><TD>control of subset assignment (integer)</TD></TR>  
<TR><TD> IN key</TD><TD> control of rank assigment (integer)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD> new communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_split(MPI_Comm comm, int color, int key, MPI_Comm *newcomm) <BR></tt>  
<P> 
 <tt> MPI_COMM_SPLIT(COMM, COLOR, KEY, NEWCOMM, IERROR)<BR> INTEGER COMM, COLOR, KEY, NEWCOMM, IERROR <BR></tt>  
  
 <font color="red">{<font color="black"> MPI::Intercomm MPI::Intercomm::Split(int color, int key) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
 <font color="red">{<font color="black"> MPI::Intracomm MPI::Intracomm::Split(int color, int key) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
  
 This function partitions the group associated with <font face="sans-serif"> comm</font>  
into disjoint subgroups, one for each value of <font face="sans-serif"> color</font>.  Each subgroup  
contains all processes of the same color.  Within each subgroup, the processes  
are ranked in the order defined by the value of the argument <font face="sans-serif"> key</font>,  
with ties broken according to their rank in the old group.  A new communicator  
is created for each subgroup and returned in <font face="sans-serif"> newcomm</font>.  A process may  
supply the color value <font face="sans-serif"> MPI_UNDEFINED</font>, in which case <font face="sans-serif"> newcomm</font>  
returns <font face="sans-serif">  MPI_COMM_NULL</font>.  This is a collective call, but each process  
is permitted to provide different values for <font face="sans-serif"> color</font> and <font face="sans-serif"> key</font>.  
<P> 
  
2.2  
<font color="red">  
With an intracommunicator <font face="sans-serif"> comm</font>, a call to <font face="sans-serif"> MPI_COMM_CREATE(comm, group, newcomm)</font> is   
equivalent to a call to <font face="sans-serif"> MPI_COMM_SPLIT(comm, color, key, newcomm)</font>, where processes  
that are members of their <font face="sans-serif"> group</font> argument provide  
<font face="sans-serif"> color</font><I>~=~</I>number of the <font face="sans-serif"> group</font>  
(based on a unique numbering of all disjoint groups) and   
<font face="sans-serif"> key</font><I>~=~</I>rank in <font face="sans-serif"> group</font>, and  
all processes that are not members of their <font face="sans-serif"> group</font> argument provide   
<font face="sans-serif"> color</font><I>~=~</I><font face="sans-serif"> MPI_UNDEFINED</font>.  
<font color="black">  
  
  
The value of <font face="sans-serif"> color</font> must be <font color="red">non-negative<font color="black">.  
  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
This is an extremely powerful mechanism for dividing a single  
communicating  group of processes into <I>k</I> subgroups, with <I>k</I> chosen  
implicitly by the user (by the number of  
colors asserted over all the processes).  Each resulting communicator will be  
non-overlapping.  Such a division could be useful for defining a hierarchy  
of computations, such as for multigrid, or linear algebra.  
<font color="red">  
For intracommunicators, <font face="sans-serif"> MPI_COMM_SPLIT</font> provides similar capability as <font face="sans-serif"> MPI_COMM_CREATE</font>   
to split a communicating group into disjoint subgroups. <font face="sans-serif"> MPI_COMM_SPLIT</font> is useful   
when some processes do not have complete information of the other members in their   
group, but all processes know (the color of) the group to which they belong.   
In this case, the MPI implementation discovers the other group members via   
communication. <font face="sans-serif"> MPI_COMM_CREATE</font> is useful when all processes have complete   
information of the members of their group. In this case, MPI can avoid the extra   
communication required to discover group membership.   
<font color="black">  
<P> 
Multiple calls to <font face="sans-serif"> MPI_COMM_SPLIT</font> can be used to overcome the  
requirement that any call have no overlap of the resulting communicators (each  
process is of only one color per call).  In this way, multiple overlapping  
communication structures can be created.  Creative use of the <font face="sans-serif"> color</font>  
and <font face="sans-serif"> key</font> in such splitting operations is encouraged.  
<P> 
Note that, for a fixed color, the keys need not  
be unique.  It is <font face="sans-serif"> MPI_COMM_SPLIT</font>'s responsibility to sort processes  
in ascending order according to this key, and to break ties in a consistent  
way.  If all the keys are specified in the same way, then all the processes  
in a given color will have the relative rank order as they did in their  
parent group.    
  
Essentially, making the key value zero for all processes of a given color  
means that one doesn't really care about the rank-order of the processes in  
the new communicator.  
 (<em> End of advice to users.</em>) <BR> 
  
 
<BR> 
<em> Rationale.</em>  
<P> 
<font face="sans-serif"> color</font> is restricted to be <font color="red">non-negative<font color="black">, so as not to confict with the value assigned to <font face="sans-serif">  MPI_UNDEFINED</font>.  
 (<em> End of rationale.</em>) <BR> 
  
  
 The result of <font face="sans-serif"> MPI_COMM_SPLIT</font> on an intercommunicator is that those  
processes on the left with the same <font face="sans-serif"> color</font> as those processes on  
the right combine to create a new intercommunicator.  The <font face="sans-serif"> key</font>  
argument describes the relative rank of processes on each side of the  
intercommunicator (see Figure <a href="node134.htm#Figure14">14 
</a>).  For those colors  
that are specified only on one side of the intercommunicator,  
<font face="sans-serif">  MPI_COMM_NULL</font> is returned.  <font face="sans-serif">  MPI_COMM_NULL</font>   
is also returned to those processes that specify <font face="sans-serif">  MPI_UNDEFINED</font>  
as the color.  
<font color="red">  
 
<BR> 
<em> Advice to users.</em>  
<P> 
For intercommunicators, <font face="sans-serif"> MPI_COMM_SPLIT</font> is more general than <font face="sans-serif"> MPI_COMM_CREATE</font>.   
A single call to <font face="sans-serif"> MPI_COMM_SPLIT</font> can create a set of disjoint intercommunicators,   
while a call to <font face="sans-serif"> MPI_COMM_CREATE</font> creates only one.  
 (<em> End of advice to users.</em>) <BR> 
<font color="black">  
<P> 
<P> 
  <CENTER><P><IMG WIDTH=293 HEIGHT=431 SRC="collective-split2.gif"><P>
</CENTER>  
  <BR> 
<b>Figure 14: </b><A NAME="Figure14">Intercommunicator construction achieved by splitting an
    existing intercommunicator with <font face="sans-serif"> MPI_COMM_SPLIT</font>
extended to intercommunicators.</a><P> 
  
    
<BR><b> Example</b>(Parallel client-server model).  
The following client code illustrates how clients on the left side of an  
intercommunicator could be assigned to a single server from a pool of  
servers on the right side of an intercommunicator.  
  
  
  
<BR> 
<pre><tt>        /* Client code */ 
        MPI_Comm  multiple_server_comm; 
        MPI_Comm  single_server_comm; 
        int       color, rank, num_servers; 
         
        /* Create intercommunicator with clients and servers:  
           multiple_server_comm */ 
        ... 
         
        /* Find out the number of servers available */ 
        MPI_Comm_remote_size ( multiple_server_comm, &amp;num_servers ); 
         
        /* Determine my color */ 
        MPI_Comm_rank ( multiple_server_comm, &amp;rank ); 
        color = rank % num_servers; 
         
        /* Split the intercommunicator */ 
        MPI_Comm_split ( multiple_server_comm, color, rank,  
                         &amp;single_server_comm ); 
</tt></pre> 
 The following is the corresponding server code:  
<BR> 
<pre><tt>        /* Server code */ 
        MPI_Comm  multiple_client_comm; 
        MPI_Comm  single_server_comm; 
        int       rank; 
 
        /* Create intercommunicator with clients and servers:  
           multiple_client_comm */ 
        ... 
         
        /* Split the intercommunicator for a single server per group 
           of clients */ 
        MPI_Comm_rank ( multiple_client_comm, &amp;rank ); 
        MPI_Comm_split ( multiple_client_comm, rank, 0,  
                         &amp;single_server_comm );   
</tt></pre> 
  
  

<P>
<HR>
<A HREF="node133.htm#Node133"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node132.htm#Node132"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node135.htm#Node135"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node132.htm#Node132"> Communicator Management</a>
<b>Next: </b><A HREF="node135.htm#Node135"> Communicator Destructors</a>
<b>Previous: </b><A HREF="node133.htm#Node133"> Communicator Accessors</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
