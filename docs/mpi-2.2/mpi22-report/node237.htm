<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-one-side/one-side-2.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Accumulate Functions</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node237">222. Accumulate Functions</a></H2>
<A HREF="node236.htm#Node236"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node233.htm#Node233"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node238.htm#Node238"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node233.htm#Node233"> Communication Calls</a>
<b>Next: </b><A HREF="node238.htm#Node238"> Synchronization Calls</a>
<b>Previous: </b><A HREF="node236.htm#Node236"> Examples</a>
<P>
  
<P> 
It is often useful in a put operation to combine the data moved to the  
target process with the data that resides at that process, rather   
then replacing the data there.  This will allow, for example, the  
accumulation of   
a sum by having all involved processes add their contribution to the  
sum variable in the memory of one process.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_ACCUMULATE(origin_addr, origin_count, origin_datatype, target_rank, target_disp, target_count,  
target_datatype, op, win)</TD></TR>  
<TR><TD> IN origin_addr</TD><TD>initial address of buffer (choice)</TD></TR> <TR><TD> IN origin_count</TD><TD>number of entries in buffer (<font color="red">non-negative<font color="black">  
integer)</TD></TR>  
<TR><TD> IN origin_datatype</TD><TD>datatype of each buffer entry (handle)</TD></TR> <TR><TD> IN target_rank</TD><TD>rank of target (<font color="red">non-negative<font color="black"> integer)</TD></TR> <TR><TD> IN target_disp</TD><TD>displacement from start of window to beginning  
of target buffer (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> IN target_count</TD><TD>number of entries in target buffer  
(<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> IN target_datatype</TD><TD>datatype of each entry in target buffer  
(handle)</TD></TR>  
<TR><TD> IN op</TD><TD>reduce operation (handle)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Accumulate(void *origin_addr, int origin_count, MPI_Datatype origin_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype,  MPI_Op op, MPI_Win win) <BR></tt>  
<P> 
 <tt> MPI_ACCUMULATE(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE,  OP, WIN, IERROR) <BR> &lt;type&gt; ORIGIN_ADDR(*) <BR>INTEGER(KIND=MPI_ADDRESS_KIND) TARGET_DISP <BR>INTEGER ORIGIN_COUNT, ORIGIN_DATATYPE,TARGET_RANK, TARGET_COUNT, TARGET_DATATYPE,  OP, WIN, IERROR <BR></tt>  
<P> 
 <font color="red">{<font color="black"> void MPI::Win::Accumulate(const void* origin_addr, int origin_count, const MPI::Datatype&amp; origin_datatype, int target_rank, MPI::Aint target_disp, int target_count, const MPI::Datatype&amp; target_datatype, const MPI::Op&amp; op) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
Accumulate the contents of the origin buffer  
(as defined by <font face="sans-serif"> origin_addr</font>, <font face="sans-serif"> origin_count</font> and  
<font face="sans-serif"> origin_datatype</font>)  
to the buffer specified by arguments <font face="sans-serif"> target_count</font> and  
<font face="sans-serif"> target_datatype</font>,  
at offset <font face="sans-serif"> target_disp</font>, in  
the target window specified by <font face="sans-serif"> target_rank</font> and <font face="sans-serif"> win</font>,  
using the operation   
<font face="sans-serif"> op</font>.  
This is like <font face="sans-serif"> MPI_PUT</font> except that data is combined into  
the target area instead of overwriting it.  
<P> 
Any of the predefined operations for <font face="sans-serif"> MPI_REDUCE</font> can be  
used. User-defined functions cannot be used.  
For example, if <font face="sans-serif"> op</font> is <font face="sans-serif"> MPI_SUM</font>,  
each element of the origin buffer is added to the corresponding element  
in the target, replacing the former value in the target.  
<P> 
Each datatype argument must be a predefined datatype or a derived  
datatype, where all basic components are of the same predefined  
datatype.  Both datatype arguments must be constructed from the same  
predefined datatype.  
The operation <font face="sans-serif"> op</font> applies to elements of that predefined  
type. <font face="sans-serif"> target_datatype</font> must not specify overlapping   
entries, and the target buffer must fit in the target window.  
<P> 
A new predefined operation, <font face="sans-serif">  MPI_REPLACE</font>, is defined.    
It corresponds to the associative function <I>f(a,b) = b</I>; i.e., the current  
value in the target memory is replaced by the value supplied by the  
origin.  
<P> 
  
2.2  
<P> 
<font color="red">  
<font face="sans-serif">  MPI_REPLACE</font> can be used only in <font face="sans-serif"> MPI_ACCUMULATE</font>,   
not in collective reduction operations, such as <font face="sans-serif"> MPI_REDUCE</font>  
and others.  
<font color="black">  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_PUT</font> is a special case of <font face="sans-serif"> MPI_ACCUMULATE</font>,  
with the  operation <font face="sans-serif">  MPI_REPLACE</font>.  
Note, however, that <font face="sans-serif"> MPI_PUT</font> and <font face="sans-serif"> MPI_ACCUMULATE</font>  
have different constraints on concurrent updates.  
 (<em> End of advice to users.</em>) <BR> 
<BR><b> Example</b>  
  
We want to compute <IMG WIDTH=100 HEIGHT=12 SRC="img137.gif">
.  The arrays  
<tt> A, B</tt> and <tt> map</tt> are distributed in the same manner.  We write  
the simple version.  
<P> 
  
2.2  
<P> 
<font color="red">  
<BR> 
<pre><tt>SUBROUTINE SUM(A, B, map, m, comm, p) 
USE MPI 
INTEGER m, map(m), comm, p, win, ierr 
REAL A(m), B(m) 
INTEGER (KIND=MPI_ADDRESS_KIND) lowerbound, sizeofreal 
 
CALL MPI_TYPE_GET_EXTENT(MPI_REAL, lowerbound, sizeofreal, ierr) 
CALL MPI_WIN_CREATE(B, m*sizeofreal, sizeofreal, MPI_INFO_NULL,  &amp; 
                    comm, win, ierr) 
 
CALL MPI_WIN_FENCE(0, win, ierr) 
DO i=1,m 
  j = map(i)/m 
  k = MOD(map(i),m) 
  CALL MPI_ACCUMULATE(A(i), 1, MPI_REAL, j, k, 1, MPI_REAL,   &amp; 
                      MPI_SUM, win, ierr) 
END DO 
CALL MPI_WIN_FENCE(0, win, ierr) 
 
CALL MPI_WIN_FREE(win, ierr) 
RETURN 
END 
</tt></pre> 
<font color="black">  
<P> 
This code is identical to the code in  
Example <a href="node236.htm#Node236">Examples 
</a>, page <a href="node236.htm#Node236">Examples 
</a>,  
except that a call to get has been  
replaced by a call to accumulate.  (Note that, if <tt> map</tt> is  
one-to-one, then the code computes <I> B = A(map<SUP>-1</SUP>)</I>, which is the  
reverse assignment to the one computed in that previous example.)  
In a similar manner, we can replace  
in Example <a href="node236.htm#Node236">Examples 
</a>,  
page <a href="node236.htm#Node236">Examples 
</a>,  
the call to get by a call to accumulate,  
thus  
performing the computation with only one communication between any  
two processes.  
   
<P> 

<P>
<HR>
<A HREF="node236.htm#Node236"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node233.htm#Node233"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node238.htm#Node238"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node233.htm#Node233"> Communication Calls</a>
<b>Next: </b><A HREF="node238.htm#Node238"> Synchronization Calls</a>
<b>Previous: </b><A HREF="node236.htm#Node236"> Examples</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
