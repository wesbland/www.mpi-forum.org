<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-terms/terms-2.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>C++ Binding Issues</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node32">32. C++ Binding Issues</a></H2>
<A HREF="node31.htm#Node31"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node28.htm#Node28"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node33.htm#Node33"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node28.htm#Node28"> Language Binding</a>
<b>Next: </b><A HREF="node33.htm#Node33"> Functions and Macros</a>
<b>Previous: </b><A HREF="node31.htm#Node31"> C Binding Issues</a>
<P>
  
<P> 
<font color="red">The C++ language bindings have been deprecated.<font color="black">  
  
There are places in the standard that give rules for C and not  
for C++.  In these cases, the C rule should be applied to the C++  
case, as appropriate.  In particular, the values of constants given in  
the text are the ones for C and Fortran.  A cross index of these with  
the C++ names is given in Annex <a href="node373.htm#Node373">Language Bindings Summary 
</a>.  
  
<P> 
We use the   
ISO C++   
declaration format.  All <font face="sans-serif"> MPI</font> names are declared  
within the scope of a namespace called <tt>MPI</tt> and therefore are  
referenced with an <tt> MPI::</tt> prefix.  Defined constants are in all  
capital letters, and class names, defined types, and functions have  
only their first letter capitalized.  Programs must not declare  
variables or functions in the <tt>MPI</tt> namespace.  This is mandated  
to avoid possible name collisions.  
<P> 
The definition of named constants, function prototypes, and type  
definitions must be supplied in an include file <font face="sans-serif"> mpi.h</font>.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
  
The file <font face="sans-serif"> mpi.h</font> may contain both the C and C++ definitions.  
  
Usually one can simply use the defined value (generally <tt> __cplusplus</tt>,  
but not required) to see if one is using  
C++ to protect the C++ definitions.  It is possible that a C compiler  
will require that the source protected this way be legal C code.  In  
this case, all the C++ definitions can be placed in a different  
include file and the ``<tt>#include</tt>'' directive can be used to include the  
necessary C++ definitions in the <font face="sans-serif"> mpi.h</font> file.  
 (<em> End of advice to implementors.</em>) <BR> 
C++ functions that create objects or return information usually place  
the object or information in the return value.  Since the language  
neutral prototypes of <font face="sans-serif"> MPI</font> functions include the C++ return value as  
an <font face="sans-serif">  OUT</font> parameter, semantic descriptions of <font face="sans-serif"> MPI</font> functions refer to  
the C++ return value by that parameter   
name.  
The remaining C++ functions return <tt> void</tt>.  
<P> 
  
In some circumstances, <font face="sans-serif"> MPI</font> permits users to indicate that they do  
not want a return value.  For example, the user may indicate that the  
status is not filled in.  Unlike C and Fortran where this is achieved  
through a special input value, in C++ this is done by having two  
bindings where one has the optional argument and one does not.  
  
<P> 
C++ functions do not return error codes.  If the default error handler  
has been set to <font face="sans-serif">  MPI::ERRORS_THROW_EXCEPTIONS</font>, the C++  
exception mechanism is used to signal an error by  
throwing an   
  
<font face="sans-serif">  MPI::Exception</font>  
  
object.  
<P> 
It should be noted that the default error handler  
(i.e., <font face="sans-serif">  MPI::ERRORS_ARE_FATAL</font>) on a given type has not  
changed.  User error handlers are also permitted.  
<font face="sans-serif">  MPI::ERRORS_RETURN</font> simply returns control to the calling  
function; there is no provision for the user to retrieve the error  
code.  
<P> 
User callback functions that return integer error codes should not  
throw exceptions; the returned error will be handled by the <font face="sans-serif"> MPI</font>  
implementation by invoking the appropriate error handler.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
C++ programmers that want to handle <font face="sans-serif"> MPI</font> errors on their own should  
use the <font face="sans-serif">  MPI::ERRORS_THROW_EXCEPTIONS</font> error handler, rather  
than <font face="sans-serif">  MPI::ERRORS_RETURN</font>, that is used for that purpose in  
C.  Care should be taken using exceptions in mixed language  
situations.  
 (<em> End of advice to users.</em>) <BR> 
Opaque object handles must be objects in themselves, and have the  
assignment and equality operators overridden to perform semantically  
like their C and Fortran counterparts.  
<P> 
Array arguments are indexed from zero.  
<P> 
Logical flags are of type <tt> bool</tt>.  
<P> 
Choice arguments are pointers of type <tt> void *</tt>.  
<P> 
Address arguments are of <font face="sans-serif"> MPI</font>-defined integer type <font face="sans-serif"> MPI::Aint</font>,  
defined to be an integer of the size needed to hold any valid address  
on the target architecture.  
  
Analogously, <font face="sans-serif"> MPI::Offset</font> is an integer to hold file offsets.  
  
<P> 
Most <font face="sans-serif"> MPI</font> functions are methods of <font face="sans-serif"> MPI</font> C++ classes.  <font face="sans-serif"> MPI</font> class  
names are generated from the language neutral <font face="sans-serif"> MPI</font> types by dropping  
the <tt> MPI_</tt> prefix and scoping the type within the  
<tt>MPI</tt> namespace.  For example, <font face="sans-serif"> MPI_DATATYPE</font> becomes   
<tt> MPI::Datatype</tt>.  
<P> 
  
The names of   
<font face="sans-serif"> MPI</font>   
functions generally follow the naming rules  
given.  In some circumstances, the   
<font face="sans-serif"> MPI</font> function is related to a function defined already for <font face="sans-serif"> MPI-1</font>  
with a name that does not follow the naming  
conventions.  In this circumstance, the language neutral name is in  
analogy to the   
<font face="sans-serif"> MPI</font>   
name even though this gives an <font face="sans-serif"> MPI-2</font> name that  
violates the naming conventions.  The C and Fortran names are the same  
as the language neutral name in this case.  However, the C++   
names   
do reflect the naming rules and can differ from the C and  
Fortran names.  Thus, the analogous name in C++ to the   
<font face="sans-serif"> MPI</font> name may be  
different than the language neutral name.  This results in the C++  
name differing from the language neutral name.  An example of this is  
the language neutral name of <font face="sans-serif"> MPI_FINALIZED</font> and a C++ name  
of <font face="sans-serif"> MPI::Is_finalized</font>.  
  
<P> 
  
In C++, function <tt> typedef</tt>s are made publicly within appropriate  
classes.  However, these declarations then become somewhat cumbersome,  
as with the following:  
<P> 
 <font color="red">{<font color="black"><tt> typedef MPI::Grequest::Query_function(); <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em>}<font color="black"><BR></tt>  
<P> 
  
would look like the following:  
<P> 
<BR> 
<pre><tt>namespace MPI { 
  class Request { 
    // ... 
  }; 
 
  class Grequest : public MPI::Request { 
    // ... 
    typedef Query_function(void* extra_state, MPI::Status&amp; status); 
  }; 
}; 
</tt></pre> 
Rather than including this scaffolding when declaring   
C++ <tt> typedef</tt>s, we use an abbreviated form.  In  
particular, we explicitly indicate the class and namespace scope for  
the <tt> typedef</tt> of the function.  Thus, the example above is  
shown in the text as follows:  
<BR> 
<pre><tt>typedef int MPI::Grequest::Query_function(void* extra_state, 
                                          MPI::Status&amp; status) 
</tt></pre> 
  
<P> 
The C++ bindings presented in Annex <a href="node411.htm#Node411">C++ Bindings (deprecated) 
</a>  
and throughout this document were generated by applying a simple set  
of name generation rules to the <font face="sans-serif"> MPI</font> function specifications.  While  
these guidelines may be sufficient in most cases, they may not be  
suitable for all situations.  In cases of ambiguity or where a  
specific semantic statement is desired, these guidelines may be  
superseded as the situation dictates.  
<P> 
<ol> 
 
1. All functions, types, and constants are declared within the  
  scope of a <tt>namespace</tt> called <tt>MPI</tt>.  
  <P> 
 
<BR> 
2. Arrays of <font face="sans-serif"> MPI</font> handles are always left in the argument list  
  (whether they are <font face="sans-serif">  IN</font> or <font face="sans-serif">  OUT</font> arguments).  
<P> 
 
<BR> 
3. If the argument list of an <font face="sans-serif"> MPI</font> function contains a scalar <font face="sans-serif">  IN</font>  
  handle, and it makes sense to define the function as a method of the  
  object corresponding to that handle, the function is made a member  
  function of the corresponding <font face="sans-serif"> MPI</font> class.  
  The member functions are named according to the corresponding <font face="sans-serif"> MPI</font>  
  function name, but without the ``<tt> MPI_</tt>'' prefix and without  
  the object name prefix (if applicable).  In addition:  
<P> 
<ol> 
   
1. The scalar <font face="sans-serif">  IN</font> handle is dropped from the argument list, and  
    <tt> this</tt> corresponds to the dropped argument.  
<P> 
 
<BR> 
2. The function is declared <tt> const</tt>.  
  </ol> 
 
<BR> 
4. <font face="sans-serif"> MPI</font> functions are made into class functions (static) when they  
belong on a class but do not have a unique scalar <font face="sans-serif">  IN</font> or <font face="sans-serif">  INOUT</font>  
parameter of that class.  
<P> 
 
<BR> 
5. If the argument list contains a single <font face="sans-serif">  OUT</font> argument that is  
  not of type <font face="sans-serif"> MPI_STATUS</font> (or an array), that argument is  
  dropped from the list and the function returns that value.  
<P> 
<BR><b> Example</b>  
    The C++ binding for <font face="sans-serif"> MPI_COMM_SIZE</font> is  
    <font face="sans-serif"> int MPI::Comm::Get_size(void) const</font>.  
    
<P> 
 
<BR> 
6. If there are multiple <font face="sans-serif">  OUT</font> arguments in the argument list, one  
  is chosen as the return value and is removed from the list.  
<P> 
 
<BR> 
7. If the argument list does not contain any <font face="sans-serif">  OUT</font> arguments,  
  the function returns <tt> void</tt>.  
<P> 
<BR><b> Example</b>  
    The C++ binding for <font face="sans-serif"> MPI_REQUEST_FREE</font> is   
    <font face="sans-serif"> void MPI::Request::Free(void)</font>  
    
<P> 
 
<BR> 
8. <font face="sans-serif"> MPI</font> functions to which the above rules do not apply are not  
  members of any class, but are defined in the <tt>MPI</tt> namespace.  
<P> 
<BR><b> Example</b>  
    The C++ binding for <font face="sans-serif"> MPI_BUFFER_ATTACH</font> is  
    <font face="sans-serif"> void MPI::Attach_buffer(void* buffer, int size)</font>.  
    
<P> 
 
<BR> 
9. All class names, defined types, and function names have only  
  their first letter capitalized.  Defined constants are in all  
  capital letters.  
<P> 
 
<BR> 
10. Any <font face="sans-serif">  IN</font> pointer, reference, or array argument must be declared  
  <tt> const</tt>.  
  <P> 
 
<BR> 
11. Handles are passed by reference.  
  <P> 
 
<BR> 
12. Array arguments are denoted with square brackets (<tt> []</tt>), not  
  pointers, as this is more semantically precise.  
</ol> 
  

<P>
<HR>
<A HREF="node31.htm#Node31"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node28.htm#Node28"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node33.htm#Node33"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node28.htm#Node28"> Language Binding</a>
<b>Next: </b><A HREF="node33.htm#Node33"> Functions and Macros</a>
<b>Previous: </b><A HREF="node31.htm#Node31"> C Binding Issues</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
