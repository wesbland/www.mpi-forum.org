<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Communication Modes</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node53">52. Communication Modes</a></H1>
<A HREF="node52.htm#Node52"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node54.htm#Node54"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node54.htm#Node54"> Semantics of Point-to-Point Communication</a>
<b>Previous: </b><A HREF="node52.htm#Node52"> Data Conversion</a>
<P>
  
The send call described in Section <a href="node43.htm#Node43">Blocking Send 
</a>  
is <b> blocking</b>:  
it does not return until the message data  
and envelope have been safely stored away so that the sender is  
free to <font color="red">modify<font color="black">  
the send buffer.  
The message might be copied directly into the matching receive buffer,  
or it might be copied into a temporary system buffer.  
<P> 
Message buffering  
decouples the send and receive operations.  A blocking send can  
complete as soon  
as the message was buffered, even if no matching receive has been executed  
by the receiver.   On the other hand, message buffering can be expensive,  
as it entails additional memory-to-memory copying, and it requires the  
allocation of memory for buffering.  <font face="sans-serif"> MPI</font> offers the choice of  
several communication modes that allow one to control the choice of the  
communication protocol.  
<P> 
The send call described in Section <a href="node43.htm#Node43">Blocking Send 
</a>  
uses   
the <b> standard</b> communication mode.  In this mode,  
it is up to <font face="sans-serif"> MPI</font> to decide whether outgoing  
messages will be buffered.  <font face="sans-serif"> MPI</font> may  
buffer outgoing messages.  In such a case, the send call may complete  
before a matching receive is invoked.  On the other hand, buffer space may be  
unavailable, or <font face="sans-serif"> MPI</font> may choose not to buffer  
outgoing messages, for performance reasons. In this case,  
the send call will not complete until a matching receive has been posted, and  
the data has been moved to the receiver.  
<P> 
Thus, a send in standard mode can be started whether or not a  
matching receive has been posted.  It may complete before a matching receive  
is posted.  The  
standard mode send is <b> non-local</b>:  successful completion of the send  
operation may depend on the occurrence of a matching receive.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The reluctance of <font face="sans-serif"> MPI</font> to mandate whether standard sends are buffering  
or not stems from the desire to achieve portable programs.  Since any  
system will run out of buffer resources as message sizes are increased,  
and some implementations may want to provide little buffering, <font face="sans-serif"> MPI</font>  
takes the position that correct (and therefore, portable) programs  
do not rely on system buffering in standard mode.  Buffering  
may improve the performance  
of a correct program, but it doesn't affect the result of the program.  
If the user wishes to guarantee a certain amount of buffering, the  
user-provided buffer system of Section <a href="node55.htm#Node55">Buffer Allocation and Usage 
</a> should be used,  
along with the buffered-mode send.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
There are three additional communication modes.  
<P> 
A <b> buffered</b> mode send operation can be started whether or not a  
matching receive has been posted.  
It may complete before a matching receive is posted.  However, unlike  
the standard send, this operation is <b> local</b>, and its  
completion does not depend on the occurrence of a matching receive.  Thus, if a  
send is executed and no matching receive is posted, then <font face="sans-serif"> MPI</font> must buffer the  
outgoing message, so as to allow the send call to complete.   An error will  
occur if there is insufficient buffer space.   The amount of available buffer  
space is controlled by the user --- see Section <a href="node55.htm#Node55">Buffer Allocation and Usage 
</a>.  
Buffer allocation by the user may be required for the buffered mode to be  
effective.  
<P> 
A send that uses the <b> synchronous</b> mode can be started whether or  
not a matching receive was posted.  However, the send will complete  
successfully only if a matching receive is posted, and the  
receive operation has started to receive the message sent by the  
synchronous send.  
Thus, the completion of a synchronous send not only indicates that the  
send buffer can be reused, but   
it   
also indicates that the receiver has  
reached a certain point in its execution, namely that it has started  
executing the matching receive.  If both sends and receives are  
blocking operations then the use of the synchronous mode provides  
synchronous communication semantics: a communication does not complete  
at either end before both processes rendezvous at the  
communication.  A send executed in this mode is <b> non-local</b>.  
<P> 
A send that uses the <b> ready</b> communication mode  
may be started <em> only</em> if the matching receive is already posted.  
Otherwise, the operation is erroneous and its outcome is undefined.  
On some systems, this allows the removal of a hand-shake  
operation that is otherwise required and results in improved  
performance.  
The completion of the send operation does not depend on the  
status of a matching receive, and merely indicates that the send  
buffer can be reused.   A send operation that uses the ready mode has  
the same semantics as a standard send operation, or a synchronous send  
operation; it is merely that the sender provides additional  
information to the system (namely that a matching receive is already  
posted), that can save some overhead.  In a correct program, therefore, a  
ready send could be replaced by a standard send with no effect on the  
behavior of the program other than performance.  
<P> 
Three additional send functions are provided for the three additional  
communication  
modes.  The communication mode is indicated by a one letter prefix:  
<font face="sans-serif"> B</font> for buffered,  
<font face="sans-serif"> S</font> for synchronous, and  
<font face="sans-serif"> R</font> for ready.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BSEND (buf, count, datatype, dest, tag, comm)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in send buffer (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each send buffer element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Bsend(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) <BR></tt>  
<P> 
 <tt> MPI_BSEND(BUF, COUNT, DATATYPE, DEST, TAG, COMM, IERROR)<BR> &lt;type&gt; BUF(*) <BR>INTEGER  COUNT, DATATYPE, DEST, TAG, COMM, IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Comm::Bsend(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Send in buffered mode.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SSEND (buf, count, datatype, dest, tag, comm)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in send buffer (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each send buffer element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Ssend(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) <BR></tt>  
<P> 
 <tt> MPI_SSEND(BUF, COUNT, DATATYPE, DEST, TAG, COMM, IERROR)<BR> &lt;type&gt; BUF(*) <BR>INTEGER  COUNT, DATATYPE, DEST, TAG, COMM, IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Comm::Ssend(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Send in synchronous mode.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_RSEND (buf, count, datatype, dest, tag, comm)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in send buffer (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each send buffer element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Rsend(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) <BR></tt>  
<P> 
 <tt> MPI_RSEND(BUF, COUNT, DATATYPE, DEST, TAG, COMM, IERROR)<BR> &lt;type&gt; BUF(*) <BR>INTEGER  COUNT, DATATYPE, DEST, TAG, COMM, IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Comm::Rsend(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Send in ready mode.  
<P> 
There is only one receive operation,   
but it matches  
any of the send modes.  
The receive operation described in the last section is <b> blocking</b>:  
it returns only after the receive buffer contains the newly received  
message.   A receive can complete before the matching send  
has completed (of course, it can complete only after the matching send  
has started).  
<P> 
In a multi-threaded implementation of <font face="sans-serif"> MPI</font>, the system may de-schedule a  
thread that is blocked on a send or receive  
operation, and schedule another thread for execution in the same  
address space.  
In such a case it is the user's responsibility not to   
modify a  
communication  
buffer until the communication completes.  
Otherwise, the outcome of the computation is undefined.  
<P> 
  
2.2  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Since a synchronous send cannot complete before a matching receive is posted,  
one will not normally buffer messages sent by such an operation.  
<P> 
It is recommended to choose buffering over blocking the sender, whenever  
possible, for standard sends.  The programmer can signal his or her preference  
for blocking the sender until a matching receive occurs by using the  
synchronous send mode.  
<P> 
A possible communication protocol for the various communication modes  
is outlined below.  
<P> 
<font face="sans-serif"> ready send</font>:   The message is sent as soon as possible.  
<P> 
<font face="sans-serif"> synchronous send:</font>  
The sender sends a request-to-send message.  
The receiver stores this request.  
When a matching receive is posted, the receiver sends back a permission-to-send  
message, and the sender now sends the message.  
<P> 
<font face="sans-serif"> standard send:</font>  
First protocol may be used for short messages, and second protocol for  
long messages.  
<P> 
<font face="sans-serif"> buffered send:</font>  
The sender copies the message into a buffer and then sends it with a  
nonblocking send (using the same protocol as for standard send).  
<P> 
Additional control messages might be needed for flow control and error  
recovery.  Of course, there are many other possible protocols.  
<P> 
Ready send can be implemented as a standard send. In this case  
there will be no performance advantage (or disadvantage) for the use of  
ready send.  
<P> 
A standard send can be implemented as a synchronous send.  
In such a case, no data buffering is needed.  However,   
users may  
expect some buffering.  
<P> 
In a multi-threaded environment, the execution of a blocking communication  
should block only the executing thread, allowing the thread scheduler to  
de-schedule this thread and schedule another thread for execution.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node52.htm#Node52"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node54.htm#Node54"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node54.htm#Node54"> Semantics of Point-to-Point Communication</a>
<b>Previous: </b><A HREF="node52.htm#Node52"> Data Conversion</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
