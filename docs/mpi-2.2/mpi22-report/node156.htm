<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-context/context.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Naming Objects</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node156">152. Naming Objects</a></H1>
<A HREF="node155.htm#Node155"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node157.htm#Node157"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node157.htm#Node157"> Formalizing the Loosely Synchronous Model</a>
<b>Previous: </b><A HREF="node155.htm#Node155"> Attributes Example</a>
<P>
  
  
  
There are many occasions on which it would be useful to allow a user  
to associate a printable identifier with an <font face="sans-serif"> MPI</font> communicator, window, or  
datatype, for instance error reporting, debugging, and profiling.    
  
The names attached to opaque objects do not propagate when the object  
is duplicated or copied by <font face="sans-serif"> MPI</font> routines.  
  
For communicators this can be achieved using the following two  
functions.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_SET_NAME (comm, comm_name)</TD></TR>  
<TR><TD> INOUT comm</TD><TD>communicator whose identifier is to be set (handle)</TD></TR>  
<TR><TD> IN comm_name</TD><TD>the character string which is remembered as  
the name (string)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_set_name(MPI_Comm comm, char *comm_name) <BR></tt>  
<P> 
 <tt> MPI_COMM_SET_NAME(COMM, COMM_NAME, IERROR) <BR> INTEGER COMM, IERROR<BR>CHARACTER*(*) COMM_NAME <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> void MPI::Comm::Set_name(const char* comm_name) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
<font face="sans-serif"> MPI_COMM_SET_NAME</font> allows a user to associate a name  
string with a communicator. The character string which is passed to  
<font face="sans-serif"> MPI_COMM_SET_NAME</font> will be saved inside the MPI  
library (so it can be freed by the caller immediately after the call, or  
allocated on the stack).    
Leading spaces in <font face="sans-serif"> name</font> are  
significant but trailing ones are not.  
<P> 
<font face="sans-serif"> MPI_COMM_SET_NAME</font> is a local (non-collective) operation,   
which only affects the name of the communicator as seen in the process  
which made the <font face="sans-serif"> MPI_COMM_SET_NAME</font> call. There is no  
requirement that the same (or any) name be assigned to a communicator  
in every process where it exists.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Since <font face="sans-serif"> MPI_COMM_SET_NAME</font> is provided to help debug code, it  
is sensible to give the same name to a communicator in all of the  
processes where it exists, to avoid confusion.  
 (<em> End of advice to users.</em>) <BR> 
  
The length of the name which can be stored is limited to the value of  
<font face="sans-serif">  MPI_MAX_OBJECT_NAME</font> in Fortran and   
<font face="sans-serif">  MPI_MAX_OBJECT_NAME</font>-1 in C and C++ to allow for the null terminator.  
  
Attempts to put names longer than this  
will result in truncation of the name.   
  
<font face="sans-serif">  MPI_MAX_OBJECT_NAME</font> must have a value of at least 64.   
  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Under circumstances of store exhaustion an attempt to put a  
name of any length could fail, therefore the value of  
  
<font face="sans-serif">  MPI_MAX_OBJECT_NAME</font> should be viewed only as a strict upper  
  
bound on the name length, not a guarantee that setting names of less  
than this length will always succeed.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Implementations which pre-allocate a fixed size space for a name  
should use the length of that allocation as the value of  
  
<font face="sans-serif">  MPI_MAX_OBJECT_NAME</font>.   
Implementations which allocate space for the name from the heap should  
still define <font face="sans-serif">  MPI_MAX_OBJECT_NAME</font> to be a relatively small  
value, since the user has to allocate space for a string of up to this  
size when calling <font face="sans-serif"> MPI_COMM_GET_NAME</font>.  
  
 (<em> End of advice to implementors.</em>) <BR> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_GET_NAME (comm, comm_name, resultlen)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator whose name is to be returned (handle)</TD></TR>  
<TR><TD> OUT comm_name</TD><TD>the name previously stored on the communicator, or an empty string if no such name exists (string)</TD></TR>  
<TR><TD> OUT resultlen</TD><TD>length of returned name (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_get_name(MPI_Comm comm, char *comm_name, int *resultlen) <BR></tt>  
<P> 
 <tt> MPI_COMM_GET_NAME(COMM, COMM_NAME, RESULTLEN, IERROR) <BR> INTEGER COMM, RESULTLEN, IERROR<BR>CHARACTER*(*) COMM_NAME <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> void MPI::Comm::Get_name(char* comm_name, int&amp; resultlen) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
<font face="sans-serif"> MPI_COMM_GET_NAME</font> returns the last name which has previously been  
associated with the given communicator.  The name may be set and got  
from any language.  The same name will be returned independent of the  
language used.    
  
<font face="sans-serif"> name</font> should be allocated so that it can hold a resulting string  
of length <font face="sans-serif">  MPI_MAX_OBJECT_NAME</font> characters.  
  
<font face="sans-serif"> MPI_COMM_GET_NAME</font>  
returns a copy of the set name in <font face="sans-serif"> name</font>.  
   
In C, a null character is additionally stored at <font face="sans-serif"> name[resultlen]</font>.   
<font face="sans-serif"> resultlen</font> cannot be larger then   
<font color="red"><font face="sans-serif">  MPI_MAX_OBJECT_NAME</font><font color="black">-1.   
In Fortran, name is padded on the right with blank characters.   
<font face="sans-serif"> resultlen</font> cannot be larger then   
<font color="red"><font face="sans-serif">  MPI_MAX_OBJECT_NAME</font><font color="black">.   
  
If the user has not associated a name with a communicator, or an error  
occurs, <font face="sans-serif"> MPI_COMM_GET_NAME</font> will return an empty string (all  
spaces in Fortran, <tt> ""</tt> in C and C++).  The three predefined  
communicators will have predefined names associated with them.    
Thus, the names of <font face="sans-serif">  MPI_COMM_WORLD</font>, <font face="sans-serif">  MPI_COMM_SELF</font>, and  
the communicator returned by <font face="sans-serif"> MPI_COMM_GET_PARENT</font>   
(if not <font face="sans-serif">  MPI_COMM_NULL</font>)  
will have the default of <font face="sans-serif">  MPI_COMM_WORLD</font>, <font face="sans-serif">  MPI_COMM_SELF</font>, and <font face="sans-serif">  MPI_COMM_PARENT</font>.  
The fact that the system may have chosen to give a default name to a  
communicator does not prevent the user from setting a name on the same  
communicator; doing this removes the old name and assigns the new one.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
We provide separate functions for setting and getting the name of a  
communicator, rather than simply providing a predefined attribute key   
for the following reasons:  
<ul> 
 
<li>It is not, in general, possible to store a string as an attribute  
from Fortran.  
<P> 
 
<li>It is not easy to set up the delete function for a string  
attribute unless it is known to have been allocated from the heap.  
<P> 
 
<li>To make the attribute key useful additional code to call <tt>  
strdup</tt> is necessary. If this is not standardized then users have  
to write it. This is extra unneeded work which we can easily  
eliminate.  
<P> 
 
<li>The Fortran binding is not trivial to write (it will depend on  
details of the Fortran compilation system), and will not be  
portable. Therefore it should be in the library rather than in user  
code.  
</ul> 
<BR> 
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
The above definition means that it is safe simply to print the string  
returned by <font face="sans-serif"> MPI_COMM_GET_NAME</font>, as it is always a valid  
string even if there was no name.  
<P> 
Note that associating a name with a communicator has no effect on the  
semantics of an <font face="sans-serif"> MPI</font> program, and will (necessarily)  
increase the store requirement of the program, since the names must be  
saved. Therefore there is no requirement that users use these functions to   
associate names with  
communicators. However debugging and profiling <font face="sans-serif"> MPI</font> applications may be made  
easier if names are associated with communicators,  
since the debugger or profiler should then be able to present  
information in a less cryptic manner.  
 (<em> End of advice to users.</em>) <BR> 
The following functions are used for setting and getting names of datatypes.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_SET_NAME (type, type_name)</TD></TR>  
<TR><TD> INOUT type</TD><TD>datatype whose identifier is to be set (handle)</TD></TR>  
<TR><TD> IN type_name</TD><TD>the character string which is remembered as the name (string)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_set_name(MPI_Datatype type, char *type_name) <BR></tt>  
<P> 
 <tt> MPI_TYPE_SET_NAME(TYPE, TYPE_NAME, IERROR) <BR> INTEGER TYPE, IERROR<BR>CHARACTER*(*) TYPE_NAME <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> void MPI::Datatype::Set_name(const char* type_name) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_GET_NAME (type, type_name, resultlen)</TD></TR>  
<TR><TD> IN type</TD><TD>datatype whose name is to be returned (handle)</TD></TR>  
<TR><TD> OUT type_name</TD><TD>the name previously stored on the datatype, or a  
empty string if no such name exists (string)</TD></TR>  
<TR><TD> OUT resultlen</TD><TD>length of returned name (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_get_name(MPI_Datatype type, char *type_name, int *resultlen) <BR></tt>  
<P> 
 <tt> MPI_TYPE_GET_NAME(TYPE, TYPE_NAME, RESULTLEN, IERROR) <BR> INTEGER TYPE, RESULTLEN, IERROR<BR>CHARACTER*(*) TYPE_NAME <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> void MPI::Datatype::Get_name(char* type_name, int&amp; resultlen) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
  
Named predefined datatypes have the default names of the datatype name.    
  
For example, <font face="sans-serif"> MPI_WCHAR</font> has the default name of <font face="sans-serif">  MPI_WCHAR</font>.  
<P> 
The following functions are used for setting and getting names of windows.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_SET_NAME (win, win_name)</TD></TR>  
<TR><TD> INOUT win</TD><TD>window whose identifier is to be set (handle)</TD></TR>  
<TR><TD> IN win_name</TD><TD>the character string which is remembered as the name (string)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_set_name(MPI_Win win, char *win_name) <BR></tt>  
<P> 
 <tt> MPI_WIN_SET_NAME(WIN, WIN_NAME, IERROR) <BR> INTEGER WIN, IERROR<BR>CHARACTER*(*) WIN_NAME <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> void MPI::Win::Set_name(const char* win_name) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_GET_NAME (win, win_name, resultlen)</TD></TR>  
<TR><TD> IN win</TD><TD>window whose name is to be returned (handle)</TD></TR>  
<TR><TD> OUT win_name</TD><TD>the name previously stored on the window, or a  
empty string if no such name exists (string)</TD></TR>  
<TR><TD> OUT resultlen</TD><TD>length of returned name (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_get_name(MPI_Win win, char *win_name, int *resultlen) <BR></tt>  
<P> 
 <tt> MPI_WIN_GET_NAME(WIN, WIN_NAME, RESULTLEN, IERROR) <BR> INTEGER WIN, RESULTLEN, IERROR<BR>CHARACTER*(*) WIN_NAME <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> void MPI::Win::Get_name(char* win_name, int&amp; resultlen) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
   
<P> 

<P>
<HR>
<A HREF="node155.htm#Node155"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node157.htm#Node157"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node157.htm#Node157"> Formalizing the Loosely Synchronous Model</a>
<b>Previous: </b><A HREF="node155.htm#Node155"> Attributes Example</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
