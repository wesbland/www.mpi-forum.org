<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-topol/topol.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Distributed (Graph) Constructor</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node172">165. Distributed (Graph) Constructor</a></H2>
<A HREF="node171.htm#Node171"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node168.htm#Node168"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node173.htm#Node173"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node168.htm#Node168"> Topology Constructors</a>
<b>Next: </b><A HREF="node173.htm#Node173"> Topology Inquiry Functions</a>
<b>Previous: </b><A HREF="node171.htm#Node171"> General (Graph) Constructor</a>
<P>
  
The general graph constructor assumes that each process passes the  
full (global) communication graph to the call. This limits the  
scalability of this constructor. With the distributed graph interface,  
the communication graph is specified in a fully distributed  
fashion. Each process specifies only the part of the communication  
graph of which it is aware. Typically, this could be the set of  
processes from which the process will eventually receive or get data,  
or the set of processes to which the process will send or put data, or  
some combination of such edges.  Two different interfaces can be used  
to create a distributed graph  
topology. <font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> creates a  
distributed graph communicator with each process specifying all of its  
incoming and outgoing (adjacent) edges in the logical communication  
graph and thus requires minimal communication during  
creation. <font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> provides full  
flexibility, and processes can indicate that communication will occur  
between other pairs of processes.  
<P> 
To provide better possibilities for optimization by the <font face="sans-serif"> MPI</font> library,  
the distributed graph constructors permit weighted communication edges  
and take an <font face="sans-serif"> info</font> argument that can further influence process  
reordering or other optimizations performed by the <font face="sans-serif"> MPI</font> library. For  
example, hints can be provided on how edge weights are to be  
interpreted, the quality of the reordering, and/or the time permitted  
for the <font face="sans-serif"> MPI</font> library to process the graph.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_DIST_GRAPH_CREATE_ADJACENT(comm_old, indegree, sources, sourceweights,   
outdegree, destinations, destweights, info, reorder, comm_dist_graph)</TD></TR>  
<TR><TD> IN comm_old</TD><TD>input communicator (handle)</TD></TR>  
<TR><TD> IN indegree</TD><TD>size of <font face="sans-serif"> sources</font> and <font face="sans-serif"> sourceweights</font> arrays (non-negative integer)</TD></TR>  
<TR><TD> IN sources</TD><TD>ranks of processes for which the calling process is a destination  
(array of non-negative integers)</TD></TR>  
<TR><TD> IN sourceweights</TD><TD>weights of the edges into the calling process (array of non-negative   
integers)</TD></TR>  
<TR><TD> IN outdegree</TD><TD>size of <font face="sans-serif"> destinations</font> and <font face="sans-serif"> destweights</font> arrays (non-negative integer)</TD></TR>  
<TR><TD> IN destinations</TD><TD>ranks of processes for which the calling process is a source  
(array of non-negative integers)</TD></TR>  
<TR><TD> IN destweights</TD><TD>weights of the edges out of the calling process  
(array of non-negative integers)</TD></TR>  
<TR><TD> IN info</TD><TD>hints on optimization and interpretation of weights (handle)</TD></TR>  
<TR><TD> IN reorder</TD><TD>the ranks may be reordered (<font face="sans-serif">  true</font>) or not (<font face="sans-serif">  false</font>) (logical)</TD></TR>  
<TR><TD> OUT comm_dist_graph</TD><TD>communicator with distributed graph topology (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Dist_graph_create_adjacent(MPI_Comm comm_old, int indegree, int sources[], int sourceweights[], int outdegree, int destinations[], int destweights[], MPI_Info info, int reorder, MPI_Comm *comm_dist_graph) <BR></tt>  
<P> 
 <tt> MPI_DIST_GRAPH_CREATE_ADJACENT(COMM_OLD, INDEGREE, SOURCES, SOURCEWEIGHTS, OUTDEGREE, DESTINATIONS, DESTWEIGHTS, INFO, REORDER, COMM_DIST_GRAPH, IERROR)<BR> INTEGER COMM_OLD, INDEGREE, SOURCES(*), SOURCEWEIGHTS(*), OUTDEGREE, <BR>    DESTINATIONS(*), DESTWEIGHTS(*), INFO, COMM_DIST_GRAPH, IERROR <BR>LOGICAL REORDER <BR></tt>  
<P> 
 <font color="red">{<font color="black"> MPI::Distgraphcomm MPI::Intracomm::Dist_graph_create_adjacent(int indegree, const int sources[], const int sourceweights[], int outdegree, const int destinations[], const int destweights[], const MPI::Info&amp; info, bool reorder) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
 <font color="red">{<font color="black"> MPI::Distgraphcomm MPI::Intracomm::Dist_graph_create_adjacent(int indegree, const int sources[], int outdegree, const int destinations[], const MPI::Info&amp; info, bool reorder) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> returns a handle to a new  
communicator to which the distributed graph topology information is  
attached.  Each process passes all information about the edges to its  
neighbors in the virtual distributed graph topology.  The calling  
processes must ensure that each edge of the graph is described in the  
source and in the destination process with the same weights. If there  
are multiple edges for a given <font face="sans-serif"> (source,dest)</font> pair, then the sequence  
of the weights of these edges does not matter. The complete  
communication topology is the combination of all edges shown in the  
<font face="sans-serif"> sources</font> arrays of all processes in <font face="sans-serif"> comm_old</font>, which must be  
identical to the combination of all edges shown in the  
<font face="sans-serif"> destinations</font> arrays.  Source and destination ranks must be  
process ranks of <font face="sans-serif"> comm_old</font>. This allows a fully distributed  
specification of the communication graph.  Isolated processes (i.e.,  
processes with no outgoing or incoming edges, that is, processes that  
have specified <font face="sans-serif"> indegree</font> and <font face="sans-serif"> outdegree</font> as zero and that  
thus do not occur as source or destination rank in the graph  
specification) are allowed.  
<P> 
The call creates a new communicator <font face="sans-serif"> comm_dist_graph</font> of  
distributed graph topology type to which topology information has been  
attached. The number of processes in <font face="sans-serif"> comm_dist_graph</font> is  
identical to the number of processes in <font face="sans-serif"> comm_old</font>. The call to  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> is collective.  
<P> 
Weights are specified as non-negative integers and can be used to  
influence the process remapping strategy and other internal <font face="sans-serif"> MPI</font>  
optimizations. For instance, approximate count arguments of later  
communication calls along specific edges could be used as their edge  
weights. Multiplicity of edges can likewise indicate more intense  
communication between pairs of processes. However, the exact meaning  
of edge weights is not specified by the <font face="sans-serif"> MPI</font> standard and is left to  
the implementation. In C or Fortran, an application can supply the  
special value <font face="sans-serif">  MPI_UNWEIGHTED</font> for the weight array to indicate  
that all edges have the same (effectively no) weight. In C++, this  
constant does not exist and the weight arguments may be omitted from  
the argument list. It is erroneous to supply <font face="sans-serif">  MPI_UNWEIGHTED</font>, or  
in C++ omit the weight arrays, for some but not all processes of  
<font face="sans-serif"> comm_old</font>. Note that <font face="sans-serif">  MPI_UNWEIGHTED</font> is not a special weight  
value; rather it is a special value for the total array argument. In  
C, one would expect it to be <font face="sans-serif">  NULL</font>. In Fortran,  
<font face="sans-serif">  MPI_UNWEIGHTED</font> is an object like <font face="sans-serif">  MPI_BOTTOM</font> (not usable  
for initialization or assignment).  
See Section <a href="node24.htm#Node24">Named Constants 
</a>.  
The meaning of the <font face="sans-serif"> info</font> and <font face="sans-serif"> reorder</font> arguments is defined  
in the description of the following routine.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_DIST_GRAPH_CREATE(comm_old, n, sources, degrees,   
destinations, weights, info, reorder, comm_dist_graph)</TD></TR>  
<TR><TD> IN comm_old</TD><TD>input communicator (handle)</TD></TR>  
<TR><TD> IN n</TD><TD>number of source nodes for which this process  
  specifies edges (non-negative integer)</TD></TR>  
<TR><TD> IN sources</TD><TD>array containing the <font face="sans-serif"> n</font> source nodes for which  
  this process specifies edges (array of non-negative integers)</TD></TR>  
<TR><TD> IN degrees</TD><TD>array specifying the number of destinations   
  for each source node in the source node array   
  (array of non-negative integers)</TD></TR>  
<TR><TD> IN destinations</TD><TD>destination nodes for the source nodes in the source node   
  array (array of non-negative integers)</TD></TR>  
<TR><TD> IN weights</TD><TD>weights for source to destination edges (array of non-negative integers)</TD></TR>  
<TR><TD> IN info</TD><TD>hints on optimization and interpretation of weights (handle)</TD></TR>  
<TR><TD> IN reorder</TD><TD>the process may be reordered (<font face="sans-serif">  true</font>) or not (<font face="sans-serif">  false</font>) (logical)</TD></TR>  
<TR><TD> OUT comm_dist_graph</TD><TD>communicator with distributed graph topology added (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Dist_graph_create(MPI_Comm comm_old, int n, int sources[], int degrees[], int destinations[], int weights[], MPI_Info info, int reorder, MPI_Comm *comm_dist_graph) <BR></tt>  
<P> 
 <tt> MPI_DIST_GRAPH_CREATE(COMM_OLD, N, SOURCES, DEGREES, DESTINATIONS, WEIGHTS, INFO, REORDER, COMM_DIST_GRAPH, IERROR)<BR> INTEGER COMM_OLD, N, SOURCES(*), DEGREES(*), DESTINATIONS(*), WEIGHTS(*), INFO, COMM_DIST_GRAPH, IERROR <BR>LOGICAL REORDER <BR></tt>  
<P> 
 <font color="red">{<font color="black"> MPI::Distgraphcomm MPI::Intracomm::Dist_graph_create(int n, const int sources[], const int degrees[], const int destinations[], const int weights[], const MPI::Info&amp; info, bool reorder) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
 <font color="red">{<font color="black"> MPI::Distgraphcomm MPI::Intracomm::Dist_graph_create(int n, const int sources[], const int degrees[], const int destinations[], const MPI::Info&amp; info, bool reorder) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> returns a handle to a new  
communicator to which the distributed graph topology information is  
attached. Concretely, each process calls the constructor with a set of  
directed <font face="sans-serif"> (source,destination)</font> communication edges as  
described below. Every process passes an array of <font face="sans-serif"> n</font> source  
nodes in the <font face="sans-serif"> sources</font> array.  For each source node, a  
non-negative number of destination nodes is specified in the  
<font face="sans-serif"> degrees</font> array. The destination nodes are stored in the  
corresponding consecutive segment of the <font face="sans-serif"> destinations</font>  
array. More precisely, if the <font face="sans-serif"> i</font>-th node in <font face="sans-serif"> sources</font> is  
<font face="sans-serif"> s</font>, this specifies <font face="sans-serif"> degrees[i]</font> edges <font face="sans-serif"> (s,d)</font>  
with <font face="sans-serif"> d</font> of the <font face="sans-serif"> j</font>-th such edge stored in  
<font face="sans-serif"> destinations[degrees[0]+...+degrees[i-1]+j]</font>. The weight of  
this edge is stored in  
<font face="sans-serif"> weights[degrees[0]+...+degrees[i-1]+j]</font>.  Both the  
<font face="sans-serif"> sources</font> and the <font face="sans-serif"> destinations</font> arrays may contain the  
same node more than once, and the order in which nodes are listed as  
destinations or sources is not significant. Similarly, different  
processes may specify edges with the same source and destination  
nodes.  Source and destination nodes must be process ranks of  
<font face="sans-serif"> comm_old</font>. Different processes may specify different numbers  
of source and destination nodes, as well as different source to  
destination edges.  This allows a fully distributed specification of  
the communication graph.  Isolated processes (i.e., processes with no  
outgoing or incoming edges, that is, processes that do not occur as  
source or destination node in the graph specification) are allowed.  
<P> 
The call creates a new communicator <font face="sans-serif"> comm_dist_graph</font> of  
distributed graph topology type to which topology information has been  
attached. The number of processes in <font face="sans-serif"> comm_dist_graph</font> is  
identical to the number of processes in <font face="sans-serif"> comm_old</font>. The call to  
<font face="sans-serif"> MPI_Dist_graph_create</font> is collective.  
<P> 
If <font face="sans-serif"> reorder = false</font>, all processes will have the same rank in  
<font face="sans-serif"> comm_dist_graph</font> as in <font face="sans-serif"> comm_old</font>. If  
<font face="sans-serif"> reorder = true</font> then the <font face="sans-serif"> MPI</font> library is free to remap to  
other processes (of <font face="sans-serif"> comm_old</font>) in order to improve  
communication on the edges of the communication graph. The weight  
associated with each edge is a hint to the <font face="sans-serif"> MPI</font> library about the  
amount or intensity of communication on that edge, and may be used to  
compute a ``best'' reordering.  
<P> 
Weights are specified as non-negative integers and can be used to  
influence the process remapping strategy and other internal <font face="sans-serif"> MPI</font>  
optimizations. For instance, approximate count arguments of later  
communication calls along specific edges could be used as their edge  
weights. Multiplicity of edges can likewise indicate more intense  
communication between pairs of processes. However, the exact meaning  
of edge weights is not specified by the <font face="sans-serif"> MPI</font> standard and is left to  
the implementation. In C or Fortran, an application can supply the  
special value <font face="sans-serif">  MPI_UNWEIGHTED</font> for the weight array to indicate  
that all edges have the same (effectively no) weight. In C++, this  
constant does not exist and the weights argument may be omitted from  
the argument list. It is erroneous to supply <font face="sans-serif">  MPI_UNWEIGHTED</font>, or  
in C++ omit the weight arrays, for some but not all processes of  
<font face="sans-serif"> comm_old</font>. Note that <font face="sans-serif">  MPI_UNWEIGHTED</font> is not a special weight  
value; rather it is a special value for the total array argument. In  
C, one would expect it to be <font face="sans-serif">  NULL</font>. In Fortran,  
<font face="sans-serif">  MPI_UNWEIGHTED</font> is an object like <font face="sans-serif">  MPI_BOTTOM</font> (not usable  
for initialization or assignment).   
See Section <a href="node24.htm#Node24">Named Constants 
</a>  
The meaning of the <font face="sans-serif"> weights</font> argument can be influenced by the  
<font face="sans-serif"> info</font> argument. Info arguments can be used to guide the  
mapping; possible options include minimizing the maximum number of  
edges between processes on different SMP nodes, or minimizing the sum  
of all such edges.  An <font face="sans-serif"> MPI</font> implementation is not obliged to follow  
specific hints, and it is valid for an <font face="sans-serif"> MPI</font> implementation not to do  
any reordering.  An <font face="sans-serif"> MPI</font> implementation may specify more <font face="sans-serif"> info</font>  
key-value pairs. All processes must specify the same set of key-value  
<font face="sans-serif"> info</font> pairs.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
<font face="sans-serif"> MPI</font> implementations must document any additionally supported key-value  
<font face="sans-serif"> info</font> pairs. <font face="sans-serif">  MPI_INFO_NULL</font> is always valid, and may  
indicate the default creation of the distributed graph topology to the  
<font face="sans-serif"> MPI</font> library.  
<P> 
An implementation does not explicitly need to construct the topology  
from its distributed parts. However, all processes can construct the  
full topology from the distributed specification and use this in a  
call to <font face="sans-serif"> MPI_GRAPH_CREATE</font> to create the topology.  This may serve  
as a reference implementation of the functionality, and may be  
acceptable for small communicators. However, a scalable high-quality  
implementation would save the topology graph in a distributed way.  
 (<em> End of advice to implementors.</em>) <BR> 
<BR><b> Example</b>  
As for Example <a href="node171.htm#Node171">General (Graph) Constructor 
</a>,assume there are four processes 0, 1, 2, 3 with the following adjacency matrix and   
unit edge weights: <BR>  
  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT"> neighbors </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT"> 1, 3      </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT"> 0         </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT"> 3         </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT"> 0, 2      </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
  
<P> 
With <font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font>, this graph could be  
constructed in many different ways. One way would be that each process  
specifies its outgoing edges. The arguments per process would be: <BR>  
  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT">  <font face="sans-serif"> n</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> sources</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> degrees</font></TD><TD ALIGN="LEFT">   
<font face="sans-serif"> destinations</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> weights</font> </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 0</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 1,3</TD><TD ALIGN="LEFT"> 1,1     </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 0</TD><TD ALIGN="LEFT"> 1       </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 3</TD><TD ALIGN="LEFT"> 1       </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 3</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 0,2</TD><TD ALIGN="LEFT"> 1,1     </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
  
<P> 
Another way would be to pass the whole graph on process 0, which could be  
done with the following arguments per process: <BR>  
  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT">  <font face="sans-serif"> n</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> sources</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> degrees</font></TD><TD ALIGN="LEFT">   
<font face="sans-serif"> destinations</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> weights</font>     </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT">  4</TD><TD ALIGN="LEFT"> 0,1,2,3</TD><TD ALIGN="LEFT"> 2,1,1,2</TD><TD ALIGN="LEFT"> 1,3,0,3,0,2</TD><TD ALIGN="LEFT"> 1,1,1,1,1,1 </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT">  0</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -           </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT">  0</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -           </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT">  0</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT"> -</TD><TD ALIGN="LEFT">             </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
  
<P> 
In both cases above, the application could supply <font face="sans-serif">  MPI_UNWEIGHTED</font>  
instead of explicitly providing identical weights.  
<P> 
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE_ADJACENT</font> could be used to specify  
this graph using the following arguments: <BR>  
  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT">  <font face="sans-serif"> indegree</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> sources</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> sourceweights</font></TD><TD ALIGN="LEFT">   
<font face="sans-serif"> outdegree</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> destinations</font></TD><TD ALIGN="LEFT"> <font face="sans-serif"> destweights</font>    </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT">  2</TD><TD ALIGN="LEFT"> 1,3</TD><TD ALIGN="LEFT"> 1,1</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 1,3</TD><TD ALIGN="LEFT"> 1,1            </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 0</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 0</TD><TD ALIGN="LEFT"> 1              </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT">  1</TD><TD ALIGN="LEFT"> 3</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 1</TD><TD ALIGN="LEFT"> 3</TD><TD ALIGN="LEFT"> 1              </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT">  2</TD><TD ALIGN="LEFT"> 0,2</TD><TD ALIGN="LEFT"> 1,1</TD><TD ALIGN="LEFT"> 2</TD><TD ALIGN="LEFT"> 0,2</TD><TD ALIGN="LEFT"> 1,1            </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
  
  
<P> 
<BR><b> Example</b>  
A two-dimensional PxQ torus where all processes communicate along the  
dimensions and along the diagonal edges. This cannot be modelled with  
Cartesian topologies, but can easily be captured with  
<font face="sans-serif"> MPI_DIST_GRAPH_CREATE</font> as shown in the following code. In this  
example, the communication along the dimensions is twice as heavy as  
the communication along the diagonals:  
<P> 
<BR> 
<pre><tt>/* 
Input:     dimensions P, Q 
Condition: number of processes equal to P*Q; otherwise only  
           ranks smaller than P*Q participate 
*/ 
int rank, x, y; 
int sources[1], degrees[1]; 
int destinations[8], weights[8]; 
 
MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); 
 
/* get x and y dimension */ 
y=rank/P; x=rank%P; 
 
/* get my communication partners along x dimension */ 
destinations[0] = P*y+(x+1)%P; weights[0] = 2; 
destinations[1] = P*y+(P+x-1)%P; weights[1] = 2; 
 
/* get my communication partners along y dimension */ 
destinations[2] = P*((y+1)%Q)+x; weights[2] = 2; 
destinations[3] = P*((Q+y-1)%Q)+x; weights[3] = 2; 
 
/* get my communication partners along diagonals */ 
destinations[4] = P*((y+1)%Q)+(x+1)%P; weights[4] = 1; 
destinations[5] = P*((Q+y-1)%Q)+(x+1)%P; weights[5] = 1; 
destinations[6] = P*((y+1)%Q)+(P+x-1)%P; weights[6] = 1; 
destinations[7] = P*((Q+y-1)%Q)+(P+x-1)%P; weights[7] = 1; 
 
sources[0] = rank; 
degrees[0] = 8; 
MPI_Dist_graph_create(MPI_COMM_WORLD, 1, sources, degrees, destinations, 
                      weights, MPI_INFO_NULL, 1, comm_dist_graph) 
</tt></pre> 
  
<font color="black">  
<P> 

<P>
<HR>
<A HREF="node171.htm#Node171"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node168.htm#Node168"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node173.htm#Node173"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node168.htm#Node168"> Topology Constructors</a>
<b>Next: </b><A HREF="node173.htm#Node173"> Topology Inquiry Functions</a>
<b>Previous: </b><A HREF="node171.htm#Node171"> General (Graph) Constructor</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
