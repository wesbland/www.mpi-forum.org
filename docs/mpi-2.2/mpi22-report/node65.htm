<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Persistent Communication Requests</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node65">64. Persistent Communication Requests</a></H1>
<A HREF="node64.htm#Node64"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node66.htm#Node66"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node66.htm#Node66"> Send-Receive</a>
<b>Previous: </b><A HREF="node64.htm#Node64"> Probe and Cancel</a>
<P>
  
<P> 
Often a communication with the same argument list is repeatedly  
executed within the inner loop of a parallel computation.  In such a  
situation, it may be possible to optimize the communication by  
binding the list of communication arguments to a <b> persistent</b> communication  
request once and, then, repeatedly using  
the request to initiate and complete messages.  The  
persistent request thus created can be thought of as a  
communication port or a ``half-channel.''  
It does not provide the full functionality of a conventional channel,  
since there is no binding of the send port to the receive port. This  
construct allows reduction of the overhead for communication  
between the process and communication controller, but not of the overhead for  
communication between one communication controller and another.  
It is not necessary that messages sent with a persistent request be received  
by a receive operation using a persistent request, or vice versa.  
<P> 
A persistent communication request is created using one of the   
five  
following calls.  These calls involve no communication.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SEND_INIT(buf, count, datatype, dest, tag,  
comm, request)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements sent (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Send_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_SEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  REQUEST, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
 <font color="red">{<font color="black"> MPI::Prequest MPI::Comm::Send_init(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Creates a persistent communication request  
for a standard mode send operation, and binds to it all the  
arguments of a send operation.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BSEND_INIT(buf, count, datatype, dest, tag,  
comm, request)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements sent (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Bsend_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_BSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  REQUEST, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
 <font color="red">{<font color="black"> MPI::Prequest MPI::Comm::Bsend_init(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Creates a persistent communication request for a buffered mode send.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SSEND_INIT(buf, count, datatype, dest, tag,  
comm, request)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements sent (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Ssend_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_SSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
 <font color="red">{<font color="black"> MPI::Prequest MPI::Comm::Ssend_init(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Creates a persistent communication object  
for a synchronous mode send operation.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_RSEND_INIT(buf, count, datatype, dest, tag,  
comm, request)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements sent (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Rsend_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_RSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
 <font color="red">{<font color="black"> MPI::Prequest MPI::Comm::Rsend_init(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Creates a persistent communication object  
for a ready mode send operation.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_RECV_INIT(buf, count, datatype, source, tag,  
comm, request)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of receive buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements received (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN source</TD><TD>rank of source or <font face="sans-serif">  MPI_ANY_SOURCE</font> (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag or <font face="sans-serif">  MPI_ANY_TAG</font> (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Recv_init(void* buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_RECV_INIT(BUF, COUNT, DATATYPE, SOURCE, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  COUNT, DATATYPE, SOURCE, TAG, COMM, REQUEST, IERROR <BR></tt>  
 <font color="red">{<font color="black"> MPI::Prequest MPI::Comm::Recv_init(void* buf, int count, const MPI::Datatype&amp; datatype, int source, int tag) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Creates a persistent communication request  
for a receive operation.  The argument <font face="sans-serif"> buf</font> is marked as <font face="sans-serif"> OUT</font>  
because the user gives permission to write on the receive buffer by passing the  
argument to <font face="sans-serif"> MPI_RECV_INIT</font>.  
<P> 
A persistent communication request is inactive after it was created  
--- no active communication is attached to the request.  
<P> 
A communication (send or receive) that uses a persistent request  
is initiated by the function <font face="sans-serif"> MPI_START</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_START(request)</TD></TR>  
<TR><TD> INOUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Start(MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_START(REQUEST, IERROR)<BR> INTEGER  REQUEST, IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Prequest::Start() <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
The argument, <font face="sans-serif"> request</font>, is a handle returned  
by one of the previous five calls.   The associated request should be  
inactive.  The request becomes active once the call is made.  
<P> 
If the request is for a send with ready mode, then  
a matching receive should be posted before the call is made.  The  
communication buffer should not be   
<font color="red">modified<font color="black">  
after the call, and  
until the operation completes.  
<P> 
The call is local, with similar semantics to the nonblocking  
communication operations described in  
Section <a href="node57.htm#Node57">Nonblocking Communication 
</a>.  That is,  
a call to <font face="sans-serif"> MPI_START</font> with a  
request created by <font face="sans-serif"> MPI_SEND_INIT</font>  
starts a  
communication in the same manner as a call to <font face="sans-serif"> MPI_ISEND</font>;  
a call to <font face="sans-serif"> MPI_START</font> with a  
request created by <font face="sans-serif"> MPI_BSEND_INIT</font>  
starts a  
communication in the same manner as a call to  
<font face="sans-serif"> MPI_IBSEND</font>;  and so on.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_STARTALL(count, array_of_requests)</TD></TR>  
<TR><TD> IN count</TD><TD>list length (non-negative  
integer)</TD></TR>  
<TR><TD> INOUT array_of_requests</TD><TD>array of requests (array of handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Startall(int count, MPI_Request *array_of_requests) <BR></tt>  
<P> 
 <tt> MPI_STARTALL(COUNT, ARRAY_OF_REQUESTS, IERROR)<BR> INTEGER  COUNT, ARRAY_OF_REQUESTS(*), IERROR <BR></tt>  
 <font color="red">{<font color="black"> static void MPI::Prequest::Startall(int count, MPI::Prequest array_of_requests[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
Start all communications associated with requests in  
<font face="sans-serif"> array_of_requests</font>.  A call to  
<BR>  
<font face="sans-serif"> MPI_STARTALL(count, array_of_requests)</font> has the  
same effect as calls to  
<font face="sans-serif"> MPI_START</font> <font face="sans-serif"> (&amp;array_of_requests[i])</font>,   
executed for <font face="sans-serif"> i=0 ,..., count-1</font>, in some arbitrary order.  
<P> 
A communication started with a call to <font face="sans-serif"> MPI_START</font> or  
<font face="sans-serif"> MPI_STARTALL</font> is  
completed by a call to <font face="sans-serif"> MPI_WAIT</font>, <font face="sans-serif"> MPI_TEST</font>, or  
one of the derived functions described in  
Section <a href="node62.htm#Node62">Multiple Completions 
</a>.  The request becomes inactive after  
successful completion of such call.   The request is not deallocated  
and it can be activated anew by an <font face="sans-serif"> MPI_START</font> or  
<font face="sans-serif"> MPI_STARTALL</font> call.  
<P> 
A persistent request is deallocated by a call to  
<font face="sans-serif"> MPI_REQUEST_FREE</font>  
(Section <a href="node60.htm#Node60">Communication Completion 
</a>).  
<P> 
The call to <font face="sans-serif"> MPI_REQUEST_FREE</font> can occur at any point in the program  
after the persistent request was created.  However, the request will be  
deallocated only after it becomes inactive.  
Active receive requests should not be freed. Otherwise, it will not be  
possible to check that the receive has completed.  
It is preferable, in general, to free requests when they are inactive.  If this  
rule is followed, then the functions  
described in this section will be invoked  
in a sequence of the form,  
<P> 
  
<IMG WIDTH=163 HEIGHT=11 SRC="img8.gif">
  
  
  
<BR>  
where   
<I>*</I> indicates zero or more repetitions.  
If the same communication object is used in several concurrent  
threads, it is the user's responsibility to coordinate calls so that the  
correct sequence is obeyed.  
<P> 
A send operation initiated with <font face="sans-serif"> MPI_START</font> can be matched with  
any receive operation and, likewise, a receive operation initiated  
with <font face="sans-serif"> MPI_START</font> can receive messages generated by any send  
operation.  
<P> 
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
To prevent problems with the argument copying and register optimization done  
  by Fortran compilers, please note the hints in subsections ``Problems Due to  
  Data Copying and Sequence Association,'' and ``A Problem with  
  Register Optimization''    
  in Section <a href="node343.htm#Node343">Problems With Fortran Bindings for <font face="sans-serif"> MPI</font> 
</a> on  
  pages <a href="node343.htm#Node345">Problems Due to Data Copying and Sequence Association 
</a> and <a href="node343.htm#Node348">A Problem with Register Optimization 
</a>.  
 (<em> End of advice to users.</em>) <BR> 

<P>
<HR>
<A HREF="node64.htm#Node64"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node66.htm#Node66"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node66.htm#Node66"> Send-Receive</a>
<b>Previous: </b><A HREF="node64.htm#Node64"> Probe and Cancel</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
