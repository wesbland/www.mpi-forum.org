<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-coll/coll.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>All-to-All Scatter/Gather</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node101">100. All-to-All Scatter/Gather</a></H1>
<A HREF="node100.htm#Node100"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node102.htm#Node102"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node102.htm#Node102"> Global Reduction Operations</a>
<b>Previous: </b><A HREF="node100.htm#Node100"> Example using <font face="sans-serif"> MPI_ALLGATHER</font></a>
<P>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_ALLTOALL(sendbuf, sendcount, sendtype, recvbuf,  
recvcount, recvtype, comm)</TD></TR>  
<TR><TD> IN  sendbuf</TD><TD> starting address of send buffer (choice)</TD></TR>  
<TR><TD> IN  sendcount</TD><TD> number of elements sent to each process (non-negative  
integer)</TD></TR>  
<TR><TD> IN  sendtype</TD><TD> data type of send buffer elements (handle)</TD></TR>  
<TR><TD> OUT  recvbuf</TD><TD> address of receive buffer (choice)</TD></TR>  
<TR><TD> IN  recvcount</TD><TD> number of elements received from any process (non-negative  
integer)</TD></TR>  
<TR><TD> IN  recvtype</TD><TD> data type of receive buffer elements (handle)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Alltoall(void* sendbuf, int sendcount, MPI_Datatype sendtype, void* recvbuf, int recvcount, MPI_Datatype recvtype, MPI_Comm comm) <BR></tt>  
<P> 
 <tt> MPI_ALLTOALL(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT, RECVTYPE, COMM, IERROR) <BR> &lt;type&gt; SENDBUF(*), RECVBUF(*) <BR>INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, COMM, IERROR <BR></tt>  
  
  
 <font color="red">{<font color="black"> void MPI::Comm::Alltoall(const void* sendbuf, int sendcount, const MPI::Datatype&amp; sendtype, void* recvbuf, int recvcount, const MPI::Datatype&amp; recvtype) const = 0 <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
  
<P> 
<font face="sans-serif"> MPI_ALLTOALL</font> is an extension of <font face="sans-serif"> MPI_ALLGATHER</font> to the case  
where each process sends distinct data to each of the receivers.  
The   
<tt> j</tt>-th   
block sent from process <tt> i</tt> is received by process <tt> j</tt>  
and is placed in the   
<tt> i</tt>-th   
block of <font face="sans-serif"> recvbuf</font>.  
<P> 
The type signature associated with <font face="sans-serif"> sendcount, sendtype</font>,  
at a process must be equal to the type signature associated with  
<font face="sans-serif"> recvcount, recvtype</font> at any other process.  
This implies that the amount of data sent must be equal to the  
amount of data received, pairwise between every pair of processes.  
As usual, however, the type maps may be different.  
<P> 
If <font face="sans-serif"> comm</font> is an intracommunicator,   
the outcome is as if each process executed a send to each  
process (itself included)  
with a call to,  
<p><I> 
MPI_Send(sendbuf+i&#183; sendcount&#183; 
extent(sendtype),sendcount,sendtype,i, ...), 
</I><p>  
and a receive from every other process  
with a call to,  
<P><IMG WIDTH=404 HEIGHT=11 SRC="img63.gif"><P>
  
<P> 
All arguments  
on all processes are significant.  The argument <font face="sans-serif"> comm</font>  
must have identical values on all processes.  
  
<font color="red">  
The ``in place'' option for intracommunicators is specified by passing  
<font face="sans-serif">  MPI_IN_PLACE</font> to the argument <font face="sans-serif"> sendbuf</font> at <em> all</em> processes.  
In such a case, <font face="sans-serif"> sendcount</font> and <font face="sans-serif"> sendtype</font> are ignored.  
The data to be sent is taken from the <font face="sans-serif"> recvbuf</font> and replaced by the received data.  
Data sent and received must have the same type map as specified by <font face="sans-serif"> recvcount</font> and <font face="sans-serif"> recvtype</font>.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
For large <font face="sans-serif"> MPI_ALLTOALL</font> instances,  
allocating both send and receive buffers may consume too much memory.  
The ``in place'' option effectively halves the application memory consumption  
and is useful in situations where the data to be sent will not be used by the  
sending process after the <font face="sans-serif"> MPI_ALLTOALL</font> exchange (e.g., in parallel  
Fast Fourier Transforms).  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Users may opt to use the ``in place'' option in order to conserve memory.  
Quality MPI implementations should thus strive to minimize system buffering.  
 (<em> End of advice to implementors.</em>) <BR> 
<font color="black">  
If <font face="sans-serif"> comm</font> is an intercommunicator, then the outcome is as if  
each process in group A sends a message to each process in group B,  
and vice versa.  The <tt> j</tt>-th send buffer of process <tt> i</tt> in group A should  
be consistent with the <tt> i</tt>-th receive buffer of process <tt> j</tt> in group B,  
and vice versa.  
<P> 
<P> 
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
When <font color="red">a complete exchange<font color="black"> is executed on an intercommunication domain, thenthe number of data items sent from processes in group A to processes  
in group B need not equal the number of items sent in the reverse  
direction.  In particular, one can have unidirectional communication  
by specifying <font face="sans-serif"> sendcount = 0</font> in the reverse direction.  
<P> 
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_ALLTOALLV(sendbuf, sendcounts, sdispls, sendtype,  
recvbuf, recvcounts, rdispls, recvtype, comm)</TD></TR>  
<TR><TD> IN  sendbuf</TD><TD> starting address of send buffer (choice)</TD></TR>  
<TR><TD> IN  sendcounts</TD><TD>non-negative  
integer array <font color="red">(of length group size)<font color="black"> specifying the number of elements to send to each processor</TD></TR>  
<TR><TD> IN  sdispls</TD><TD> integer array (of length group size).  Entry  
<tt> j</tt> specifies the displacement (relative to <font face="sans-serif"> sendbuf</font> from  
which to take the outgoing data destined for process <tt> j</tt></TD></TR>  
<TR><TD> IN  sendtype</TD><TD> data type of send buffer elements (handle)</TD></TR>  
<TR><TD> OUT  recvbuf</TD><TD> address of receive buffer (choice)</TD></TR>  
<TR><TD> IN  recvcounts</TD><TD>non-negative  
integer array <font color="red">(of length group size)<font color="black"> specifying the number of elements that can be received from  
each processor</TD></TR>  
<TR><TD> IN  rdispls</TD><TD> integer array (of length group size).  Entry  
<tt> i</tt> specifies the displacement (relative to <font face="sans-serif"> recvbuf</font> at  
which to place the incoming data from process <tt> i</tt></TD></TR>  
<TR><TD> IN  recvtype</TD><TD> data type of receive buffer elements (handle)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Alltoallv(void* sendbuf, int *sendcounts, int *sdispls, MPI_Datatype sendtype, void* recvbuf, int *recvcounts, int *rdispls, MPI_Datatype recvtype, MPI_Comm comm) <BR></tt>  
<P> 
 <tt> MPI_ALLTOALLV(SENDBUF, SENDCOUNTS, SDISPLS, SENDTYPE, RECVBUF, RECVCOUNTS, RDISPLS, RECVTYPE, COMM, IERROR) <BR> &lt;type&gt; SENDBUF(*), RECVBUF(*) <BR>INTEGER SENDCOUNTS(*), SDISPLS(*), SENDTYPE, RECVCOUNTS(*), RDISPLS(*), RECVTYPE, COMM, IERROR <BR></tt>  
  
  
 <font color="red">{<font color="black"> void MPI::Comm::Alltoallv(const void* sendbuf,  const int sendcounts[], const int sdispls[],  const MPI::Datatype&amp; sendtype, void* recvbuf,  const int recvcounts[], const int rdispls[],  const MPI::Datatype&amp; recvtype) const = 0 <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
  
<P> 
<font face="sans-serif"> MPI_ALLTOALLV</font> adds flexibility to <font face="sans-serif"> MPI_ALLTOALL</font> in that  
the location of data for the send is specified by <font face="sans-serif"> sdispls</font>  
and the location of the placement of the data on the receive side  
is specified by <font face="sans-serif"> rdispls</font>.  
<P> 
If <font face="sans-serif"> comm</font> is an intracommunicator, then  
the   
<tt> j</tt>-th   
block sent from process <tt> i</tt> is received by process <tt> j</tt>  
and is placed in the   
<tt> i</tt>-th   
block of <font face="sans-serif"> recvbuf</font>.  These blocks need not all have the same size.  
<P> 
The type signature associated with  
<font face="sans-serif"> sendcount<font color="red">s<font color="black">[j], sendtype</font> at process <tt> i</tt> must be equalto the type signature  
associated with <font face="sans-serif"> recvcount<font color="red">s<font color="black">[i], recvtype</font> at process <tt> j</tt>.This implies that the amount of data sent must be equal to the  
amount of data received, pairwise between every pair of processes.  
Distinct type maps between sender and receiver are still allowed.  
<P> 
The outcome is as if each process sent a message to every other process  
with,  
<p><I> 
MPI_Send(sendbuf+MPIupdate2.2113sdispls[i]&#183; extent(sendtype),sendcounts[i],sendtype,i,...), 
</I><p>and received a message from every other process with  
a call to  
<p><I> 
MPI_Recv(recvbuf+MPIupdate2.2113rdispls[i]&#183; extent(recvtype),recvcounts[i],recvtype,i,...). 
</I><p>  
All arguments  
on all processes are significant.  The argument <font face="sans-serif"> comm</font>  
must have identical values on all processes.  
  
<font color="red">  
The ``in place'' option for intracommunicators is specified by passing  
<font face="sans-serif">  MPI_IN_PLACE</font> to the argument <font face="sans-serif"> sendbuf</font> at <em> all</em> processes.  
In such a case, <font face="sans-serif"> sendcounts</font>, <font face="sans-serif"> sdispls</font> and <font face="sans-serif"> sendtype</font> are ignored.  
The data to be sent is taken from the <font face="sans-serif"> recvbuf</font> and replaced by the received data.  
Data sent and received must have the same type map as specified by the <font face="sans-serif"> recvcounts</font>  
array and the <font face="sans-serif"> recvtype</font>, and is taken from the locations of the receive buffer  
specified by <font face="sans-serif"> rdispls</font>.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Specifying the ``in place'' option (which must be given on all processes)  
implies that the same amount and type of data is sent and received between  
any two processes in the group of the communicator.  
Different pairs of processes can exchange different amounts of data.  
Users must ensure that <font face="sans-serif"> recvcounts[j]</font> and <font face="sans-serif"> recvtype</font> on process  
<tt> i</tt> match <font face="sans-serif"> recvcounts[i]</font> and <font face="sans-serif"> recvtype</font> on process <tt> j</tt>.  
This symmetric exchange can be useful in applications where the data to be sent will  
not be used by the sending process after the <font face="sans-serif"> MPI_ALLTOALLV</font> exchange.  
 (<em> End of advice to users.</em>) <BR> 
<font color="black">  
If <font face="sans-serif"> comm</font> is an intercommunicator, then the outcome is as if  
each process in group A sends a message to each process in group B,  
and vice versa.  The <tt> j</tt>-th send buffer of process <tt> i</tt> in group A should  
be consistent with the <tt> i</tt>-th receive buffer of process <tt> j</tt> in group B,  
and vice versa.  
  
 
<BR> 
<em> Rationale.</em>  
<P> 
The definitions of <font face="sans-serif"> MPI_ALLTOALL</font> and <font face="sans-serif"> MPI_ALLTOALLV</font> give as much  
flexibility as one would achieve by specifying <tt> n</tt> independent,  
point-to-point communications, with two exceptions: all messages use the same  
datatype, and messages are scattered from (or gathered to) sequential  
storage.  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Although the discussion of collective communication in terms of  
point-to-point operation implies that each message is transferred directly  
from sender to receiver, implementations may use a tree communication  
pattern. Messages can be forwarded by intermediate nodes where they  
are split (for scatter) or concatenated (for gather), if this  
is more efficient.  
 (<em> End of advice to implementors.</em>) <BR> 
  
<P> 
  
  
  
<P> 
  
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_ALLTOALLW(sendbuf, sendcounts, sdispls, sendtypes,  
recvbuf, recvcounts, rdispls, recvtypes, comm)</TD></TR>  
<TR><TD> IN sendbuf</TD><TD>starting address of send buffer (choice)</TD></TR>  
<TR><TD> IN sendcounts</TD><TD><font color="red">non-negative<font color="black"> integer array <font color="red">(of length group size)<font color="black"> specifying the  
number of elements to send to each processor</TD></TR>  
<TR><TD> IN sdispls</TD><TD>integer array (of length group size). Entry <tt> j</tt> specifies  
the displacement in bytes (relative to <font face="sans-serif"> sendbuf</font>) from which to take  
the outgoing data destined for process <tt> j</tt> (array of integers)</TD></TR>  
<TR><TD> IN sendtypes</TD><TD>array of datatypes (of length group size). Entry <tt> j</tt>  
specifies the type of data to send to process <tt> j</tt> (array of handles)</TD></TR>  
<TR><TD> OUT recvbuf</TD><TD>address of receive buffer (choice)</TD></TR>  
<TR><TD> IN recvcounts</TD><TD><font color="red">non-negative<font color="black"> integer array <font color="red">(of length group size)<font color="black"> specifying the  
number of elements that can be received from each processor</TD></TR>  
<TR><TD> IN rdispls</TD><TD>integer array (of length group size). Entry <tt> i</tt> specifies  
the displacement in bytes (relative to <font face="sans-serif"> recvbuf</font>) at which to place the  
incoming data from process <tt> i</tt> (array of integers)</TD></TR>  
<TR><TD> IN recvtypes</TD><TD>array of datatypes (of length group size). Entry <tt> i</tt>  
specifies the type of data received from process <tt> i</tt> (array of handles)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Alltoallw(void *sendbuf, int sendcounts[], int sdispls[], MPI_Datatype sendtypes[], void *recvbuf, int recvcounts[], int rdispls[], MPI_Datatype recvtypes[], MPI_Comm comm) <BR></tt>  
<P> 
 <tt> MPI_ALLTOALLW(SENDBUF, SENDCOUNTS, SDISPLS, SENDTYPES, RECVBUF, RECVCOUNTS, RDISPLS, RECVTYPES, COMM, IERROR) <BR> &lt;type&gt; SENDBUF(*), RECVBUF(*)<BR>INTEGER SENDCOUNTS(*), SDISPLS(*), SENDTYPES(*), RECVCOUNTS(*), RDISPLS(*), RECVTYPES(*), COMM, IERROR <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> void MPI::Comm::Alltoallw(const void* sendbuf, const int sendcounts[], const int sdispls[], const MPI::Datatype sendtypes[], void* recvbuf, const int recvcounts[], const int rdispls[], const MPI::Datatype recvtypes[]) const = 0 <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
<P> 
<font face="sans-serif"> MPI_ALLTOALLW</font>  
is the most general form of <font color="red">complete exchange<font color="black">.Like <font face="sans-serif"> MPI_TYPE_CREATE_STRUCT</font>, the most general type constructor,  
<font face="sans-serif"> MPI_ALLTOALLW</font> allows separate specification of count,  
displacement and datatype.  In addition, to allow maximum flexibility,  
the displacement of blocks within the send and receive buffers is  
specified in bytes.  
<P> 
If <font face="sans-serif"> comm</font> is an intracommunicator, then  
the <tt> j</tt>-th block sent from process <tt> i</tt> is received by process  
<tt> j</tt> and is placed in the <tt> i</tt>-th block of <font face="sans-serif"> recvbuf</font>.  
These blocks need not all have the same size.  
<P> 
The type signature associated with  
<font face="sans-serif"> sendcounts[j], sendtypes[j]</font> at process <tt> i</tt> must be equal  
to the type signature  
associated with <font face="sans-serif"> recvcounts[i], recvtypes[i]</font> at process <tt> j</tt>.  
This implies that the amount of data sent must be equal to the  
amount of data received, pairwise between every pair of processes.  
Distinct type maps between sender and receiver are still allowed.  
<P> 
The outcome is as if each process sent a message to every other process with  
<p><I> 
MPI_Send(sendbuf+sdispls[i],sendcounts[i],sendtypes[i] ,i,...), 
</I><p>  
and received a message from every other process with a call to  
<p><I> 
MPI_Recv(recvbuf+rdispls[i],recvcounts[i],recvtypes[i] ,i,...). 
</I><p>  
<P> 
All arguments on all processes are significant.  The argument  
<font face="sans-serif"> comm</font> must describe the same communicator on all processes.  
<P> 
<font color="red">  
Like for <font face="sans-serif"> MPI_ALLTOALLV</font>, the ``in place'' option for intracommunicators  
is specified by passing <font face="sans-serif">  MPI_IN_PLACE</font> to the argument <font face="sans-serif"> sendbuf</font>  
at <em> all</em> processes.  
In such a case, <font face="sans-serif"> sendcounts</font>, <font face="sans-serif"> sdispls</font> and <font face="sans-serif"> sendtypes</font> are ignored.  
The data to be sent is taken from the <font face="sans-serif"> recvbuf</font> and replaced by the received data.  
Data sent and received must have the same type map as specified by the <font face="sans-serif"> recvcounts</font>  
and <font face="sans-serif"> recvtypes</font> arrays, and is taken from the locations of the receive buffer  
specified by <font face="sans-serif"> rdispls</font>.  
<font color="black">  
If <font face="sans-serif"> comm</font> is an intercommunicator, then the outcome is as if  
each process in group A sends a message to each process in group B,  
and vice versa.  The <tt> j</tt>-th send buffer of process <tt> i</tt> in group A should  
be consistent with the <tt> i</tt>-th receive buffer of process <tt> j</tt> in group B,  
and vice versa.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The <font face="sans-serif"> MPI_ALLTOALLW</font> function generalizes several <font face="sans-serif"> MPI</font> functions by  
carefully selecting the input arguments.  For example, by making all but one  
process have <tt>sendcounts[i] = 0</tt>, this achieves an <tt>MPI_SCATTERW</tt>  
function.   
 (<em> End of rationale.</em>) <BR> 
  
  

<P>
<HR>
<A HREF="node100.htm#Node100"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node102.htm#Node102"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node102.htm#Node102"> Global Reduction Operations</a>
<b>Previous: </b><A HREF="node100.htm#Node100"> Example using <font face="sans-serif"> MPI_ALLGATHER</font></a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
