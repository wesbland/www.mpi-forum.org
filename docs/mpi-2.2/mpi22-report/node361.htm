<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Transfer of Handles</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node361">321. Transfer of Handles</a></H2>
<A HREF="node360.htm#Node360"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node362.htm#Node362"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> Language Interoperability</a>
<b>Next: </b><A HREF="node362.htm#Node362"> Status</a>
<b>Previous: </b><A HREF="node360.htm#Node360"> Initialization</a>
<P>
  
<P> 
  
  
Handles are passed between  
Fortran and C or C++ by using an explicit C wrapper to convert  
Fortran handles to C handles. There is no direct access to C or C++  
handles in Fortran. Handles are passed between C and C++ using   
overloaded C++ operators called from C++ code. There is no  
direct access to C++ objects from C.   
  
  
<P> 
The type definition <font face="sans-serif">  MPI_Fint</font> is provided in C/C++ for an  
integer of the size that matches a Fortran <font face="sans-serif">  INTEGER</font>;  
usually, <font face="sans-serif">  MPI_Fint</font> will be equivalent to  
<font face="sans-serif">  int</font>.  
<P> 
  
The following functions are provided in C to convert from a  
Fortran communicator handle (which is an integer) to a C communicator handle, and vice versa.   
See also Section <a href="node33.htm#Node33">Functions and Macros 
</a> on page <a href="node33.htm#Node33">Functions and Macros 
</a>.    
<BR>  
  
  
  
 <tt> MPI_Comm MPI_Comm_f2c(MPI_Fint comm) <BR></tt>  
<P> 
If <font face="sans-serif"> comm</font> is a valid Fortran handle to a communicator,  
then <font face="sans-serif"> MPI_Comm_f2c</font> returns a valid C handle to that same  
communicator;  
if <font face="sans-serif"> comm = MPI_COMM_NULL</font> (Fortran value), then  
<font face="sans-serif"> MPI_Comm_f2c</font> returns a null C handle; if <font face="sans-serif"> comm</font>  
is an invalid Fortran handle, then <font face="sans-serif"> MPI_Comm_f2c</font>  
returns an invalid C handle.  
<P> 
  
<P> 
 <tt> MPI_Fint MPI_Comm_c2f(MPI_Comm comm) <BR></tt>  
<P> 
  
<P> 
The function <font face="sans-serif"> MPI_Comm_c2f</font>  
translates a C communicator handle into a Fortran handle to the same  
communicator; it maps a null handle into a null handle and an invalid  
handle into an invalid handle.  
<P> 
Similar functions are provided for the other types of opaque objects.  
<P> 
  
<P> 
 <tt> MPI_Datatype MPI_Type_f2c(MPI_Fint datatype) <BR></tt>  
<P> 
 <tt> MPI_Fint MPI_Type_c2f(MPI_Datatype datatype) <BR></tt>  
<P> 
 <tt> MPI_Group MPI_Group_f2c(MPI_Fint group) <BR></tt>  
<P> 
 <tt> MPI_Fint MPI_Group_c2f(MPI_Group group) <BR></tt>  
<P> 
 <tt> MPI_Request MPI_Request_f2c(MPI_Fint request) <BR></tt>  
<P> 
 <tt> MPI_Fint MPI_Request_c2f(MPI_Request request) <BR></tt>  
<P> 
 <tt> MPI_File MPI_File_f2c(MPI_Fint file) <BR></tt>  
<P> 
 <tt> MPI_Fint MPI_File_c2f(MPI_File file) <BR></tt>  
<P> 
 <tt> MPI_Win MPI_Win_f2c(MPI_Fint win) <BR></tt>  
<P> 
 <tt> MPI_Fint MPI_Win_c2f(MPI_Win win) <BR></tt>  
<P> 
 <tt> MPI_Op MPI_Op_f2c(MPI_Fint op) <BR></tt>  
<P> 
 <tt> MPI_Fint MPI_Op_c2f(MPI_Op op) <BR></tt>  
<P> 
 <tt> MPI_Info MPI_Info_f2c(MPI_Fint info) <BR></tt>  
<P> 
 <tt> MPI_Fint MPI_Info_c2f(MPI_Info info) <BR></tt>  
 <P> 
 <tt> MPI_Errhandler MPI_Errhandler_f2c(MPI_Fint errhandler) <BR></tt>  
 <P> 
 <tt> MPI_Fint MPI_Errhandler_c2f(MPI_Errhandler errhandler) <BR></tt>  
  
  
<P> 
<BR><b> Example</b>  
  
The example below illustrates how the Fortran <font face="sans-serif"> MPI</font> function  
<font face="sans-serif"> MPI_TYPE_COMMIT</font> can be implemented by wrapping the C <font face="sans-serif"> MPI</font>  
function <font face="sans-serif"> MPI_Type_commit</font> with a C wrapper to do handle  
conversions.  
  
In this example a Fortran-C interface is assumed where a Fortran function is  
all upper case when referred to from C and arguments are passed by addresses.  
  
<P> 
  
<BR> 
<pre><tt>! FORTRAN PROCEDURE 
SUBROUTINE MPI_TYPE_COMMIT( DATATYPE, IERR) 
INTEGER DATATYPE, IERR 
CALL MPI_X_TYPE_COMMIT(DATATYPE, IERR) 
RETURN 
END 
</tt></pre> 
<BR> 
<pre><tt>/* C wrapper */ 
 
void MPI_X_TYPE_COMMIT( MPI_Fint *f_handle, MPI_Fint *ierr) 
{ 
   MPI_Datatype datatype; 
    
   datatype = MPI_Type_f2c( *f_handle); 
   *ierr = (MPI_Fint)MPI_Type_commit( &amp;datatype); 
   *f_handle = MPI_Type_c2f(datatype); 
   return; 
} 
</tt></pre> 
The same approach can be used for all other <font face="sans-serif"> MPI</font> functions.  
The call to <font face="sans-serif"> MPI_xxx_f2c</font> (resp. <font face="sans-serif"> MPI_xxx_c2f</font>)  
can be  
omitted when the handle is an  OUT (resp.  IN) argument, rather than  
 INOUT.  
  
  
<P> 
  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The design here provides a convenient solution for the prevalent case,  
where a C wrapper is used to allow Fortran code to call a C  
library, or C code to call a Fortran library.  
The use of C wrappers is much more likely than the use of Fortran  
wrappers, because it is much more likely that a variable of type  
<font face="sans-serif">  INTEGER</font> can be passed to C,  than a C handle  
can be passed to Fortran.  
<P> 
  
Returning the converted value as a function value rather than  
through the argument list allows the generation of efficient  
inlined code when these functions are simple (e.g., the identity).  
  
The conversion function in the wrapper  
does not catch an invalid handle argument.  Instead, an invalid handle  
is passed below to the library function, which, presumably, checks its  
input arguments.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
  
<P> 
<P> 
C and C++   
The C++ language interface provides the functions listed below for  
mixed-language interoperability.  The token <tt> &lt;CLASS&gt;</tt> is used  
below to indicate any valid <font face="sans-serif"> MPI</font> opaque handle name (e.g.,  
  
<tt> Group</tt>), except where noted.  
For the case where the C++ class corresponding to  
<tt> &lt;CLASS&gt;</tt> has derived classes, functions are also provided for  
converting between the derived classes and the C <tt> MPI_&lt;CLASS&gt;</tt>.  
  
<P> 
The following function allows assignment from  
a C <font face="sans-serif"> MPI</font> handle to a C++ <font face="sans-serif"> MPI</font> handle.  
<P> 
  
 <tt>  MPI::&lt;CLASS&gt;&amp; MPI::&lt;CLASS&gt;::operator=(const MPI_&lt;CLASS&gt;&amp; data) <BR></tt>  
<P> 
The constructor below creates a C++ <font face="sans-serif"> MPI</font> object from a C <font face="sans-serif"> MPI</font>  
handle.  This allows the automatic promotion of a C <font face="sans-serif"> MPI</font> handle to a  
C++ <font face="sans-serif"> MPI</font> handle.  
<P> 
  
 <tt>  MPI::&lt;CLASS&gt;::&lt;CLASS&gt;(const MPI_&lt;CLASS&gt;&amp; data) <BR></tt>  
<P> 
  
<BR><b> Example</b>  
 In order for a C program to use a C++ library, the C++ library  
must export a C interface that provides appropriate conversions  
before invoking the underlying C++ library call.  This example  
shows a C interface function that invokes a C++ library call with  
a C communicator; the communicator is automatically promoted to a  
C++ handle when the underlying C++ function is invoked.  
<P> 
<BR> 
<pre><tt>// C++ library function prototype 
void cpp_lib_call(MPI::Comm cpp_comm); 
 
// Exported C function prototype 
extern "C" { 
   void c_interface(MPI_Comm c_comm); 
} 
 
void c_interface(MPI_Comm c_comm) 
{ 
   // the MPI_Comm (c_comm) is automatically promoted to MPI::Comm 
   cpp_lib_call(c_comm); 
} 
</tt></pre> 
  
<P> 
The following function allows conversion from C++ objects to C <font face="sans-serif"> MPI</font>  
handles.  In this case, the casting operator is overloaded to provide  
the functionality.  
<P> 
  
 <tt>  MPI::&lt;CLASS&gt;::operator MPI_&lt;CLASS&gt;() const <BR></tt>  
<P> 
  
<BR><b> Example</b>  
 A C library routine is called from a C++ program.  The C  
library routine is prototyped to take an <tt> MPI_Comm</tt> as an  
argument.  
<P> 
<BR> 
<pre><tt>// C function prototype 
extern "C" { 
   void c_lib_call(MPI_Comm c_comm); 
} 
 
void cpp_function() 
{ 
   // Create a C++ communicator, and initialize it with a dup of 
   //   MPI::COMM_WORLD 
   MPI::Intracomm cpp_comm(MPI::COMM_WORLD.Dup()); 
   c_lib_call(cpp_comm); 
} 
</tt></pre> 
  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
Providing conversion from C to C++ via constructors and from C++ to  
C via casting allows the compiler to make automatic conversions.  
Calling C from C++ becomes trivial, as does the provision of a C or Fortran  
 interface to a C++ library.  
 (<em> End of rationale.</em>) <BR> 
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
Note that the casting and promotion operators return new handles by value.   
Using these new handles as  INOUT parameters will affect the internal MPI  
object, but will <em> not</em> affect the original handle from which it was  
cast.  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
<P> 
It is important to note that all C++ objects <font color="red">with<font color="black"> corresponding C  
handles can be used interchangeably by an application.  For example,  
an application can cache an attribute on <tt> MPI_COMM_WORLD</tt> and  
later retrieve it from <tt> MPI::COMM_WORLD</tt>.  
<P> 
  
<P> 
  
<P> 

<P>
<HR>
<A HREF="node360.htm#Node360"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node362.htm#Node362"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> Language Interoperability</a>
<b>Next: </b><A HREF="node362.htm#Node362"> Status</a>
<b>Previous: </b><A HREF="node360.htm#Node360"> Initialization</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
