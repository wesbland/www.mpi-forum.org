<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>MPI Opaque Objects</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node363">323. MPI Opaque Objects</a></H2>
<A HREF="node362.htm#Node362"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node364"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> Language Interoperability</a>
<b>Next: </b><A HREF="node363.htm#Node364"> Datatypes</a>
<b>Previous: </b><A HREF="node362.htm#Node362"> Status</a>
<P>
  
  
Unless said otherwise, opaque objects are ``the same'' in all languages:  
  
  
they carry the same information, and have the same meaning in both  
languages.  The mechanism described in the previous section can be  
used to pass references to <font face="sans-serif"> MPI</font> objects from language to language.  
An object created in one language can be accessed, modified or freed  
in another language.  
<P> 
We examine below in more detail, issues that arise for each type of  
<font face="sans-serif"> MPI</font> object.  
<P> 
<menu> 
</menu> 

<P>
<HR>
<A HREF="node362.htm#Node362"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node364"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> Language Interoperability</a>
<b>Next: </b><A HREF="node363.htm#Node364"> Datatypes</a>
<b>Previous: </b><A HREF="node362.htm#Node362"> Status</a>
<P>
<HR><H3><A NAME="Node364">323.1. Datatypes</a></H3>
<A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node365"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node365"> Callback Functions</a>
<b>Previous: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<P>
  
<P> 
  
Datatypes encode the same information in all languages.  E.g., a  
datatype accessor like <font face="sans-serif"> MPI_TYPE_GET_EXTENT</font> will return the  
same information in all languages.  
  
If a datatype defined in  
one language is used for a communication call in another language, then the  
message sent will  
be identical to the message that would be sent from the first language: the  
same  
communication buffer is accessed, and the same representation  
conversion is performed, if needed.  
  
  
All predefined  
  
datatypes can be used in datatype constructors in any language. If  
a datatype is committed, it can be used for  
communication in any language.  
<P> 
The function <font face="sans-serif"> MPI_GET_ADDRESS</font> returns the same value in  
all languages.  Note that we do not require that the  
constant <font face="sans-serif">  MPI_BOTTOM</font> have the same value in all languages (see  
<a href="node371.htm#Node371">Constants 
</a>, page <a href="node371.htm#Node371">Constants 
</a>).  
  
<P> 
  
<BR><b> Example</b>  
  
 <BR> 
<pre><tt>! FORTRAN CODE 
REAL R(5) 
INTEGER TYPE, IERR, AOBLEN(1), AOTYPE(1) 
INTEGER (KIND=MPI_ADDRESS_KIND) AODISP(1) 
 
! create an absolute datatype for array R 
AOBLEN(1) = 5 
CALL MPI_GET_ADDRESS( R, AODISP(1), IERR) 
AOTYPE(1) = MPI_REAL 
CALL MPI_TYPE_CREATE_STRUCT(1, AOBLEN,AODISP,AOTYPE, TYPE, IERR) 
CALL C_ROUTINE(TYPE) 
</tt></pre> 
  
<BR> 
<pre><tt>/* C code */ 
 
void C_ROUTINE(MPI_Fint *ftype) 
{ 
   int count = 5; 
   int lens[2] = {1,1}; 
   MPI_Aint displs[2]; 
   MPI_Datatype types[2], newtype; 
    
   /* create an absolute datatype for buffer that consists   */ 
   /*  of count, followed by R(5)                            */ 
    
   MPI_Get_address(&amp;count, &amp;displs[0]); 
   displs[1] = 0; 
   types[0] = MPI_INT; 
   types[1] = MPI_Type_f2c(*ftype); 
   MPI_Type_create_struct(2, lens, displs, types, &amp;newtype); 
   MPI_Type_commit(&amp;newtype); 
    
   MPI_Send(MPI_BOTTOM, 1, newtype, 1, 0, MPI_COMM_WORLD); 
   /* the message sent contains an int count of 5, followed  */ 
   /* by the 5 REAL entries of the Fortran array R.          */ 
} 
</tt></pre> 
  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
  
The following implementation can be used:  <font face="sans-serif"> MPI</font> addresses, as  
returned by <font face="sans-serif"> MPI_GET_ADDRESS</font>, will have  
the same value in all languages.  
  
One obvious choice is that  
<font face="sans-serif"> MPI</font> addresses be identical to regular addresses.  
The address is stored in the  
datatype, when datatypes with absolute addresses are constructed.  
When a send or receive operation is performed, then addresses stored in  
a datatype are interpreted as displacements that are all augmented by  
a base address.  This base address is (the address of) <font face="sans-serif"> buf</font>,  
or zero, if <font face="sans-serif"> buf = MPI_BOTTOM</font>.  Thus, if  
<font face="sans-serif">  MPI_BOTTOM</font> is zero then a send or  
receive call with <font face="sans-serif"> buf = MPI_BOTTOM</font> is implemented  
exactly as a call with a regular buffer argument:  in both cases the  
base address is <font face="sans-serif"> buf</font>.  
On the other  
hand, if <font face="sans-serif">  MPI_BOTTOM</font> is not zero, then the  
implementation has to be slightly different.  A test is performed  
to check whether <font face="sans-serif"> buf = MPI_BOTTOM</font>.  If true, then  
the base address is zero, otherwise it is <font face="sans-serif"> buf</font>.  
  
In particular, if <font face="sans-serif">  MPI_BOTTOM</font> does not have the same value in  
Fortran and C/C++, then an additional test for <font face="sans-serif"> buf = MPI_BOTTOM</font>  
is needed in at least one of the languages.  
<P> 
It may be desirable to use a value other than zero for  
<font face="sans-serif">  MPI_BOTTOM</font> even in C/C++, so as to distinguish it from a NULL  
pointer.  
  
If <font face="sans-serif">  MPI_BOTTOM</font> = c then one can still avoid the test  
<font face="sans-serif"> buf = MPI_BOTTOM</font>, by using the displacement from  
<font face="sans-serif">  MPI_BOTTOM</font>, i.e., the regular address - c, as the <font face="sans-serif"> MPI</font> address  
returned by <font face="sans-serif"> MPI_GET_ADDRESS</font> and stored in absolute datatypes.  
 (<em> End of advice to implementors.</em>) <BR> 
  
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
  

<P>
<HR>
<A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node365"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node365"> Callback Functions</a>
<b>Previous: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<P>
<HR><H3><A NAME="Node365">323.2. Callback Functions</a></H3>
<A HREF="node363.htm#Node364"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node366"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node366"> Error Handlers</a>
<b>Previous: </b><A HREF="node363.htm#Node364"> Datatypes</a>
<P>
<font face="sans-serif"> MPI</font> calls may associate callback functions with <font face="sans-serif"> MPI</font>  
objects: error handlers are associated with communicators and files, attribute copy  
and  
delete functions are associated with attribute keys, reduce operations  
are   
associated  
with operation objects, etc.  In a multilanguage  
environment, a function passed in an <font face="sans-serif"> MPI</font> call in one language may be  
invoked by an <font face="sans-serif"> MPI</font> call in another language.  <font face="sans-serif"> MPI</font> implementations  
must make sure that such invocation will use the calling convention of  
the language the function is bound to.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Callback functions need to have a language tag.  This tag is set  
when the callback function is passed in by the library function (which  
is presumably different for each language), and is used to generate  
the right calling sequence when the callback function is invoked.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node363.htm#Node364"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node366"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node366"> Error Handlers</a>
<b>Previous: </b><A HREF="node363.htm#Node364"> Datatypes</a>
<P>
<HR><H3><A NAME="Node366">323.3. Error Handlers</a></H3>
<A HREF="node363.htm#Node365"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node367"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node367"> Reduce Operations</a>
<b>Previous: </b><A HREF="node363.htm#Node365"> Callback Functions</a>
<P>
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Error handlers, have,  
in C and C++, a ``<tt> stdargs</tt>'' argument list.  
  
It might be useful to  
provide to the handler information on the language environment where  
the error occurred.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node363.htm#Node365"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node367"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node367"> Reduce Operations</a>
<b>Previous: </b><A HREF="node363.htm#Node365"> Callback Functions</a>
<P>
<HR><H3><A NAME="Node367">323.4. Reduce Operations</a></H3>
<A HREF="node363.htm#Node366"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node368"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node368"> Addresses</a>
<b>Previous: </b><A HREF="node363.htm#Node366"> Error Handlers</a>
<P>
 
<BR> 
<em> Advice to users.</em>  
<P> 
Reduce operations receive as one of their arguments the datatype of the  
operands.  
  
Thus, one can define ``polymorphic'' reduce  
operations that work for C, C++, and Fortran datatypes.  
  
 (<em> End of advice to users.</em>) <BR> 

<P>
<HR>
<A HREF="node363.htm#Node366"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node368"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node368"> Addresses</a>
<b>Previous: </b><A HREF="node363.htm#Node366"> Error Handlers</a>
<P>
<HR><H3><A NAME="Node368">323.5. Addresses</a></H3>
<A HREF="node363.htm#Node367"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node369.htm#Node369"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node369.htm#Node369"> Attributes</a>
<b>Previous: </b><A HREF="node363.htm#Node367"> Reduce Operations</a>
<P>
  
<P> 
  
Some of the datatype accessors and constructors have arguments of type  
   
<font face="sans-serif"> MPI_Aint</font> (in C) or <font face="sans-serif"> MPI::Aint</font> in C++, to hold  
addresses.  The corresponding arguments, in Fortran, have type  
<font face="sans-serif">  INTEGER</font>.  This causes Fortran and C/C++ to be incompatible,  
in an environment where addresses have 64 bits, but Fortran  
<font face="sans-serif">  INTEGER</font>s have 32 bits.  
  
<P> 
This is a problem, irrespective of  
interlanguage issues.  Suppose that a Fortran process has an address  
space of <IMG WIDTH=7 HEIGHT=9 SRC="img158.gif">
 4 GB.  What should be the value returned in Fortran by  
<font face="sans-serif"> MPI_ADDRESS</font>, for a variable with an address above <I>2<SUP>32</SUP></I>?  
The design described here addresses this issue, while maintaining  
compatibility with current Fortran codes.  
<P> 
  
The constant <font face="sans-serif">  MPI_ADDRESS_KIND</font> is defined so that, in Fortran  
90,  
<BR>  
<tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt>)  
is an address sized integer type (typically, but not necessarily,  
the size of an <tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt> is 4 on 32 bit address machines and 8 on 64  
bit address machines).  
Similarly, the constant  
<font face="sans-serif">  MPI_INTEGER_KIND</font> is defined so that  
<tt> INTEGER(KIND=MPI_INTEGER_KIND)</tt> is a default size  
<font face="sans-serif">  INTEGER</font>.  
  
<P> 
There are seven functions that have address arguments:  
<font face="sans-serif"> MPI_TYPE_HVECTOR</font>,  
<BR>  
<font face="sans-serif"> MPI_TYPE_HINDEXED</font>,  
<font face="sans-serif"> MPI_TYPE_STRUCT</font>,  
<font face="sans-serif"> MPI_ADDRESS</font>,  
<font face="sans-serif"> MPI_TYPE_EXTENT</font>  
<BR>  
<font face="sans-serif">  MPI_TYPE_LB</font> and  
<font face="sans-serif"> MPI_TYPE_UB</font>.  
<P> 
  
Four new functions are provided to supplement the first four functions  
in this list.  These functions are described in  
Section <a href="node70.htm#Node70">Type Constructors with Explicit Addresses 
</a> on page <a href="node70.htm#Node70">Type Constructors with Explicit Addresses 
</a>.  
The remaining three functions are supplemented by the  
new function  
  
<font face="sans-serif"> MPI_TYPE_GET_EXTENT</font>, described in  
that same section.  
The new functions have the same functionality as the old functions  
  
in C/C++, or on Fortran systems where default <font face="sans-serif">  INTEGER</font>s are  
address sized.  In Fortran, they accept arguments of type  
<tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt>,  
wherever arguments of type   
<font face="sans-serif">  MPI_Aint</font>   
and <font face="sans-serif">  MPI::Aint</font>   
are used in C  
and C++.  
On Fortran 77 systems that do not support the Fortran 90  
<font face="sans-serif">  KIND</font> notation, and where addresses are  
64 bits whereas default <font face="sans-serif">  INTEGER</font>s are 32 bits,  
these arguments will be  
of an appropriate integer type.  The old functions will continue to be  
provided, for backward compatibility.  However, users are encouraged to switch to  
the new functions, in Fortran, so as to avoid problems on systems with  
an address range <I>&gt; 2<SUP>32</SUP></I>, and to provide compatibility across languages.  
  
<P> 

<P>
<HR>
<A HREF="node363.htm#Node367"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node369.htm#Node369"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node363.htm#Node363"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node369.htm#Node369"> Attributes</a>
<b>Previous: </b><A HREF="node363.htm#Node367"> Reduce Operations</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
