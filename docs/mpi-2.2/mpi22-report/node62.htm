<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Multiple Completions</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node62">61. Multiple Completions</a></H2>
<A HREF="node61.htm#Node61"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node57.htm#Node57"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node63.htm#Node63"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node57.htm#Node57"> Nonblocking Communication</a>
<b>Next: </b><A HREF="node63.htm#Node63"> Non-destructive Test of <font face="sans-serif"> status</font></a>
<b>Previous: </b><A HREF="node61.htm#Node61"> Semantics of Nonblocking Communications</a>
<P>
  
<P> 
It is convenient to be able to wait for the completion of any, some, or all the  
operations in a list, rather than having to wait for a specific message.  
A call to <font face="sans-serif"> MPI_WAITANY</font> or <font face="sans-serif"> MPI_TESTANY</font> can be used to  
wait for the  
completion of one out of several operations. A call to <font face="sans-serif"> MPI_WAITALL</font>  
or <font face="sans-serif"> MPI_TESTALL</font> can be  
used to wait for all pending operations in a list. A call to  
<font face="sans-serif"> MPI_WAITSOME</font> or <font face="sans-serif"> MPI_TESTSOME</font> can be used to complete all  
enabled operations in a list.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WAITANY (count, array_of_requests, index, status)</TD></TR>  
<TR><TD> IN count</TD><TD>list length (non-negative  
integer)</TD></TR>  
<TR><TD> INOUT array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD> OUT index</TD><TD>index of handle for operation that completed (integer)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Waitany(int count, MPI_Request *array_of_requests, int *index, MPI_Status *status) <BR></tt>  
<P> 
 <tt> MPI_WAITANY(COUNT, ARRAY_OF_REQUESTS, INDEX, STATUS, IERROR)<BR> INTEGER  COUNT, ARRAY_OF_REQUESTS(*), INDEX, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <font color="red">{<font color="black"> static int MPI::Request::Waitany(int count, MPI::Request array_of_requests[], MPI::Status&amp; status) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> static int MPI::Request::Waitany(int count, MPI::Request array_of_requests[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
Blocks until one of the operations associated with the active  
requests in the array has completed.  
If more then one operation is  
enabled and can terminate, one is arbitrarily chosen.  
Returns in <font face="sans-serif"> index</font> the index  
of that request in the array and returns in <font face="sans-serif"> status</font> the status of the  
completing communication.  
(The array is indexed from zero in C, and from one in Fortran.)  
If the request was allocated by a nonblocking communication operation, then it  
is deallocated and the request handle is set to <font face="sans-serif">  MPI_REQUEST_NULL</font>.  
<P> 
  
The <font face="sans-serif"> array_of_requests</font> list may contain null or inactive  
handles.  
If the list contains no active handles (list has length zero or all  
entries are null or inactive),  
then the call  returns immediately with <font face="sans-serif"> index =</font>  
<font face="sans-serif">  MPI_UNDEFINED</font>, and a empty <font face="sans-serif"> status</font>.  
<P> 
The execution of <font face="sans-serif"> MPI_WAITANY(count, array_of_requests, index,  
status)</font> has the same effect as the execution of   
<font face="sans-serif"> MPI_WAIT(&amp;array_of_requests[i], status)</font>,   
where <font face="sans-serif"> i</font> is the value  
returned by <font face="sans-serif"> index</font> (unless the value of <font face="sans-serif"> index</font>  
is <font face="sans-serif">  MPI_UNDEFINED</font>).  
<font face="sans-serif"> MPI_WAITANY</font> with an array containing one active entry  
is equivalent to <font face="sans-serif"> MPI_WAIT</font>.  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TESTANY(count, array_of_requests, index, flag, status)</TD></TR>  
<TR><TD> IN count</TD><TD>list length (non-negative  
integer)</TD></TR>  
<TR><TD> INOUT array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD> OUT index</TD><TD>index of operation that completed,  
or <font face="sans-serif">  MPI_UNDEFINED</font> if none completed (integer)</TD></TR>  
<TR><TD> OUT flag</TD><TD><font face="sans-serif">  true</font> if one of the operations is complete  
(logical)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Testany(int count, MPI_Request *array_of_requests, int *index, int *flag, MPI_Status *status) <BR></tt>  
<P> 
 <tt> MPI_TESTANY(COUNT, ARRAY_OF_REQUESTS, INDEX, FLAG, STATUS, IERROR)<BR> LOGICAL  FLAG <BR>INTEGER  COUNT, ARRAY_OF_REQUESTS(*), INDEX, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <font color="red">{<font color="black"> static bool MPI::Request::Testany(int count, MPI::Request array_of_requests[], int&amp; index, MPI::Status&amp; status) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> static bool MPI::Request::Testany(int count, MPI::Request array_of_requests[], int&amp; index) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
Tests for completion of  
either one or none of the operations associated with active handles.  
In the former case, it returns <font face="sans-serif"> flag = true</font>,  
returns in <font face="sans-serif"> index</font> the index of this request in the array,  
and returns in <font face="sans-serif"> status</font> the status of that operation; if the request was  
allocated by a nonblocking communication call then the request is deallocated  
and the handle is set to <font face="sans-serif">  MPI_REQUEST_NULL</font>.  
(The array is indexed from zero in C, and from one in Fortran.)  
In the latter case (no operation completed), it returns <font face="sans-serif"> flag =  
false</font>, returns a value  
of <font face="sans-serif">  MPI_UNDEFINED</font> in <font face="sans-serif"> index</font> and <font face="sans-serif"> status</font> is  
undefined.  
<P> 
  
The array may contain null or inactive handles.  
If the  
array contains no active handles then the call returns  
immediately with <font face="sans-serif"> flag = true</font>,  
<font face="sans-serif"> index</font> = <font face="sans-serif">  MPI_UNDEFINED</font>, and an empty <font face="sans-serif"> status</font>.  
<P> 
If the array of requests contains active handles then  
  
the execution of <font face="sans-serif"> MPI_TESTANY(count, array_of_requests,  
index, status)</font> has the same effect as the execution of  
<font face="sans-serif"> MPI_TEST( &amp;array_of_requests[i], flag, status)</font>,  
for <font face="sans-serif"> i=0, 1 ,..., count-1</font>,  
in some arbitrary order, until one call returns <font face="sans-serif"> flag = true</font>, or  
all fail.  In the former case, <font face="sans-serif"> index</font> is set to the last value of <font face="sans-serif"> i</font>,  
and in the latter case, it is set to <font face="sans-serif">  MPI_UNDEFINED</font>.  
<font face="sans-serif"> MPI_TESTANY</font> with an array containing one active entry  
is equivalent to <font face="sans-serif"> MPI_TEST</font>.  
<P> 
  
  
2.2  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WAITALL( count, array_of_requests, array_of_statuses)</TD></TR>  
<TR><TD> IN count</TD><TD>lists length (non-negative  
integer)</TD></TR>  
<TR><TD> INOUT array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD> OUT array_of_statuses</TD><TD>array of status objects (array of Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Waitall(int count, MPI_Request *array_of_requests, MPI_Status *array_of_statuses) <BR></tt>  
<P> 
 <tt> MPI_WAITALL(COUNT, ARRAY_OF_REQUESTS, ARRAY_OF_STATUSES, IERROR)<BR> INTEGER  COUNT, ARRAY_OF_REQUESTS(*) <BR>INTEGER  ARRAY_OF_STATUSES(MPI_STATUS_SIZE,*), IERROR <BR></tt>  
 <font color="red">{<font color="black"> static void MPI::Request::Waitall(int count, MPI::Request array_of_requests[], MPI::Status array_of_statuses[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> static void MPI::Request::Waitall(int count, MPI::Request array_of_requests[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
Blocks until all communication operations associated with active handles  
in the list complete, and return the status of all these operations  
(this includes the case where no handle in the list is active).  
Both arrays have the same number of valid entries.  The <font face="sans-serif"> i</font>-th entry in  
<font face="sans-serif"> array_of_statuses</font> is set to the return status of the  
<font face="sans-serif"> i</font>-th operation.  
Requests that were created by nonblocking communication operations are  
deallocated and the corresponding handles in the array are set to  
<font face="sans-serif">  MPI_REQUEST_NULL</font>.  
  
The list may contain null or inactive handles.  
The call sets to empty the status of each such entry.  
<P> 
The error-free execution of <font face="sans-serif"> MPI_WAITALL(count, array_of_requests,  
array_of_statuses)</font> has the same effect as the execution of  
<BR>  
<font face="sans-serif"> MPI_WAIT(&amp;array_of_request[i], &amp;array_of_statuses[i])</font>,  
for <font face="sans-serif"> i=0 ,..., count-1</font>, in some arbitrary order.  
<font face="sans-serif"> MPI_WAITALL</font> with an array of length one  
is equivalent to <font face="sans-serif"> MPI_WAIT</font>.  
<P> 
When one or more of the communications completed by a  
call to <font face="sans-serif"> MPI_WAITALL</font> fail, it is  
desireable to return specific information on each  
communication.  The function <font face="sans-serif"> MPI_WAITALL</font> will return in such  
case the error code <font face="sans-serif">  MPI_ERR_IN_STATUS</font> and will set the  
error field of each status to a specific error code.  This code will be  
<font face="sans-serif">  MPI_SUCCESS</font>, if the specific communication completed; it will  
be another specific error code, if it failed;  
or it can be <font face="sans-serif">  MPI_ERR_PENDING</font> if it has neither failed nor completed.  
The function <font face="sans-serif"> MPI_WAITALL</font> will return <font face="sans-serif">  MPI_SUCCESS</font> if no request  
had an error,  
or will return another error code if it failed  
for other reasons (such as invalid arguments).  In such cases, it will  
not update the error fields of the statuses.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
This design streamlines error handling in the application.  
The application code need only test the (single) function result to  
determine if an error has occurred.  It needs to check each individual  
status only  when an error occurred.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TESTALL(count, array_of_requests, flag,  
array_of_statuses)</TD></TR>  
<TR><TD> IN count</TD><TD>lists length (non-negative  
integer)</TD></TR>  
<TR><TD> INOUT array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD> OUT flag</TD><TD>(logical)</TD></TR>  
<TR><TD> OUT array_of_statuses</TD><TD>array of status objects (array of Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Testall(int count, MPI_Request *array_of_requests, int *flag, MPI_Status *array_of_statuses) <BR></tt>  
<P> 
 <tt> MPI_TESTALL(COUNT, ARRAY_OF_REQUESTS, FLAG, ARRAY_OF_STATUSES, IERROR)<BR> LOGICAL  FLAG <BR>INTEGER  COUNT, ARRAY_OF_REQUESTS(*), ARRAY_OF_STATUSES(MPI_STATUS_SIZE,*), IERROR <BR></tt>  
 <font color="red">{<font color="black"> static bool MPI::Request::Testall(int count, MPI::Request array_of_requests[], MPI::Status array_of_statuses[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> static bool MPI::Request::Testall(int count, MPI::Request array_of_requests[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
Returns <font face="sans-serif"> flag = true</font>  
if all communications associated  
with active handles in the array have completed (this includes the  
case where no handle in the list is active).  
In this case, each status entry that corresponds to an active handle  
request  
is set to the status of the corresponding communication; if the request was  
allocated by a nonblocking communication call then it is deallocated, and  
the handle is set to <font face="sans-serif">  MPI_REQUEST_NULL</font>.  
  
Each status entry that corresponds to a null or inactive  
handle is set to empty.  
  
<P> 
Otherwise,  
<font face="sans-serif"> flag = false</font> is returned, no request is modified  
and the values of the status entries are undefined.  
This is a local operation.  
<P> 
  
Errors that occurred during the execution of <font face="sans-serif"> MPI_TESTALL</font>  
are handled as errors in <font face="sans-serif"> MPI_WAITALL</font>.  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WAITSOME(incount, array_of_requests, outcount,  
array_of_indices, array_of_statuses)</TD></TR>  
<TR><TD> IN incount</TD><TD>length of array_of_requests (non-negative  
integer)</TD></TR>  
<TR><TD> INOUT array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD> OUT outcount</TD><TD>number of completed requests (integer)</TD></TR>  
<TR><TD> OUT array_of_indices</TD><TD>array of indices of operations that  
completed (array of integers)</TD></TR>  
<TR><TD> OUT array_of_statuses</TD><TD>array of status objects for  
    operations that completed (array of Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Waitsome(int incount, MPI_Request *array_of_requests, int *outcount, int *array_of_indices, MPI_Status *array_of_statuses) <BR></tt>  
<P> 
 <tt> MPI_WAITSOME(INCOUNT, ARRAY_OF_REQUESTS, OUTCOUNT, ARRAY_OF_INDICES, ARRAY_OF_STATUSES, IERROR)<BR> INTEGER INCOUNT, ARRAY_OF_REQUESTS(*), OUTCOUNT, ARRAY_OF_INDICES(*), ARRAY_OF_STATUSES(MPI_STATUS_SIZE,*), IERROR <BR></tt>  
 <font color="red">{<font color="black"> static int MPI::Request::Waitsome(int incount, MPI::Request array_of_requests[], int array_of_indices[], MPI::Status array_of_statuses[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> static int MPI::Request::Waitsome(int incount, MPI::Request array_of_requests[], int array_of_indices[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Waits until at least one of the operations associated with active  
handles in the list have completed.  
Returns in <font face="sans-serif"> outcount</font> the number of requests from the list  
<font face="sans-serif"> array_of_requests</font> that have completed.  Returns in the first  
<font face="sans-serif"> outcount</font> locations of the array <font face="sans-serif"> array_of_indices</font>  
the indices of these operations (index within the  
array <font face="sans-serif"> array_of_requests</font>; the array is indexed from zero in  
C and from one in  
Fortran).  Returns in the first <font face="sans-serif"> outcount</font>  
locations of the array <font face="sans-serif"> array_of_status</font>  
the status for these completed operations.  If a request that completed was  
allocated by a nonblocking communication call, then it is deallocated, and the  
associated handle is set to <font face="sans-serif">  MPI_REQUEST_NULL</font>.  
<P> 
  
If the list contains no active handles, then the  
call returns immediately with <font face="sans-serif"> outcount =</font> <font face="sans-serif">  MPI_UNDEFINED</font>.  
<P> 
When one or more of the communications completed by  
<font face="sans-serif"> MPI_WAITSOME</font> fails, then it is desirable to return specific   
information on each communication.  
The arguments <font face="sans-serif"> outcount</font>,  
<font face="sans-serif"> array_of_indices</font> and <font face="sans-serif"> array_of_statuses</font> will be  
adjusted to indicate completion of all communications that have  
succeeded or failed.  The call will return the error code  
<font face="sans-serif">  MPI_ERR_IN_STATUS</font> and the error field of each status  
returned will be set to indicate success or to indicate the specific error  
that occurred.  The call will return <font face="sans-serif">  MPI_SUCCESS</font> if no request  
resulted in an error,  
and will return another error code if it failed  
for other reasons (such as invalid arguments).  In such cases, it will  
not update the error fields of the statuses.  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TESTSOME(incount, array_of_requests, outcount,  
array_of_indices, array_of_statuses)</TD></TR>  
<TR><TD> IN incount</TD><TD>length of array_of_requests (non-negative  
integer)</TD></TR>  
<TR><TD> INOUT array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD> OUT outcount</TD><TD>number of completed requests (integer)</TD></TR>  
<TR><TD> OUT array_of_indices</TD><TD>array of indices of operations that  
completed (array of integers)</TD></TR>  
<TR><TD> OUT array_of_statuses</TD><TD>array of status objects for  
    operations that completed (array of Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Testsome(int incount, MPI_Request *array_of_requests, int *outcount, int *array_of_indices, MPI_Status *array_of_statuses) <BR></tt>  
<P> 
 <tt> MPI_TESTSOME(INCOUNT, ARRAY_OF_REQUESTS, OUTCOUNT, ARRAY_OF_INDICES, ARRAY_OF_STATUSES, IERROR)<BR> INTEGER INCOUNT, ARRAY_OF_REQUESTS(*), OUTCOUNT, ARRAY_OF_INDICES(*), ARRAY_OF_STATUSES(MPI_STATUS_SIZE,*), IERROR <BR></tt>  
 <font color="red">{<font color="black"> static int MPI::Request::Testsome(int incount, MPI::Request array_of_requests[], int array_of_indices[], MPI::Status array_of_statuses[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> static int MPI::Request::Testsome(int incount, MPI::Request array_of_requests[], int array_of_indices[]) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Behaves like <font face="sans-serif"> MPI_WAITSOME</font>, except that it returns  
immediately. If no operation has completed it  
returns <font face="sans-serif"> outcount = 0</font>.  
  
If there is no active handle in the list it  
returns <font face="sans-serif"> outcount =</font> <font face="sans-serif">  MPI_UNDEFINED</font>.  
  
<P> 
<font face="sans-serif"> MPI_TESTSOME</font> is a local operation, which returns  
immediately, whereas  
<font face="sans-serif"> MPI_WAITSOME</font> will   
block until a communication completes, if it was  
passed a list that contains at least one active handle.  Both calls fulfill a  
<font face="sans-serif"> fairness</font> requirement:  If a request for a receive repeatedly  
appears in a list of requests passed to <font face="sans-serif"> MPI_WAITSOME</font> or  
<font face="sans-serif"> MPI_TESTSOME</font>, and a matching send has been posted, then the receive  
will eventually succeed, unless the send is satisfied by another receive; and  
similarly for send requests.  
<P> 
  
Errors that occur during the execution of <font face="sans-serif"> MPI_TESTSOME</font> are  
handled as for <BR><font face="sans-serif"> MPI_WAITSOME</font>.  
  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
The use of <font face="sans-serif"> MPI_TESTSOME</font> is likely to be more efficient than the use  
of <font face="sans-serif"> MPI_TESTANY</font>. The former returns information on all  
completed communications, with the latter, a new call is required for  
each communication that completes.  
<P> 
A server with multiple clients can use <font face="sans-serif"> MPI_WAITSOME</font> so as not to  
starve any client.   Clients send messages to the server with service  
requests. The server calls <font face="sans-serif"> MPI_WAITSOME</font> with one receive request  
for each client, and then handles all receives that completed.  
If a call to <font face="sans-serif"> MPI_WAITANY</font> is used instead, then one client  
could starve while requests from another client always sneak in first.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
<font face="sans-serif"> MPI_TESTSOME</font> should complete as many pending communications as  
possible.  
 (<em> End of advice to implementors.</em>) <BR> 
<BR><b> Example</b>   
  
  
  
  
  
  
Client-server code (starvation can occur).  
<P><IMG WIDTH=428 HEIGHT=279 SRC="img7.gif"><P>
   
  
<P> 
<BR><b> Example</b>   
  
  
  
  
  
  
Same code, using <font face="sans-serif"> MPI_WAITSOME</font>.  
<BR> 
<pre><tt>CALL MPI_COMM_SIZE(comm, size, ierr) 
CALL MPI_COMM_RANK(comm, rank, ierr) 
IF(rank .GT. 0) THEN         ! client code 
    DO WHILE(.TRUE.) 
       CALL MPI_ISEND(a, n, MPI_REAL, 0, tag, comm, request, ierr) 
       CALL MPI_WAIT(request, status, ierr) 
    END DO 
ELSE         ! rank=0 -- server code 
    DO i=1, size-1 
       CALL MPI_IRECV(a(1,i), n, MPI_REAL, i, tag, 
                      comm, request_list(i), ierr) 
    END DO 
    DO WHILE(.TRUE.) 
       CALL MPI_WAITSOME(size, request_list, numdone, 
                        indices, statuses, ierr) 
       DO i=1, numdone 
          CALL DO_SERVICE(a(1, indices(i))) 
          CALL MPI_IRECV(a(1, indices(i)), n, MPI_REAL, 0, tag, 
                       comm, request_list(indices(i)), ierr) 
       END DO 
    END DO 
END IF 
</tt></pre> 
   
  
<P> 

<P>
<HR>
<A HREF="node61.htm#Node61"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node57.htm#Node57"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node63.htm#Node63"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node57.htm#Node57"> Nonblocking Communication</a>
<b>Next: </b><A HREF="node63.htm#Node63"> Non-destructive Test of <font face="sans-serif"> status</font></a>
<b>Previous: </b><A HREF="node61.htm#Node61"> Semantics of Nonblocking Communications</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
