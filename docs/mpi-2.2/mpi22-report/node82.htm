<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Decoding a Datatype</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node82">81. Decoding a Datatype</a></H2>
<A HREF="node81.htm#Node81"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node69.htm#Node69"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node83.htm#Node83"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node69.htm#Node69"> Derived Datatypes</a>
<b>Next: </b><A HREF="node83.htm#Node83"> Examples</a>
<b>Previous: </b><A HREF="node81.htm#Node81"> Correct Use of Addresses</a>
<P>
  
  
<P> 
<font face="sans-serif"> MPI</font>   
datatype objects   
allow users to specify  
an arbitrary layout of data in memory.  
There are several cases  
where accessing the layout information in  
opaque datatype objects would be useful.   
The opaque datatype  
object has found a number of uses outside <font face="sans-serif"> MPI</font>.  Furthermore, a  
number of tools wish to display internal information about a datatype.  
To achieve this, datatype decoding functions are provided.  
The two functions in this section are used together to decode datatypes  
to recreate the calling sequence used in their initial definition.  
These can be used to allow a user to determine the type map and type  
signature of a datatype.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_GET_ENVELOPE(datatype, num_integers,  
num_addresses, num_datatypes, combiner)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype to access (handle)</TD></TR>  
<TR><TD> OUT num_integers</TD><TD>number of input integers used in the call  
constructing <font face="sans-serif"> combiner</font> (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> OUT num_addresses</TD><TD>number of input addresses used in the call  
constructing <font face="sans-serif"> combiner</font> (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> OUT num_datatypes</TD><TD>number of input datatypes used in the call  
constructing <font face="sans-serif"> combiner</font> (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> OUT combiner</TD><TD>combiner (state)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_get_envelope(MPI_Datatype datatype, int *num_integers, int *num_addresses, int *num_datatypes, int *combiner) <BR></tt>  
<P> 
 <tt> MPI_TYPE_GET_ENVELOPE(DATATYPE, NUM_INTEGERS, NUM_ADDRESSES, NUM_DATATYPES, COMBINER, IERROR)<BR> INTEGER DATATYPE, NUM_INTEGERS, NUM_ADDRESSES, NUM_DATATYPES, COMBINER, IERROR <BR></tt>  
<P> 
 <font color="red">{<font color="black"> void MPI::Datatype::Get_envelope(int&amp; num_integers, int&amp; num_addresses, int&amp; num_datatypes, int&amp; combiner) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
For the given <font face="sans-serif"> datatype</font>,  
<font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> returns information on the  
number and type of input arguments used in the call that created the  
<font face="sans-serif"> datatype</font>.  The number-of-arguments values returned can be  
used to provide sufficiently large arrays in the decoding routine  
<font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font>.  This call and the meaning of the  
  
returned values is described below.  The <font face="sans-serif"> combiner</font> reflects  
  
the <font face="sans-serif"> MPI</font> datatype constructor call that was used in creating  
<font face="sans-serif"> datatype</font>.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
  
By requiring that the <font face="sans-serif"> combiner</font> reflect the constructor used  
in the creation  
of the <font face="sans-serif"> datatype</font>, the decoded information can be used  
to effectively recreate the calling sequence used in the original  
creation.    
One call is effectively the same as another when the information obtained  
from <font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font> may be used with either to produce  
the same outcome.  C calls <font face="sans-serif"> MPI_Type_hindexed</font> and <font face="sans-serif"> MPI_Type_create_hindexed</font> are  
always effectively the same while the Fortran call <font face="sans-serif"> MPI_TYPE_HINDEXED</font> will  
be different than either of these in some <font face="sans-serif"> MPI</font> implementations.  
  
  
This is the most useful information and    
  
was  
felt to be reasonable even though it constrains implementations to  
remember the original constructor sequence even if the internal  
representation is different.  
<P> 
  
The decoded information keeps track of datatype duplications.  This is  
important as one needs to distinguish between a predefined datatype  
and a dup of a predefined datatype.  The former is a constant object  
that cannot be freed, while the latter is a derived datatype that can  
be freed.  
  
 (<em> End of rationale.</em>) <BR> 
The list below has the values that can be returned in  
<font face="sans-serif"> combiner</font> on the left and the call associated with them on the  
right.  
<P> 
<CENTER>   
<P><A NAME="node80.htm#Equation2"><IMG WIDTH=392 HEIGHT=390 SRC="img47.gif"></a><P>
</CENTER>   
<BR> 
<font face="sans-serif"> combiner</font> values returned from <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> 
<P> 
   
  
  
If <font face="sans-serif"> combiner</font> is <font face="sans-serif">  MPI_COMBINER_NAMED</font> then <font face="sans-serif"> datatype</font> is a  
named predefined datatype.    
<P> 
  
For  
deprecated  
 calls with address arguments, we sometimes need to differentiate whether the  
call used an integer or an address size argument.  For example, there are two  
combiners for hvector: <font face="sans-serif">  MPI_COMBINER_HVECTOR_INTEGER</font> and  
<font face="sans-serif">  MPI_COMBINER_HVECTOR</font>.  The former is used if   
it was the <font face="sans-serif"> MPI-1</font> call from Fortran, and the latter is used if it was the  
<font face="sans-serif"> MPI-1</font> call from C or C++.    
However, on systems where <font face="sans-serif">  MPI_ADDRESS_KIND</font> = <font face="sans-serif">  MPI_INTEGER_KIND</font> (i.e., where integer arguments and address size  
arguments are the same), the combiner <font face="sans-serif">  MPI_COMBINER_HVECTOR</font>  
may be returned for a datatype constructed by a call to  
<font face="sans-serif"> MPI_TYPE_HVECTOR</font> from Fortran.  Similarly,  
<font face="sans-serif">  MPI_COMBINER_HINDEXED</font> may be returned for a datatype  
constructed by a call to <font face="sans-serif"> MPI_TYPE_HINDEXED</font> from Fortran,  
and <font face="sans-serif">  MPI_COMBINER_STRUCT</font> may be returned for a datatype  
constructed by a call to <font face="sans-serif"> MPI_TYPE_STRUCT</font> from Fortran. On  
such systems, one need not differentiate constructors that take  
address size arguments from constructors that take integer arguments,  
since these are the same.  
The  
preferred  
 calls all use address sized  
arguments  
so two combiners are not required for them.  
  
  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
For recreating the original call, it is important to know if address  
information may have been truncated.  The   
deprecated  
calls from Fortran for a few  
routines could be  
subject to truncation in the case where the default <tt> INTEGER</tt> size is  
smaller than the size of an address.   
 (<em> End of rationale.</em>) <BR> 
The actual arguments used in the creation call for a <font face="sans-serif"> datatype</font>  
can be obtained from the call:  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_GET_CONTENTS(datatype, max_integers,  
max_addresses,  max_datatypes,  array_of_integers, array_of_addresses, array_of_datatypes)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype to access (handle)</TD></TR>  
<TR><TD> IN max_integers</TD><TD>number of elements in <font face="sans-serif"> array_of_integers</font> (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> IN max_addresses</TD><TD>number of elements in <font face="sans-serif"> array_of_addresses</font> (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> IN max_datatypes</TD><TD>number of elements in <font face="sans-serif"> array_of_datatypes</font> (<font color="red">non-negative<font color="black"> integer)</TD></TR>  
<TR><TD> OUT array_of_integers</TD><TD>contains integer arguments used in constructing <font face="sans-serif"> datatype</font> (array of integers)</TD></TR>  
<TR><TD> OUT array_of_addresses</TD><TD>contains address arguments used in constructing <font face="sans-serif"> datatype</font> (array of integers)</TD></TR>  
<TR><TD> OUT array_of_datatypes</TD><TD>contains datatype arguments used in constructing <font face="sans-serif"> datatype</font> (array of handles)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_get_contents(MPI_Datatype datatype, int max_integers, int max_addresses, int max_datatypes, int array_of_integers[], MPI_Aint array_of_addresses[], MPI_Datatype array_of_datatypes[]) <BR></tt>  
<P> 
 <tt> MPI_TYPE_GET_CONTENTS(DATATYPE, MAX_INTEGERS, MAX_ADDRESSES, MAX_DATATYPES, ARRAY_OF_INTEGERS, ARRAY_OF_ADDRESSES, ARRAY_OF_DATATYPES, IERROR)<BR> INTEGER DATATYPE, MAX_INTEGERS, MAX_ADDRESSES, MAX_DATATYPES, ARRAY_OF_INTEGERS(*), ARRAY_OF_DATATYPES(*), IERROR <BR>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_ADDRESSES(*) <BR></tt>  
<P> 
 <font color="red">{<font color="black"> void MPI::Datatype::Get_contents(int max_integers, int max_addresses, int max_datatypes, int array_of_integers[], MPI::Aint array_of_addresses[], MPI::Datatype array_of_datatypes[]) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
  
<font face="sans-serif"> datatype</font> must be a predefined unnamed or a derived datatype;  
the call is erroneous if <font face="sans-serif"> datatype</font> is a predefined named  
datatype.  
  
<P> 
The values given for <font face="sans-serif"> max_integers</font>, <font face="sans-serif"> max_addresses</font>, and  
<font face="sans-serif"> max_datatypes</font> must be at least as large as the value  
returned in <font face="sans-serif"> num_integers</font>, <font face="sans-serif"> num_addresses</font>, and  
<font face="sans-serif"> num_datatypes</font>, respectively, in the call <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font>  
for the same <font face="sans-serif"> datatype</font> argument.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The arguments <font face="sans-serif"> max_integers</font>, <font face="sans-serif"> max_addresses</font>, and  
<font face="sans-serif"> max_datatypes</font> allow for error checking in the   
call.  
 (<em> End of rationale.</em>) <BR> 
  
The datatypes returned in <font face="sans-serif"> array_of_datatypes</font> are handles to  
datatype objects that are equivalent to the datatypes used in the  
original construction call.  If these were derived datatypes, then  
the returned datatypes are new datatype objects, and the  
user is responsible for freeing these datatypes with  
<font face="sans-serif"> MPI_TYPE_FREE</font>.    
If these were predefined datatypes, then  
the returned datatype is equal to that (constant) predefined datatype  
and cannot be freed.  
<P> 
The committed state of returned derived datatypes is undefined,   
i.e., the datatypes may or  
may not be committed.  Furthermore, the content of attributes of  
returned datatypes is undefined.  
<P> 
Note that <font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font> can be invoked with a   
<font face="sans-serif"> datatype</font> argument that was constructed using  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>,  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_INTEGER</font>, or  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_COMPLEX</font>  (an unnamed predefined datatype).  
In such a case, an empty <font face="sans-serif"> array_of_datatypes</font> is returned.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The definition of datatype equivalence implies that equivalent  
predefined datatypes are equal.  
By requiring the same handle for named predefined datatypes, it is  
possible to use the <tt> ==</tt> or <tt> .EQ.</tt> comparison operator to determine the  
datatype involved.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
  
The datatypes returned in <font face="sans-serif"> array_of_datatypes</font> must appear to the  
user as if each is an equivalent copy of the datatype used in the type  
constructor call.  
  
Whether this is done by  
creating a new datatype or via another mechanism such as a reference  
count mechanism is up to the implementation as long as the semantics  
are preserved.  
 (<em> End of advice to implementors.</em>) <BR> 
  
 
<BR> 
<em> Rationale.</em>  
<P> 
The committed state and attributes of the returned datatype is  
deliberately left vague.  The datatype used in the original  
construction may have been modified since its use in the constructor  
call.  Attributes can be added, removed, or modified as well as having  
the datatype committed.  The semantics given allow for a  
reference count implementation without having to track these changes.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
In the  
deprecated  
 datatype constructor calls, the address arguments in Fortran are of  
type <tt> INTEGER</tt>.  In the   
preferred  
calls, the address arguments are of  
type <tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt>.  The call  
<font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font> returns all addresses in an argument  
of type <tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt>.  This is true even if the  
deprecated  
 calls were used.  Thus, the location of values returned can  
be thought of as being returned by the C bindings.  It can also be  
determined by examining the  
preferred  
 calls for datatype constructors  
for the   
deprecated   
calls that involve addresses.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
By having all address arguments returned in the  
<font face="sans-serif"> array_of_addresses</font> argument, the result from a C and Fortran  
decoding of a <font face="sans-serif"> datatype</font> gives the result in the same   
argument.  It is assumed that an integer  
of type <tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt> will be at least as large as   
the <tt> INTEGER</tt> argument used in datatype construction with the old <font face="sans-serif"> MPI-1</font>  
calls so no loss of information will occur.  
 (<em> End of rationale.</em>) <BR> 
The following defines what values are placed in each entry of the  
returned arrays depending on the datatype constructor used for  
<font face="sans-serif"> datatype</font>.  It also specifies the size of the arrays needed  
which is the values returned by <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font>.  
In Fortran, the following calls were made:  
<P> 
<P><IMG WIDTH=428 HEIGHT=159 SRC="img48.gif"><P>
  
or in C the analogous calls of:  
<P> 
<BR> 
<pre><tt>#define LARGE 1000 
int ni, na, nd, combiner, i[LARGE]; 
MPI_Aint a[LARGE]; 
MPI_Datatype type, d[LARGE]; 
/* construct datatype type (not shown) */ 
MPI_Type_get_envelope(type, &amp;ni, &amp;na, &amp;nd, &amp;combiner); 
if ((ni &gt; LARGE) || (na &gt; LARGE) || (nd &gt; LARGE)) { 
  fprintf(stderr, "ni, na, or nd = %d %d %d returned by ", ni, na, nd); 
  fprintf(stderr, "MPI_Type_get_envelope is larger than LARGE = %d\n",  
          LARGE); 
  MPI_Abort(MPI_COMM_WORLD, 99); 
}; 
MPI_Type_get_contents(type, ni, na, nd, i, a, d); 
</tt></pre> 
The C++ code is in analogy to the C code above with the same values returned.  
<P> 
In the descriptions that follow, the lower case name   
  
of arguments  
  
is used.  
<P> 
  
If combiner is <font face="sans-serif">  MPI_COMBINER_NAMED</font> then  
it is erroneous to call <font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font>.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_DUP</font> then   
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">  C &amp; C++ location</TD><TD ALIGN="LEFT">    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
oldtype</TD><TD ALIGN="CENTER">               d[0]</TD><TD ALIGN="LEFT">          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 0, na = 0, nd = 1.  
  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_CONTIGUOUS</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">  C &amp; C++ location</TD><TD ALIGN="LEFT">    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
count</TD><TD ALIGN="CENTER">                 i[0]</TD><TD ALIGN="LEFT">          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">               d[0]</TD><TD ALIGN="LEFT">          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 1, na = 0, nd = 1.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_VECTOR</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">  C &amp; C++ location</TD><TD ALIGN="LEFT">    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
count</TD><TD ALIGN="CENTER">                 i[0]</TD><TD ALIGN="LEFT">          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
blocklength</TD><TD ALIGN="CENTER">           i[1]</TD><TD ALIGN="LEFT">          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
stride</TD><TD ALIGN="CENTER">                i[2]</TD><TD ALIGN="LEFT">          I(3)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">               d[0]</TD><TD ALIGN="LEFT">          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 3, na = 0, nd = 1.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_HVECTOR_INTEGER</font> or <font face="sans-serif">  MPI_COMBINER_HVECTOR</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">  C &amp; C++ location</TD><TD ALIGN="LEFT">    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
count</TD><TD ALIGN="CENTER">                 i[0]</TD><TD ALIGN="LEFT">          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
blocklength</TD><TD ALIGN="CENTER">           i[1]</TD><TD ALIGN="LEFT">          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
stride</TD><TD ALIGN="CENTER">                a[0]</TD><TD ALIGN="LEFT">          A(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">               d[0]</TD><TD ALIGN="LEFT">          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 2, na = 1, nd = 1.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_INDEXED</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
count</TD><TD ALIGN="CENTER">       i[0]</TD><TD ALIGN="LEFT">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_blocklengths</TD><TD ALIGN="CENTER">       i[1] to i[i[0]]</TD><TD ALIGN="LEFT">               I(2) to I(I(1)+1)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_displacements</TD><TD ALIGN="CENTER">      i[i[0]+1] to i[2*i[0]]</TD><TD ALIGN="LEFT">        I(I(1)+2) to I(2*I(1)+1)        </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="LEFT">                          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 2*count+1, na = 0, nd = 1.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_HINDEXED_INTEGER</font> or <font face="sans-serif">  MPI_COMBINER_HINDEXED</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
count</TD><TD ALIGN="CENTER">       i[0]</TD><TD ALIGN="LEFT">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_blocklengths</TD><TD ALIGN="CENTER">       i[1] to i[i[0]]</TD><TD ALIGN="LEFT">               I(2) to I(I(1)+1)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_displacements</TD><TD ALIGN="CENTER">      a[0] to a[i[0]-1]</TD><TD ALIGN="LEFT">             A(1) to A(I(1))                 </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="LEFT">                          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = count+1, na = count, nd = 1.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_INDEXED_BLOCK</font> then  
<P> 
  
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
count</TD><TD ALIGN="CENTER">       i[0]</TD><TD ALIGN="LEFT">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
blocklength</TD><TD ALIGN="CENTER">       i[1]</TD><TD ALIGN="LEFT">                          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_displacements</TD><TD ALIGN="CENTER">      i[2] to i[i[0]+1]</TD><TD ALIGN="LEFT">             I(3) to I(I(1)+2)    </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="LEFT">                          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
  
<BR>  
and ni = count+2, na = 0, nd = 1.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_STRUCT_INTEGER</font> or <font face="sans-serif">  MPI_COMBINER_STRUCT</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
count</TD><TD ALIGN="CENTER">                         i[0]</TD><TD ALIGN="LEFT">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_blocklengths</TD><TD ALIGN="CENTER">       i[1] to i[i[0]]</TD><TD ALIGN="LEFT">               I(2) to I(I(1)+1)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_displacements</TD><TD ALIGN="CENTER">      a[0] to a[i[0]-1]</TD><TD ALIGN="LEFT">             A(1) to A(I(1))                 </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_types</TD><TD ALIGN="CENTER">              d[0] to d[i[0]-1]</TD><TD ALIGN="LEFT">             D(1) to D(I(1))                 </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = count+1, na = count, nd = count.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_SUBARRAY</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
ndims</TD><TD ALIGN="CENTER">                         i[0]</TD><TD ALIGN="LEFT">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_sizes</TD><TD ALIGN="CENTER">              i[1] to i[i[0]]</TD><TD ALIGN="LEFT">               I(2) to I(I(1)+1)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_subsizes</TD><TD ALIGN="CENTER">           i[i[0]+1] to i[2*i[0]]</TD><TD ALIGN="LEFT">        I(I(1)+2) to I(2*I(1)+1)        </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_starts</TD><TD ALIGN="CENTER">             i[2*i[0]+1] to i[3*i[0]]</TD><TD ALIGN="LEFT">      I(2*I(1)+2) to I(3*I(1)+1)      </TD></TR> 
<TR><TD ALIGN="LEFT">  
order</TD><TD ALIGN="CENTER">                         i[3*i[0]+1]</TD><TD ALIGN="LEFT">                   I(3*I(1)+2]                     </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="LEFT">                          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 3*ndims+2, na = 0, nd = 1.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_DARRAY</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
size</TD><TD ALIGN="CENTER">                          i[0]</TD><TD ALIGN="LEFT">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
rank</TD><TD ALIGN="CENTER">                          i[1]</TD><TD ALIGN="LEFT">                          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
ndims</TD><TD ALIGN="CENTER">                         i[2]</TD><TD ALIGN="LEFT">                          I(3)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_gsizes</TD><TD ALIGN="CENTER">             i[3] to i[i[2]+2]</TD><TD ALIGN="LEFT">             I(4) to I(I(3)+3)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_distribs</TD><TD ALIGN="CENTER">           i[i[2]+3] to i[2*i[2]+2]</TD><TD ALIGN="LEFT">      I(I(3)+4) to I(2*I(3)+3)        </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_dargs</TD><TD ALIGN="CENTER">              i[2*i[2]+3] to i[3*i[2]+2]</TD><TD ALIGN="LEFT">    I(2*I(3)+4) to I(3*I(3)+3)      </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_psizes</TD><TD ALIGN="CENTER">             i[3*i[2]+3] to i[4*i[2]+2]</TD><TD ALIGN="LEFT">    I(3*I(3)+4) to I(4*I(3)+3)      </TD></TR> 
<TR><TD ALIGN="LEFT">  
order</TD><TD ALIGN="CENTER">                         i[4*i[2]+3]</TD><TD ALIGN="LEFT">                   I(4*I(3)+4)                     </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="LEFT">                          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 4*ndims+4, na = 0, nd = 1.  
<P> 
  
If combiner is <font face="sans-serif">  MPI_COMBINER_F90_REAL</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
p</TD><TD ALIGN="CENTER">                             i[0]</TD><TD ALIGN="LEFT">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
r</TD><TD ALIGN="CENTER">                             i[1]</TD><TD ALIGN="LEFT">                          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 2, na = 0, nd = 0.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_F90_COMPLEX</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
p</TD><TD ALIGN="CENTER">                             i[0]</TD><TD ALIGN="LEFT">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
r</TD><TD ALIGN="CENTER">                             i[1]</TD><TD ALIGN="LEFT">                          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 2, na = 0, nd = 0.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_F90_INTEGER</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
r</TD><TD ALIGN="CENTER">                             i[0]</TD><TD ALIGN="LEFT">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 1, na = 0, nd = 0.  
<P> 
If combiner is <font face="sans-serif">  MPI_COMBINER_RESIZED</font> then  
<P> 
  
<CENTER>  
<TABLE><TR><TD ALIGN="LEFT">  
Constructor argument</TD><TD ALIGN="CENTER">          C &amp; C++ location</TD><TD ALIGN="LEFT">                    Fortran location                </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
lb</TD><TD ALIGN="CENTER">                            a[0]</TD><TD ALIGN="LEFT">                          A(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
extent</TD><TD ALIGN="CENTER">                        a[1]</TD><TD ALIGN="LEFT">                          A(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="LEFT">                          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</CENTER>  
  
<BR>  
and ni = 0, na = 2, nd = 1.  
  
<P> 
  

<P>
<HR>
<A HREF="node81.htm#Node81"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node69.htm#Node69"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node83.htm#Node83"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node69.htm#Node69"> Derived Datatypes</a>
<b>Next: </b><A HREF="node83.htm#Node83"> Examples</a>
<b>Previous: </b><A HREF="node81.htm#Node81"> Correct Use of Addresses</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
