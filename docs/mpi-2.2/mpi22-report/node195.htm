<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-inquiry/inquiry.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Startup</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node195">184. Startup</a></H1>
<A HREF="node194.htm#Node194"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node196.htm#Node196"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node196.htm#Node196"> Allowing User Functions at Process Termination</a>
<b>Previous: </b><A HREF="node194.htm#Node194"> Timers and Synchronization</a>
<P>
  
  
  
    
One goal of <font face="sans-serif"> MPI</font> is to achieve <em> source code portability</em>.  By this we mean  
that a program written using <font face="sans-serif"> MPI</font> and complying with the relevant language  
standards is portable as written, and must not require any source code changes  
when moved from one system to another.  This explicitly does <em> not</em> say  
anything about how an <font face="sans-serif"> MPI</font> program is started or launched from the command  
line, nor what the user must do to set up the environment in which an <font face="sans-serif"> MPI</font>  
program will run.  However, an implementation may require some setup to be  
performed before other <font face="sans-serif"> MPI</font> routines may be called.  To provide for this, <font face="sans-serif"> MPI</font>  
includes an initialization routine <font face="sans-serif"> MPI_INIT</font>.  
<P> 
<P><IMG WIDTH=53 HEIGHT=11 SRC="img126.gif"><P>
 <tt> int MPI_Init(int *argc, char ***argv) <BR></tt>  
<P> 
 <tt> MPI_INIT(IERROR)<BR> INTEGER IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Init(int&amp; argc, char**&amp; argv) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> void MPI::Init() <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
<font color="red">All <font face="sans-serif"> MPI</font> programs must contain exactly one call to an <font face="sans-serif"> MPI</font> initialization routine:  
<font face="sans-serif"> MPI_INIT</font> or <font face="sans-serif"> MPI_INIT_THREAD</font>. Subsequent calls to any  
initialization routines are erroneous. The only <font face="sans-serif"> MPI</font> functions that may be invoked  
before the <font face="sans-serif"> MPI</font> initialization routines are called are <font face="sans-serif"> MPI_GET_VERSION</font>,  
<font face="sans-serif"> MPI_INITIALIZED</font>, and <font face="sans-serif"> MPI_FINALIZED</font>. The version for ISO C  
accepts the <font face="sans-serif"> argc</font> and <font face="sans-serif"> argv</font> that are provided by the arguments to  
<tt>main</tt> or <font face="sans-serif"> NULL</font>:  
<font color="black">  
<P><IMG WIDTH=415 HEIGHT=144 SRC="img127.gif"><P>
  
The Fortran version takes only <font face="sans-serif">  IERROR</font>.  
<P> 
Conforming implementations of <font face="sans-serif"> MPI</font> are required to allow  
applications to pass <font face="sans-serif"> NULL</font> for both the <font face="sans-serif"> argc</font> and  
<font face="sans-serif"> argv</font> arguments of <font face="sans-serif"> main</font> in C and C++.  In C++, there is an alternative  
binding for <font face="sans-serif"> MPI::Init</font> that does not have these arguments at all.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
In some applications, libraries may be making the call to <font face="sans-serif"> MPI_Init</font>,  
and may not have access to <font face="sans-serif"> argc</font> and <font face="sans-serif"> argv</font> from <font face="sans-serif"> main</font>.  
It is anticipated that applications requiring special information about  
the environment or information supplied by <tt> mpiexec</tt> can get that  
information from environment variables.  
 (<em> End of rationale.</em>) <BR> 
  
  
<P><IMG WIDTH=78 HEIGHT=11 SRC="img128.gif"><P>
 <tt> int MPI_Finalize(void) <BR></tt>  
<P> 
 <tt> MPI_FINALIZE(IERROR)<BR> INTEGER IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Finalize() <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
This routine cleans up all <font face="sans-serif"> MPI</font> state.  
  
  
Each process must call <font face="sans-serif"> MPI_FINALIZE</font> before it exits.  
Unless there has been a call to <font face="sans-serif"> MPI_ABORT</font>, each process must ensure that all pending <font color="red">nonblocking<font color="black">  
communications are (locally) complete before calling <font face="sans-serif"> MPI_FINALIZE</font>.  
Further, at the instant at which the last process calls  
<font face="sans-serif"> MPI_FINALIZE</font>, all pending sends must be matched by a receive, and  
all pending receives must be matched by a send.  
<P> 
For example, the following program is correct:  
<BR> 
<pre><tt>        Process 0                Process 1 
        ---------                --------- 
        MPI_Init();              MPI_Init(); 
        MPI_Send(dest=1);        MPI_Recv(src=0); 
        MPI_Finalize();          MPI_Finalize(); 
</tt></pre> 
Without the matching receive, the program is erroneous:  
<BR> 
<pre><tt>        Process 0                Process 1 
        -----------              ----------- 
        MPI_Init();              MPI_Init(); 
        MPI_Send (dest=1); 
        MPI_Finalize();          MPI_Finalize(); 
</tt></pre> 
  
<P> 
A successful return from a blocking communication operation or from  
<font face="sans-serif"> MPI_WAIT</font> or <font face="sans-serif"> MPI_TEST</font> tells the user that the buffer can  
be reused and means that the communication is completed by the user, but does  
not guarantee that the local process has no more work to do.  
A successful return from <font face="sans-serif"> MPI_REQUEST_FREE</font> with a request handle  
generated by an <font face="sans-serif"> MPI_ISEND</font> nullifies the handle but provides no  
assurance of operation completion.  The <font face="sans-serif"> MPI_ISEND</font> is complete only when it is  
known by some means that a matching receive has completed.  
<font face="sans-serif"> MPI_FINALIZE</font> guarantees that all local actions required by  
communications the user has completed will, in fact, occur before it returns.  
<P> 
<font face="sans-serif"> MPI_FINALIZE</font> guarantees nothing about pending communications that  
have not been completed (completion is assured only by <font face="sans-serif"> MPI_WAIT</font>,  
<font face="sans-serif"> MPI_TEST</font>, or <font face="sans-serif"> MPI_REQUEST_FREE</font> combined with some other  
verification of completion).  
<P> 
<BR><b> Example</b>  
  
  
  
   This program is correct:  
<BR> 
<pre><tt>rank 0                          rank 1 
===================================================== 
...                             ... 
MPI_Isend();                    MPI_Recv(); 
MPI_Request_free();             MPI_Barrier(); 
MPI_Barrier();                  MPI_Finalize(); 
MPI_Finalize();                 exit(); 
exit(); 
</tt></pre> 
  
<P> 
<BR><b> Example</b>  
  
  
   This program is erroneous and its behavior is undefined:  
<BR> 
<pre><tt>rank 0                          rank 1 
===================================================== 
...                             ... 
MPI_Isend();                    MPI_Recv(); 
MPI_Request_free();             MPI_Finalize(); 
MPI_Finalize();                 exit(); 
exit(); 
</tt></pre> 
  
<P> 
If no <font face="sans-serif"> MPI_BUFFER_DETACH</font> occurs between an <font face="sans-serif"> MPI_BSEND</font> (or  
other buffered send) and  
<font face="sans-serif"> MPI_FINALIZE</font>, the <font face="sans-serif"> MPI_FINALIZE</font> implicitly supplies  
the <font face="sans-serif"> MPI_BUFFER_DETACH</font>.  
<P> 
<BR><b> Example</b>  
  
  
   This program is correct, and after the <font face="sans-serif"> MPI_Finalize</font>, it is  
    as if the buffer had been detached.  
<BR> 
<pre><tt>rank 0                          rank 1 
===================================================== 
...                             ... 
buffer = malloc(1000000);       MPI_Recv(); 
MPI_Buffer_attach();            MPI_Finalize(); 
MPI_Bsend();                    exit(); 
MPI_Finalize(); 
free(buffer); 
exit(); 
</tt></pre> 
  
<P> 
<BR><b> Example</b>  
  
  
  
  
  
   In this example, <font face="sans-serif"> MPI_Iprobe()</font> must return a <font face="sans-serif"> FALSE</font>  
    flag.  <font face="sans-serif"> MPI_Test_cancelled()</font> must return a <font face="sans-serif"> TRUE</font> flag,  
    independent of the relative order of execution of <font face="sans-serif"> MPI_Cancel()</font>  
    in process 0 and <font face="sans-serif"> MPI_Finalize()</font> in process 1.  
<P> 
The <font face="sans-serif"> MPI_Iprobe()</font> call is there to make sure the implementation  
    knows that the ``tag1'' message exists at the destination, without being  
    able to claim that the user knows about it.  
<P> 
<BR> 
<pre><tt>rank 0                          rank 1 
======================================================== 
MPI_Init();                     MPI_Init(); 
MPI_Isend(tag1); 
MPI_Barrier();                  MPI_Barrier(); 
                                MPI_Iprobe(tag2); 
MPI_Barrier();                  MPI_Barrier(); 
                                MPI_Finalize(); 
                                exit(); 
MPI_Cancel(); 
MPI_Wait(); 
MPI_Test_cancelled(); 
MPI_Finalize(); 
exit(); 
 
</tt></pre> 
  
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
An implementation may need to delay the return from <font face="sans-serif"> MPI_FINALIZE</font>  
   until all potential future message cancellations have been  
   processed.  One possible solution is to place a barrier inside  
   <font face="sans-serif"> MPI_FINALIZE</font>  
 (<em> End of advice to implementors.</em>) <BR> 
Once <font face="sans-serif"> MPI_FINALIZE</font> returns, no <font face="sans-serif"> MPI</font> routine (not even <font face="sans-serif"> MPI_INIT</font>) may  
be called, except for <font face="sans-serif"> MPI_GET_VERSION</font>, <font face="sans-serif"> MPI_INITIALIZED</font>,  
and <font face="sans-serif"> MPI_FINALIZED</font>.    
Each process must complete  
any pending communication it initiated before it calls  
<font face="sans-serif"> MPI_FINALIZE</font>.  If the call returns, each process may continue local  
computations, or exit, without participating in further <font face="sans-serif"> MPI</font> communication  
with other processes.    
<font face="sans-serif"> MPI_FINALIZE</font> is collective over all connected processes.  
If no processes were spawned, accepted or connected then this means  
over <font face="sans-serif">  MPI_COMM_WORLD</font>; otherwise it is collective over the  
union of all processes that have been and continue to be connected,  
as explained in Section <a href="node226.htm#Node226">Releasing Connections 
</a> on page <a href="node226.htm#Node226">Releasing Connections 
</a>.  
  
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Even though a process has completed all the communication it initiated, such  
  communication may not yet be completed from the viewpoint of the underlying  
  <font face="sans-serif"> MPI</font> system.  E.g., a blocking send may have completed, even though the data  
  is still buffered at the sender.  The <font face="sans-serif"> MPI</font> implementation must ensure that a  
  process has completed any involvement in <font face="sans-serif"> MPI</font> communication before  
  <font face="sans-serif"> MPI_FINALIZE</font> returns.  Thus, if a process exits after the call to  
  <font face="sans-serif"> MPI_FINALIZE</font>, this will not cause an ongoing communication to  
  fail.  
 (<em> End of advice to implementors.</em>) <BR> 
Although it is not required that all processes return from  
<font face="sans-serif"> MPI_FINALIZE</font>, it is required that at least process 0 in  
<font face="sans-serif">  MPI_COMM_WORLD</font> return, so  
that users can know that the <font face="sans-serif"> MPI</font> portion of the computation is over.  In  
addition, in a POSIX environment, they may desire to supply an exit code for  
each process that returns from <font face="sans-serif"> MPI_FINALIZE</font>.  
<P> 
<BR><b> Example</b>  
  
   The following illustrates the use of requiring that at least one  
    process return and that it be known that process 0 is one of the processes  
    that return.  One wants code like the following to work no matter how many  
    processes return.  
<P> 
<BR> 
<pre><tt>    ... 
    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank); 
    ... 
    MPI_Finalize(); 
    if (myrank == 0) { 
        resultfile = fopen("outfile","w"); 
        dump_results(resultfile); 
        fclose(resultfile); 
    } 
    exit(0); 
</tt></pre> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INITIALIZED( flag )</TD></TR>  
<TR><TD> OUT flag</TD><TD>F</TD></TR>lag is true if <font face="sans-serif"> MPI_INIT</font> has been called and false  
otherwise.  
</TABLE>  
<P> 
 <tt> int MPI_Initialized(int *flag) <BR></tt>  
<P> 
 <tt> MPI_INITIALIZED(FLAG, IERROR)<BR> LOGICAL FLAG <BR>INTEGER IERROR <BR></tt>  
 <font color="red">{<font color="black"> bool MPI::Is_initialized() <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
This routine may be used to determine whether <font face="sans-serif"> MPI_INIT</font> has been  
called.  
<font face="sans-serif"> MPI_INITIALIZED</font> returns <font face="sans-serif"> true</font> if the calling process has  
called <font face="sans-serif"> MPI_INIT</font>.  Whether <font face="sans-serif"> MPI_FINALIZE</font> has been  
called does not affect the behavior of <font face="sans-serif"> MPI_INITIALIZED</font>.  
  
It is one of the few routines that may be called before  
<font face="sans-serif"> MPI_INIT</font> is called.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_ABORT( comm, errorcode )</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator of tasks to abort</TD></TR>  
<TR><TD> IN errorcode</TD><TD>error code to return to invoking environment</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Abort(MPI_Comm comm, int errorcode) <BR></tt>  
<P> 
 <tt> MPI_ABORT(COMM, ERRORCODE, IERROR)<BR> INTEGER COMM, ERRORCODE, IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Comm::Abort(int errorcode) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
This routine makes a ``best attempt'' to abort all tasks in the group  
of <font face="sans-serif"> comm</font>.  
This function does not require that the invoking environment take any action  
with the error code.  However, a Unix or POSIX environment should handle this  
as a <tt>return errorcode</tt> from the main program.  
  
  
  
It may not be possible for an <font face="sans-serif"> MPI</font> implementation to abort only the  
processes represented by <font face="sans-serif"> comm</font> if this is a subset of the processes.  
In this case, the <font face="sans-serif"> MPI</font> implementation should attempt to abort all the connected  
processes but should not abort any unconnected processes.  
If no processes were spawned, accepted or connected then this has the effect  
of aborting all the processes associated with <font face="sans-serif">  MPI_COMM_WORLD</font>.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The communicator argument is provided to allow for future extensions of <font face="sans-serif"> MPI</font> to  
environments with, for example, dynamic process management.  In particular, it  
allows but does not require an <font face="sans-serif"> MPI</font> implementation to abort a subset of  
<font face="sans-serif">  MPI_COMM_WORLD</font>.   
 (<em> End of rationale.</em>) <BR> 
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
Whether the errorcode is returned from the executable or from the  
<font face="sans-serif"> MPI</font> process startup mechanism (e.g., <tt> mpiexec</tt>), is an aspect of quality  
of the <font face="sans-serif"> MPI</font> library but not mandatory.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Where possible, a high-quality implementation will try to return the  
errorcode from the <font face="sans-serif"> MPI</font> process startup mechanism  
(e.g. <tt> mpiexec</tt> or singleton init).  
 (<em> End of advice to implementors.</em>) <BR> 
  
<menu> 
</menu> 

<P>
<HR>
<A HREF="node194.htm#Node194"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi22-report.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node196.htm#Node196"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi22-report.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node196.htm#Node196"> Allowing User Functions at Process Termination</a>
<b>Previous: </b><A HREF="node194.htm#Node194"> Timers and Synchronization</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
