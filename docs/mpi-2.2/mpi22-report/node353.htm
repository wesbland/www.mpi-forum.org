<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Additional Support for Fortran Numeric Intrinsic Types</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node353">316. Additional Support for Fortran Numeric Intrinsic Types</a></H2>
<A HREF="node350.htm#Node352"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node341.htm#Node341"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node353.htm#Node354"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node341.htm#Node341"> Fortran Support</a>
<b>Next: </b><A HREF="node353.htm#Node354"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<b>Previous: </b><A HREF="node350.htm#Node352"> No Type Mismatch Problems for Subroutines with Choice Arguments</a>
<P>
  
  
<P> 
The routines in this section are part of Extended Fortran Support   
described in Section <a href="node350.htm#Node350">Extended Fortran Support 
</a>.  
<P> 
<font face="sans-serif"> MPI</font>   
provides a small number of named datatypes that correspond to  
named intrinsic types supported by C and Fortran. These include  
<font face="sans-serif">  MPI_INTEGER</font>, <font face="sans-serif">  MPI_REAL</font>, <font face="sans-serif">  MPI_INT</font>,  
<font face="sans-serif">  MPI_DOUBLE</font>, etc., as well as the optional types  
<font face="sans-serif">  MPI_REAL4</font>, <font face="sans-serif">  MPI_REAL8</font>, etc.  There is a one-to-one  
correspondence between language declarations and <font face="sans-serif"> MPI</font> types.  
<P> 
Fortran (starting with Fortran 90) provides so-called <tt> KIND</tt>-parameterized  
types. These types are declared using an intrinsic type (one of   
<tt> INTEGER</tt>, <tt> REAL</tt>, <tt> COMPLEX</tt>, <tt> LOGICAL</tt> and   
<tt> CHARACTER</tt>) with an optional integer  
<tt> KIND</tt> parameter that selects from among one or more variants.  
The specific meaning of different <tt> KIND</tt> values themselves are   
implementation dependent and not specified by the language.  
Fortran  
provides the <tt> KIND</tt> selection functions <tt> selected_real_kind</tt>   
for <tt> REAL</tt> and <tt> COMPLEX</tt> types, and  
<tt> selected_int_kind</tt> for <tt> INTEGER</tt> types  
that allow users to declare variables  
with a minimum precision or number of digits. These functions provide  
a portable way to declare <tt> KIND</tt>-parameterized <tt> REAL</tt>,  
<tt> COMPLEX</tt> and <tt> INTEGER</tt> variables in Fortran.   
  
This scheme is backward compatible with Fortran 77. <tt> REAL</tt> and  
<tt> INTEGER</tt> Fortran variables have a default <tt> KIND</tt> if none  
is specified. Fortran DOUBLE PRECISION variables are of  
intrinsic type <tt> REAL</tt> with a non-default <tt> KIND</tt>. The following  
two declarations are equivalent:  
<BR> 
<pre><tt>    double precision x 
    real(KIND(0.0d0)) x 
</tt></pre> 
<font face="sans-serif"> MPI</font> provides two orthogonal methods to communicate using  
numeric intrinsic types. The first method can be used when  
variables have been declared in a portable way --- using  
default <tt> KIND</tt> or using <tt> KIND</tt> parameters obtained with  
the <tt> selected_int_kind</tt> or <tt> selected_real_kind</tt>  
functions. With this method, <font face="sans-serif"> MPI</font> automatically   
selects the correct data size (e.g., 4 or 8 bytes) and  
provides representation conversion in heterogeneous   
environments.  The second method gives the user complete  
control over communication by exposing machine representations.  
  
<P> 
   
<menu> 
</menu> 

<P>
<HR>
<A HREF="node350.htm#Node352"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node341.htm#Node341"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node353.htm#Node354"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node341.htm#Node341"> Fortran Support</a>
<b>Next: </b><A HREF="node353.htm#Node354"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<b>Previous: </b><A HREF="node350.htm#Node352"> No Type Mismatch Problems for Subroutines with Choice Arguments</a>
<P>
<HR><H3><A NAME="Node354">316.1. Parameterized Datatypes with Specified Precision and Exponent Range</a></H3>
<A HREF="node353.htm#Node353"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node353.htm#Node353"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node353.htm#Node355"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node353.htm#Node353"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><A HREF="node353.htm#Node355"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<b>Previous: </b><A HREF="node353.htm#Node353"> Additional Support for Fortran Numeric Intrinsic Types</a>
<P>
  
<font face="sans-serif"> MPI</font>   
provides named datatypes corresponding to standard Fortran 77  
numeric types --- <font face="sans-serif">  MPI_INTEGER</font>, <font face="sans-serif">  MPI_COMPLEX</font>,  
<font face="sans-serif">  MPI_REAL</font>, <font face="sans-serif">  MPI_DOUBLE_PRECISION</font> and <font face="sans-serif">  MPI_DOUBLE_COMPLEX</font>.  
<font face="sans-serif"> MPI</font> automatically selects the correct data size and provides  
representation conversion in heterogeneous environments. The  
mechanism described in this section extends this model  
to support portable parameterized numeric types.   
  
<P> 
The model for supporting portable parameterized types is as follows.   
Real variables are declared (perhaps indirectly) using  
<tt> selected_real_kind(p, r)</tt> to determine the <tt> KIND</tt> parameter, where  
<tt> p</tt> is decimal digits of precision and <tt> r</tt> is an exponent range.  
  
Implicitly <font face="sans-serif"> MPI</font> maintains  
  
a two-dimensional array of predefined <font face="sans-serif"> MPI</font> datatypes <tt> D(p, r)</tt>.  
<tt> D(p, r)</tt> is defined for each value of <tt> (p, r)</tt> supported  
by the compiler, including pairs for which one value is unspecified.   
Attempting to access an element of the array with an index <tt> (p, r)</tt> not   
supported by the compiler is erroneous.  
  
<font face="sans-serif"> MPI</font> implicitly maintains a similar array of <tt> COMPLEX</tt> datatypes.   
  
For integers, there is a similar implicit array related to   
<tt> selected_int_kind</tt> and indexed by  
  
the requested number of digits <tt> r</tt>. Note that the predefined datatypes  
  
contained in these implicit arrays are not the same as the named  
<font face="sans-serif"> MPI</font> datatypes <font face="sans-serif">  MPI_REAL</font>, etc., but a new set.   
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
The above description is for explanatory purposes only. It is not  
expected that implementations will have such internal arrays.  
 (<em> End of advice to implementors.</em>) <BR> 
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
<tt> selected_real_kind()</tt> maps a large number of <tt> (p,r)</tt> pairs  
to a much smaller number of <tt> KIND</tt> parameters supported by the compiler.  
<tt> KIND</tt> parameters are not specified by the language and are not  
portable.  From the language point of view intrinsic types of the  
same base type and <tt> KIND</tt> parameter are of the same type.  
In order to allow interoperability in a heterogeneous environment,  
<font face="sans-serif"> MPI</font> is more stringent. The corresponding <font face="sans-serif"> MPI</font> datatypes match if  
and only if they have the same <tt> (p,r)</tt> value (<tt> REAL</tt> and <tt> COMPLEX</tt>) or  
<tt> r</tt> value (<tt> INTEGER</tt>). Thus <font face="sans-serif"> MPI</font> has many more datatypes than  
there are fundamental language types.   
 (<em> End of advice to users.</em>) <BR> 
  
 <P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_F90_REAL(p, r, newtype)</TD></TR>  
  
<TR><TD> IN p</TD><TD>precision, in decimal digits (integer)</TD></TR>  
<TR><TD> IN r</TD><TD>decimal exponent range (integer)</TD></TR>  
  
<TR><TD> OUT newtype</TD><TD>the requested <font face="sans-serif"> MPI</font> datatype (handle)</TD></TR>  
</TABLE>  
 <tt> int MPI_Type_create_f90_real(int p, int r, MPI_Datatype *newtype) <BR></tt>   
 <tt> MPI_TYPE_CREATE_F90_REAL(P, R, NEWTYPE, IERROR)<BR> INTEGER P, R, NEWTYPE, IERROR <BR></tt>  
 <font color="red">{<font color="black"> static MPI::Datatype MPI::Datatype::Create_f90_real(int p, int r) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
This function returns a predefined <font face="sans-serif"> MPI</font> datatype that matches a <tt> REAL</tt> variable  
of <tt> KIND</tt> <tt> selected_real_kind(p, r)</tt>. In the model described above  
it returns a handle for the element <tt> D(p, r)</tt>.  
  
Either <tt> p</tt> or <tt> r</tt> may be omitted from calls to <tt>  
selected_real_kind(p, r)</tt> (but not both).  Analogously, either <tt>  
p</tt> or <tt> r</tt> may be set to <font face="sans-serif">  MPI_UNDEFINED</font>.  
  
In communication, an <font face="sans-serif"> MPI</font> datatype <tt> A</tt> returned by   
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font> matches a datatype <tt> B</tt>  
if and only if <tt> B</tt> was returned by <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>  
called with the same values for <tt> p</tt> and <tt> r</tt> or <tt> B</tt>  
is a duplicate of such a datatype.   
  
Restrictions on using the returned datatype with the ``external32'' data  
representation are given on page <a href="node353.htm#Node354">Parameterized Datatypes with Specified Precision and Exponent Range 
</a>.  
  
<P> 
It is erroneous to supply values for <font face="sans-serif"> p</font> and <font face="sans-serif"> r</font> not  
supported by the compiler.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_F90_COMPLEX(p, r, newtype)</TD></TR>  
  
<TR><TD> IN p</TD><TD>precision, in decimal digits (integer)</TD></TR>  
<TR><TD> IN r</TD><TD>decimal exponent range (integer)</TD></TR>  
  
<TR><TD> OUT newtype</TD><TD>the requested <font face="sans-serif"> MPI</font> datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_f90_complex(int p, int r, MPI_Datatype *newtype) <BR></tt>  
 <tt> MPI_TYPE_CREATE_F90_COMPLEX(P, R, NEWTYPE, IERROR)<BR> INTEGER P, R, NEWTYPE, IERROR <BR></tt>  
 <font color="red">{<font color="black"> static MPI::Datatype MPI::Datatype::Create_f90_complex(int p, int r) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
This function returns a predefined <font face="sans-serif"> MPI</font> datatype that matches a <tt> COMPLEX</tt> variable  
of <tt> KIND</tt> <tt> selected_real_kind(p, r)</tt>.  
  
Either <tt> p</tt> or <tt> r</tt> may be omitted from calls to <tt>  
selected_real_kind(p, r)</tt> (but not both).  Analogously, either <tt>  
p</tt> or <tt> r</tt> may be set to <font face="sans-serif">  MPI_UNDEFINED</font>.  
  
Matching rules for datatypes created by this function are  
analogous to the matching rules for datatypes created by  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>.  
  
Restrictions on using the returned datatype with the ``external32'' data  
representation are given on page <a href="node353.htm#Node354">Parameterized Datatypes with Specified Precision and Exponent Range 
</a>.  
  
<P> 
It is erroneous to supply values for <font face="sans-serif"> p</font> and <font face="sans-serif"> r</font> not  
supported by the compiler.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_F90_INTEGER(r, newtype)</TD></TR>  
  
<TR><TD> IN r</TD><TD>decimal exponent range, i.e., number of decimal digits (integer)</TD></TR>  
  
<TR><TD> OUT newtype</TD><TD>the requested <font face="sans-serif"> MPI</font> datatype (handle)</TD></TR>  
</TABLE>  
 <tt> int MPI_Type_create_f90_integer(int r, MPI_Datatype *newtype) <BR></tt>   
 <tt> MPI_TYPE_CREATE_F90_INTEGER(R, NEWTYPE, IERROR)<BR> INTEGER R, NEWTYPE, IERROR <BR></tt>  
 <font color="red">{<font color="black"> static MPI::Datatype MPI::Datatype::Create_f90_integer(int r) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
This function returns a predefined <font face="sans-serif"> MPI</font> datatype that matches a <tt> INTEGER</tt> variable  
of <tt> KIND</tt> <tt> selected_int_kind(r)</tt>.   
Matching rules for datatypes created by this function are  
analogous to the matching rules for datatypes created by  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>.  
  
Restrictions on using the returned datatype with the ``external32'' data  
representation are given on page <a href="node353.htm#Node354">Parameterized Datatypes with Specified Precision and Exponent Range 
</a>.  
  
 <P> 
It is erroneous to supply a value for <font face="sans-serif"> r</font> that is not  
supported by the compiler.   
<P> 
Example:  
  
<BR> 
<pre><tt>   integer       longtype, quadtype 
   integer, parameter :: long = selected_int_kind(15) 
   integer(long) ii(10) 
   real(selected_real_kind(30)) x(10) 
   call MPI_TYPE_CREATE_F90_INTEGER(15, longtype, ierror) 
   call MPI_TYPE_CREATE_F90_REAL(30, MPI_UNDEFINED, quadtype, ierror) 
   ... 
 
   call MPI_SEND(ii, 10, longtype, ...) 
   call MPI_SEND(x,  10, quadtype, ...) 
</tt></pre> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
  
The datatypes returned by the above functions are  
predefined datatypes. They cannot be freed; they do not need to be   
committed; they can be used with predefined reduction operations.   
There are two situations in which they behave differently syntactically,   
but not semantically, from the <font face="sans-serif"> MPI</font> named predefined datatypes.  
<ol> 
 
1. <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> returns special  
combiners that allow a program to retrieve the values of   
<font face="sans-serif"> p</font> and <font face="sans-serif"> r</font>.  
 
<BR> 
2. Because the datatypes are not named, they cannot  
be used as compile-time initializers or otherwise  
accessed before a call to one of the <font face="sans-serif"> MPI_TYPE_CREATE_F90_</font>  
routines.  
</ol> 
  
If a variable was declared specifying a non-default <tt> KIND</tt> value that was  
not obtained with  <tt> selected_real_kind()</tt> or  
<tt> selected_int_kind()</tt>, the only way to obtain a matching  
<font face="sans-serif"> MPI</font> datatype is to use the size-based mechanism described  
in the next section.   
<P> 
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
An application may often repeat a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_xxxx</font> with the same combination of   
(<font face="sans-serif"> xxxx</font>,<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>).  
The application is not allowed to free the returned predefined, unnamed  
datatype handles. To prevent the creation of a potentially huge amount of handles,   
a high quality   
<font face="sans-serif"> MPI</font> implementation should return the same datatype handle for  
the same   
(<font face="sans-serif"> REAL</font>/<font face="sans-serif"> COMPLEX</font>/ <font face="sans-serif"> INTEGER</font>,<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>)   
combination.    
Checking for the  
combination (<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>) in the preceding call to   
<font face="sans-serif"> MPI_TYPE_CREATE_F90_xxxx</font> and  
using a hash-table to find formerly generated handles should limit the  
overhead of finding a previously generated datatype with same combination  
of (<font face="sans-serif"> xxxx</font>,<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>).  
 (<em> End of advice to implementors.</em>) <BR> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL/COMPLEX/INTEGER</font> interface  
needs as input the original range and precision values to be able to   
define useful and compiler-independent   
external (Section <a href="node290.htm#Node290">External Data Representation: ``external32'' 
</a> on page <a href="node290.htm#Node290">External Data Representation: ``external32'' 
</a>)  
or user-defined (Section <a href="node291.htm#Node291">User-Defined Data Representations 
</a> on   
page <a href="node291.htm#Node291">User-Defined Data Representations 
</a>) data representations, and in order  
to be able to perform automatic and efficient data conversions in a heterogeneous  
environment.   
 (<em> End of rationale.</em>) <BR> 
  
We now specify how the datatypes described in this section  
behave when used with the ``external32'' external data representation  
described in Section <a href="node290.htm#Node290">External Data Representation: ``external32'' 
</a> on page <a href="node290.htm#Node290">External Data Representation: ``external32'' 
</a>.  
<P> 
The external32 representation specifies data formats for integer  
and floating point values. Integer values are represented in two's complement  
big-endian format. Floating point values are represented by one  
of three IEEE formats. These are the IEEE ``Single,'' ``Double'' and   
``Double Extended'' formats, requiring 4, 8 and 16 bytes of storage,   
respectively.   
  
For the IEEE ``Double Extended'' formats, <font face="sans-serif"> MPI</font> specifies a  
Format Width of 16 bytes, with 15 exponent bits, bias = +10383,  
112 fraction bits, and an encoding analogous to the ``Double'' format.   
  
<P> 
The external32 representations of the datatypes returned by   
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL/COMPLEX/INTEGER</font>  
are given by the following rules.   
  
<BR>  
   
For <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>:  
<BR> 
<pre><tt>   if      (p &gt; 33) or (r &gt; 4931) then  external32 representation 
                                        is undefined   
   else if (p &gt; 15) or (r &gt;  307) then  external32_size = 16 
   else if (p &gt;  6) or (r &gt;   37) then  external32_size =  8 
   else                                 external32_size =  4 
</tt></pre> 
For <font face="sans-serif"> MPI_TYPE_CREATE_F90_COMPLEX</font>: twice the size  
as for <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>.  
<BR>  
For <font face="sans-serif"> MPI_TYPE_CREATE_F90_INTEGER</font>:  
<BR> 
<pre><tt>   if      (r &gt; 38) then  external32 representation is undefined 
   else if (r &gt; 18) then  external32_size =  16  
   else if (r &gt;  9) then  external32_size =  8  
   else if (r &gt;  4) then  external32_size =  4 
   else if (r &gt;  2) then  external32_size =  2  
   else                   external32_size =  1  
</tt></pre> 
  
If the external32 representation of  
a datatype is undefined, the result of using the datatype directly  
or indirectly (i.e., as part of another datatype or through a  
duplicated datatype) in operations that require the external32  
representation is undefined. These operations include <font face="sans-serif"> MPI_PACK_EXTERNAL</font>,  
<font face="sans-serif"> MPI_UNPACK_EXTERNAL</font> and many <font face="sans-serif"> MPI_FILE</font>  
functions, when the ``external32'' data representation is used.   
The ranges for which the external32 representation is undefined are  
reserved for future standardization.   
  
 <P> 

<P>
<HR>
<A HREF="node353.htm#Node353"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node353.htm#Node353"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node353.htm#Node355"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node353.htm#Node353"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><A HREF="node353.htm#Node355"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<b>Previous: </b><A HREF="node353.htm#Node353"> Additional Support for Fortran Numeric Intrinsic Types</a>
<P>
<HR><H3><A NAME="Node355">316.2. Support for Size-specific  MPI Datatypes</a></H3>
<A HREF="node353.htm#Node354"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node353.htm#Node353"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node353.htm#Node356"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node353.htm#Node353"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><A HREF="node353.htm#Node356"> Communication With Size-specific Types</a>
<b>Previous: </b><A HREF="node353.htm#Node354"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<P>
  
<P> 
  
<font face="sans-serif"> MPI</font>   
provides named datatypes corresponding to optional Fortran 77  
numeric types that contain explicit byte lengths --- <font face="sans-serif">  MPI_REAL4</font>,   
<font face="sans-serif">  MPI_INTEGER8</font>, etc. This section describes a mechanism  
that generalizes this model to support all Fortran numeric   
intrinsic types.   
  
<P> 
We assume that for each <b> typeclass</b> (integer, real, complex) and each  
word size there is a unique machine representation.    
For every pair (<b> typeclass</b>, <b> n</b>) supported by a compiler,   
<font face="sans-serif"> MPI</font> must provide a named size-specific datatype.    
The name of this datatype is of the form  
<font face="sans-serif">  MPI_<I>&lt;</I>TYPE<I>&gt;</I>n</font> in C and Fortran and of the form  
<font face="sans-serif">  MPI::<I>&lt;</I>TYPE<I>&gt;</I>n</font> in C++ where <font face="sans-serif">  <I>&lt;</I>TYPE<I>&gt;</I></font> is one of  
<font face="sans-serif">  REAL</font>, <font face="sans-serif">  INTEGER</font> and <font face="sans-serif">  COMPLEX</font>, and <b> n</b> is the length in bytes of the  
machine representation.  This datatype locally matches all variables  
of type (<b> typeclass</b>, <b> n</b>).  The list of names for such types  
includes:  
<BR> 
<pre><tt>MPI_REAL4    
MPI_REAL8 
MPI_REAL16    
MPI_COMPLEX8 
MPI_COMPLEX16 
MPI_COMPLEX32 
MPI_INTEGER1 
MPI_INTEGER2    
MPI_INTEGER4 
MPI_INTEGER8    
MPI_INTEGER16    
</tt></pre> 
One   
datatype is required for each representation supported by  
the compiler.  To be backward compatible with the interpretation of  
these types in <font face="sans-serif"> MPI-1</font>, we assume that the nonstandard declarations  
<tt> REAL*n</tt>, <tt> INTEGER*n</tt>, always create a variable whose  
representation is of size <b> n</b>. All these datatypes are predefined.  
<P> 
The following functions allow a  
user to obtain a size-specific <font face="sans-serif"> MPI</font> datatype for any intrinsic Fortran type.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SIZEOF(x, size)</TD></TR>   
  
<TR><TD> IN x</TD><TD>a Fortran variable of numeric intrinsic type (choice)</TD></TR>   
  
<TR><TD> OUT size</TD><TD>size of machine representation of that type (integer)</TD></TR>   
</TABLE>  
<P> 
 <tt> MPI_SIZEOF(X, SIZE, IERROR) <BR> &lt;type&gt; X<BR>INTEGER SIZE, IERROR  <BR></tt>  
<P> 
This function returns the size in bytes of the machine representation of  
the given variable. It is a generic Fortran routine and has a Fortran  
binding only.   
<P> 
 
<BR> 
<em> Advice to users.</em>  
 <P> 
This function is similar to the C and C++ <em> sizeof</em> operator  
but behaves slightly differently. If given an array argument, it   
returns the size of the base element, not the size of the  
whole array.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Rationale.</em>  
<P> 
This function is not available in other languages because it would  
not be useful.   
 (<em> End of rationale.</em>) <BR> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_MATCH_SIZE(typeclass, size, type)</TD></TR>  
<TR><TD> IN typeclass</TD><TD>generic type specifier (integer)</TD></TR>  
<TR><TD> IN size</TD><TD>size, in bytes, of representation (integer)</TD></TR>  
<TR><TD> OUT type</TD><TD>datatype with correct type, size (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_match_size(int typeclass, int size, MPI_Datatype *type) <BR></tt>   
 <tt> MPI_TYPE_MATCH_SIZE(TYPECLASS, SIZE, TYPE, IERROR) <BR> INTEGER TYPECLASS, SIZE, TYPE, IERROR <BR></tt>  
 <font color="red">{<font color="black"> static MPI::Datatype MPI::Datatype::Match_size(int typeclass, int size) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>   
<P> 
<font face="sans-serif"> typeclass</font> is one of <font face="sans-serif">  MPI_TYPECLASS_REAL</font>,  
<font face="sans-serif">  MPI_TYPECLASS_INTEGER</font> and   
<font face="sans-serif">  MPI_TYPECLASS_COMPLEX</font>,  
corresponding to the  desired <b> typeclass</b>.  The function returns  
an <font face="sans-serif"> MPI</font> datatype matching a local variable of type (<b> typeclass</b>,  
<b> size</b>).   
<P> 
This function  
returns a reference (handle) to one of the predefined named  
datatypes, not a duplicate. This type cannot be freed.   
  
<font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font> can be used to obtain a size-specific type that  
matches a Fortran numeric intrinsic type by first calling  
<font face="sans-serif"> MPI_SIZEOF</font> in order to compute the variable size, and then  
calling <font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font> to find a suitable  
datatype.    
  
In C and C++, one can use the C function <font face="sans-serif"> sizeof()</font>, instead of  
<font face="sans-serif"> MPI_SIZEOF</font>.  In addition, for variables of default kind  
the variable's size can be computed by a call to  
<font face="sans-serif"> MPI_TYPE_GET_EXTENT</font>, if the <tt> typeclass</tt> is known.  
It is erroneous to specify a size not supported by the compiler.   
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
This is a convenience function. Without it, it can be tedious to   
find the correct named type. See note to implementors below.   
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
This function could be implemented as a series of tests.  
  
<BR> 
<pre><tt>int MPI_Type_match_size(int typeclass, int size, MPI_Datatype *rtype) 
{ 
  switch(typeclass) { 
      case MPI_TYPECLASS_REAL: switch(size) { 
        case 4: *rtype = MPI_REAL4; return MPI_SUCCESS; 
        case 8: *rtype = MPI_REAL8; return MPI_SUCCESS; 
        default: error(...); 
      } 
      case MPI_TYPECLASS_INTEGER: switch(size) { 
         case 4: *rtype = MPI_INTEGER4; return MPI_SUCCESS;          
         case 8: *rtype = MPI_INTEGER8; return MPI_SUCCESS; 
         default: error(...);       } 
     ... etc. ...  
   } 
}  
</tt></pre> 
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node353.htm#Node354"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node353.htm#Node353"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node353.htm#Node356"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node353.htm#Node353"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><A HREF="node353.htm#Node356"> Communication With Size-specific Types</a>
<b>Previous: </b><A HREF="node353.htm#Node354"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<P>
<HR><H3><A NAME="Node356">316.3. Communication With Size-specific Types</a></H3>
<A HREF="node353.htm#Node355"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node353.htm#Node353"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node353.htm#Node353"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><A HREF="node357.htm#Node357"> Language Interoperability</a>
<b>Previous: </b><A HREF="node353.htm#Node355"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<P>
The usual type matching rules apply to size-specific datatypes: a  
value sent with datatype   
<font face="sans-serif">  MPI_<I>&lt;</I>TYPE<I>&gt;</I>n</font> can be received with this same datatype on  
another process.  
Most modern computers use 2's complement for integers and  
IEEE format for floating point.  Thus, communication using these  
size-specific datatypes will not entail loss of precision or  
truncation errors.  
<P> 
  
  
 <P> 
 
<BR> 
<em> Advice to users.</em>  
 <P> 
Care is required when communicating in a heterogeneous  
environment. Consider the following code:  
  
<BR> 
<pre><tt>real(selected_real_kind(5)) x(100)    
call MPI_SIZEOF(x, size, ierror)    
call MPI_TYPE_MATCH_SIZE(MPI_TYPECLASS_REAL, size, xtype, ierror)    
if (myrank .eq. 0) then 
    ... initialize x ...       
    call MPI_SEND(x, xtype, 100, 1, ...)    
else if (myrank .eq. 1) then       
    call MPI_RECV(x, xtype, 100, 0, ...) 
endif  
</tt></pre> 
This may not work in a heterogeneous environment  
if the value of <font face="sans-serif"> size</font> is not the same on process 1 and  
process 0. There should be no problem in a homogeneous environment.  
To communicate in a heterogeneous environment, there are at least four  
options. The first is to declare variables of default type and use  
the <font face="sans-serif"> MPI</font> datatypes for these types, e.g., declare a variable of type  
<tt> REAL</tt> and use <font face="sans-serif">  MPI_REAL</font>.  The second is to use   
<tt> selected_real_kind</tt> or <tt> selected_int_kind</tt> and  
with the functions of the previous section.   
The third is to declare a variable   
that is known to be the same size on all architectures (e.g.,   
<tt> selected_real_kind(12)</tt> on almost all compilers will result in an 8-byte  
representation). The fourth is to carefully check  
representation size before communication. This may require explicit  
conversion to a variable of size that can be communicated and  
handshaking between sender and receiver to agree on a size.    
<P> 
Note finally that using the ``external32'' representation for I/O  
requires explicit attention to the representation sizes. Consider the  
following code:   
<P> 
  
  
<BR> 
<pre><tt>real(selected_real_kind(5)) x(100)   
call MPI_SIZEOF(x, size, ierror)    
call MPI_TYPE_MATCH_SIZE(MPI_TYPECLASS_REAL, size, xtype, ierror) 
 
if (myrank .eq. 0) then 
   call MPI_FILE_OPEN(MPI_COMM_SELF, 'foo',                &amp; 
                      MPI_MODE_CREATE+MPI_MODE_WRONLY,     &amp; 
                      MPI_INFO_NULL, fh, ierror) 
   call MPI_FILE_SET_VIEW(fh, 0, xtype, xtype, 'external32',  &amp; 
                          MPI_INFO_NULL, ierror) 
   call MPI_FILE_WRITE(fh, x, 100, xtype, status, ierror) 
   call MPI_FILE_CLOSE(fh, ierror) 
endif 
 
call MPI_BARRIER(MPI_COMM_WORLD, ierror) 
 
if (myrank .eq. 1) then 
   call MPI_FILE_OPEN(MPI_COMM_SELF, 'foo', MPI_MODE_RDONLY,  &amp; 
                 MPI_INFO_NULL, fh, ierror) 
   call MPI_FILE_SET_VIEW(fh, 0, xtype, xtype, 'external32',  &amp; 
                          MPI_INFO_NULL, ierror) 
   call MPI_FILE_WRITE(fh, x, 100, xtype, status, ierror) 
   call MPI_FILE_CLOSE(fh, ierror) 
endif 
 
</tt></pre> 
  
If processes 0 and 1 are on different machines, this code may not work  
as expected if the <font face="sans-serif"> size</font> is different on the two machines.  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
  
<P> 

<P>
<HR>
<A HREF="node353.htm#Node355"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node353.htm#Node353"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node353.htm#Node353"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><A HREF="node357.htm#Node357"> Language Interoperability</a>
<b>Previous: </b><A HREF="node353.htm#Node355"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
