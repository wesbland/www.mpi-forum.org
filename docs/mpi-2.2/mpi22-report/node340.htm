<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Profiling</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node340">310. Profiling</a></H2>
<A HREF="node339.htm#Node339"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node330.htm#Node330"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node341.htm#Node341"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node330.htm#Node330"> C++</a>
<b>Next: </b><A HREF="node341.htm#Node341"> Fortran Support</a>
<b>Previous: </b><A HREF="node339.htm#Node339"> Mixed-Language Operability</a>
<P>
  
<P> 
  
<P> 
This section specifies the requirements of a C++ profiling interface  
to <font face="sans-serif"> MPI</font>.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Since the main goal of profiling is to intercept function calls from  
  user code, it is the implementor's decision how to layer the  
  underlying implementation to allow function calls to be intercepted  
  and profiled.  If an implementation of the <font face="sans-serif"> MPI</font> C++ bindings is  
  layered on top of <font face="sans-serif"> MPI</font> bindings in another language (such as C), or  
  if the C++ bindings are layered on top of a profiling interface in  
  another language, no extra profiling interface is necessary because  
  the underlying <font face="sans-serif"> MPI</font> implementation already meets the <font face="sans-serif"> MPI</font>  
  profiling interface requirements.  
<P> 
Native C++ <font face="sans-serif"> MPI</font> implementations that do not have access to other  
  profiling interfaces must implement an interface that meets the  
  requirements outlined in this section.    
<P> 
High-quality implementations can implement the interface outlined in  
  this section in order to promote portable C++ profiling libraries.  
  Implementors may wish to provide an option whether to build the C++  
  profiling interface or not; C++ implementations that are already  
  layered on top of bindings in another language or another profiling  
  interface will have to insert a third layer to implement the C++  
  profiling interface.  
 (<em> End of advice to implementors.</em>) <BR> 
To meet the requirements of the C++ <font face="sans-serif"> MPI</font> profiling interface, an  
implementation of the <font face="sans-serif"> MPI</font> functions <em> must</em>:  
<P> 
<ol> 
 
1. Provide a mechanism through which all of the <font face="sans-serif"> MPI</font> defined  
  functions may be accessed with a name shift. Thus all of the <font face="sans-serif"> MPI</font>  
  functions (which normally start with the prefix ``<tt> MPI::</tt>'')  
  should also be accessible with the prefix ``<tt> PMPI::</tt>.''  
<P> 
 
<BR> 
2. Ensure that those <font face="sans-serif"> MPI</font> functions which are not replaced may  
  still be linked into an executable image without causing name  
  clashes.  
<P> 
 
<BR> 
3. Document the implementation of different language bindings of  
  the <font face="sans-serif"> MPI</font> interface if they are layered on top of each other, so  
  that profiler developer knows whether they must implement the  
  profile interface for each binding, or can economize by implementing  
  it only for the lowest level routines.  
<P> 
 
<BR> 
4. Where the implementation of different language bindings   
  is  
  done through a layered approach (e.g., the C++ binding is a set of  
  ``wrapper'' functions which call the C implementation), ensure that  
  these wrapper functions are separable from the rest of the library.  
<P> 
This is necessary to allow a separate profiling library to be  
  correctly implemented, since (at least with Unix linker semantics)  
  the profiling library must contain these wrapper functions if it is  
  to perform as expected.  This requirement allows the author of the  
  profiling library to extract these functions from the original <font face="sans-serif"> MPI</font>  
  library and add them into the profiling library without bringing  
  along any other unnecessary code.  
  <P> 
 
<BR> 
5. Provide a no-op routine <font face="sans-serif"> MPI::Pcontrol</font> in the <font face="sans-serif"> MPI</font>  
  library.  
</ol> 
  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
There are (at least) two apparent options for implementing the C++  
profiling interface: inheritance or caching.  An inheritance-based  
approach may not be attractive because it may require a virtual  
inheritance implementation of the communicator classes.  Thus, it is  
most likely that implementors   
will   
cache <tt> PMPI</tt> objects on their  
corresponding <tt> MPI</tt> objects.  The caching scheme is outlined  
below.  
<P> 
  
<P> 
The ``real'' entry points to each routine can be provided within a  
<tt> namespace PMPI</tt>.  The non-profiling version can then be  
provided within a <tt> namespace MPI</tt>.  
<P> 
  <P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
  
<P> 
Caching instances of <tt> PMPI</tt> objects in the <tt> MPI</tt> handles  
provides the ``has a'' relationship that is necessary to implement  
the profiling scheme.  
<P> 
Each instance of an <tt> MPI</tt> object simply ``wraps up'' an  
instance of a <tt> PMPI</tt> object.  <tt> MPI</tt> objects can then  
perform profiling actions before invoking the corresponding function  
in their internal <tt> PMPI</tt> object.  
<P> 
  
<P> 
The key to making the profiling work by simply re-linking programs is  
by having a header file that <em> declares</em> all the <font face="sans-serif"> MPI</font> functions.  
The functions must be <em> defined</em> elsewhere, and compiled into a  
library.  <font face="sans-serif"> MPI</font> constants should be declared <tt> extern</tt> in  
the <tt> MPI</tt> namespace.  For example, the following is an excerpt  
from a sample <tt> mpi.h</tt> file:  
<P> 
  
<P> 
  
<BR><b> Example</b>   
Sample <tt> mpi.h</tt> file.  
<BR> 
<pre><tt>namespace PMPI { 
  class Comm { 
  public: 
    int Get_size() const; 
  }; 
  // etc. 
}; 
 
namespace MPI { 
public: 
  class Comm { 
  public: 
    int Get_size() const; 
 
  private: 
    PMPI::Comm pmpi_comm; 
  }; 
}; 
</tt></pre> 
  
  
<P> 
Note that all constructors, the assignment operator, and the  
destructor in the <tt> MPI</tt> class will need to initialize/destroy  
the internal <tt> PMPI</tt> object as appropriate.  
<P> 
  
<P> 
The definitions of the functions must be in separate object files; the  
<tt> PMPI</tt> class member functions and the non-profiling versions of  
the <tt> MPI</tt> class member functions can be compiled into <tt>  
  libmpi.a</tt>, while the profiling versions can be compiled into <tt>  
  libpmpi.a</tt>.  Note that the <tt> PMPI</tt> class member functions and  
the <tt> MPI</tt> constants must be in different object files than the  
non-profiling <tt> MPI</tt> class member functions in the <tt> libmpi.a</tt>  
library to prevent multiple definitions of <tt> MPI</tt> class member  
function names when linking both <tt> libmpi.a</tt> and <tt> libpmpi.a</tt>.  
For example:  
<P> 
  
<BR><b> Example</b>   
<tt> pmpi.cc</tt>, to be compiled into <tt> libmpi.a</tt>.  
<BR> 
<pre><tt>int PMPI::Comm::Get_size() const 
{ 
  // Implementation of MPI_COMM_SIZE 
} 
</tt></pre> 
  
  
<P> 
  
<BR><b> Example</b>   
<tt> constants.cc</tt>, to be compiled into <tt>  
    libmpi.a</tt>.  
<BR> 
<pre><tt>const MPI::Intracomm MPI::COMM_WORLD; 
</tt></pre> 
  
  
<P> 
  
<P> 
  
<BR><b> Example</b>  
 <tt> mpi_no_profile.cc</tt>, to be compiled into <tt>  
  libmpi.a</tt>.   
<BR> 
<pre><tt>int MPI::Comm::Get_size() const 
{ 
  return pmpi_comm.Get_size(); 
} 
</tt></pre> 
  
  
<P> 
  
<BR><b> Example</b>  
 <tt> mpi_profile.cc</tt>, to be compiled into <tt> libpmpi.a</tt>.  
<BR> 
<pre><tt>int MPI::Comm::Get_size() const 
{ 
  // Do profiling stuff 
  int ret = pmpi_comm.Get_size(); 
  // More profiling stuff 
  return ret; 
} 
</tt></pre> 
  
  
<P> 
  
<P> 
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node339.htm#Node339"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node330.htm#Node330"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node341.htm#Node341"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node330.htm#Node330"> C++</a>
<b>Next: </b><A HREF="node341.htm#Node341"> Fortran Support</a>
<b>Previous: </b><A HREF="node339.htm#Node339"> Mixed-Language Operability</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
