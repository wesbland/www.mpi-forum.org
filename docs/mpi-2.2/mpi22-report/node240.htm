<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-one-side/one-side-2.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>General Active Target Synchronization</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node240">225. General Active Target Synchronization</a></H2>
<A HREF="node239.htm#Node239"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node238.htm#Node238"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node241.htm#Node241"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node238.htm#Node238"> Synchronization Calls</a>
<b>Next: </b><A HREF="node241.htm#Node241"> Lock</a>
<b>Previous: </b><A HREF="node239.htm#Node239"> Fence</a>
<P>
<TABLE><TR><TD COLSPAN=2>MPI_WIN_START(group, assert, win)</TD></TR>  
<TR><TD> IN group</TD><TD>group of target processes (handle)</TD></TR>  
<TR><TD> IN assert</TD><TD>program assertion (integer)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_start(MPI_Group group, int assert, MPI_Win win) <BR></tt>  
<P> 
 <tt> MPI_WIN_START(GROUP, ASSERT, WIN, IERROR)<BR> INTEGER GROUP, ASSERT, WIN, IERROR <BR></tt>  
<P> 
 <font color="red">{<font color="black"> void MPI::Win::Start(const MPI::Group&amp; group, int assert) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
Starts an <font face="sans-serif"> RMA</font> access epoch for <font face="sans-serif"> win</font>.  <font face="sans-serif"> RMA</font> calls issued on  
<font face="sans-serif"> win</font> during this epoch must access only windows at  
processes in <font face="sans-serif"> group</font>.  
Each process in <font face="sans-serif"> group</font> must issue a matching call to   
<font face="sans-serif"> MPI_WIN_POST</font>.  
<font face="sans-serif"> RMA</font> accesses to each target  
window will be delayed, if necessary,  
until the target process executed the matching call to   
<font face="sans-serif"> MPI_WIN_POST</font>.  
  
<font face="sans-serif"> MPI_WIN_START</font> is allowed to block until the corresponding  
<font face="sans-serif"> MPI_WIN_POST</font> calls are executed, but is not required to.  
  
<P> 
The <font face="sans-serif"> assert</font> argument is used to provide assertions on the  
context of the call that may be used for various optimizations.  This  
is described in  
Section <a href="node242.htm#Node242">Assertions 
</a>.  A value of <font face="sans-serif"> assert = 0</font> is  
always valid.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_COMPLETE(win)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_complete(MPI_Win win) <BR></tt>  
<P> 
 <tt> MPI_WIN_COMPLETE(WIN, IERROR)<BR> INTEGER WIN,  IERROR <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> void MPI::Win::Complete() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
Completes an <font face="sans-serif"> RMA</font> access epoch on <font face="sans-serif"> win</font> started by a  
call to <font face="sans-serif"> MPI_WIN_START</font>.  All <font face="sans-serif"> RMA</font> communication  
calls issued on <font face="sans-serif"> win</font> during this epoch will have completed at  
the origin when the call returns.  
<P> 
<font face="sans-serif"> MPI_WIN_COMPLETE</font> enforces completion of preceding <font face="sans-serif"> RMA</font>  
calls at the origin, but not at the target.  
A put or accumulate call may not have completed  
at the target when it has completed at the origin.  
<P> 
Consider the sequence of calls in the example below.  
<BR><b> Example</b>  
  
  
<BR> 
<pre><tt>MPI_Win_start(group, flag, win); 
MPI_Put(...,win); 
MPI_Win_complete(win); 
</tt></pre> 
  
<P> 
The call to <font face="sans-serif"> MPI_WIN_COMPLETE</font> does not return until the  
put call has completed at the origin; and  
the target window will be accessed by the put operation only after the  
call to <font face="sans-serif"> MPI_WIN_START</font> has matched a call to  
<font face="sans-serif"> MPI_WIN_POST</font> by the target process.  This still leaves  
much choice to implementors. The call to  
<font face="sans-serif"> MPI_WIN_START</font> can block until the matching call to  
<font face="sans-serif"> MPI_WIN_POST</font> occurs at all target processes.  One can also  
have implementations where the call to <font face="sans-serif"> MPI_WIN_START</font> is  
nonblocking, but the call to <font face="sans-serif"> MPI_PUT</font> blocks until the  
matching call to <font face="sans-serif"> MPI_WIN_POST</font> occurred;  or  
implementations where the first two calls are nonblocking, but the  
call to <font face="sans-serif"> MPI_WIN_COMPLETE</font> blocks until the call to  
<font face="sans-serif"> MPI_WIN_POST</font> occurred; or even implementations where all  
three calls can complete before any target process called   
<font face="sans-serif"> MPI_WIN_POST</font> ---   
the data put must be buffered, in this last case, so as to allow the  
put to complete at the origin ahead of its completion at the   
target.  
However, once the  
call to <font face="sans-serif"> MPI_WIN_POST</font> is issued, the sequence above  
must complete, without further dependencies.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_POST(group, assert, win)</TD></TR>  
<TR><TD> IN group</TD><TD>group of origin processes (handle)</TD></TR>  
<TR><TD> IN assert</TD><TD>program assertion (integer)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_post(MPI_Group group, int assert, MPI_Win win) <BR></tt>  
<P> 
 <tt> MPI_WIN_POST(GROUP, ASSERT, WIN, IERROR)<BR> INTEGER GROUP, ASSERT, WIN, IERROR <BR></tt>  
<P> 
 <font color="red">{<font color="black"> void MPI::Win::Post(const MPI::Group&amp; group, int assert) const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
<P> 
Starts an <font face="sans-serif"> RMA</font> exposure epoch for the  
local window associated with <font face="sans-serif"> win</font>.  Only processes in  
<font face="sans-serif"> group</font> should access the window with <font face="sans-serif"> RMA</font> calls on  
<font face="sans-serif"> win</font> during  this   
epoch.  
Each process in <font face="sans-serif"> group</font> must issue a matching call to   
<font face="sans-serif"> MPI_WIN_START</font>.  
  
<font face="sans-serif"> MPI_WIN_POST</font> does not block.  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_WAIT(win)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_wait(MPI_Win win) <BR></tt>  
<P> 
 <tt> MPI_WIN_WAIT(WIN, IERROR)<BR> INTEGER WIN,  IERROR <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> void MPI::Win::Wait() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
Completes an <font face="sans-serif"> RMA</font> exposure epoch started by a call to  
<font face="sans-serif"> MPI_WIN_POST</font> on   
<font face="sans-serif"> win</font>.  
This call matches calls to <font face="sans-serif"> MPI_WIN_COMPLETE(win)</font>  
issued  
by each of the origin processes that were granted access to the window  
during this epoch.  
The call to <font face="sans-serif"> MPI_WIN_WAIT</font> will  
block until all matching calls to <font face="sans-serif"> MPI_WIN_COMPLETE</font>  
have occurred.  
This guarantees that all these origin processes have completed their  
<font face="sans-serif"> RMA</font> accesses to the local  
window.  
When the call returns, all these <font face="sans-serif"> RMA</font> accesses will  
have completed at the target window.  
<P> 
Figure <a href="node240.htm#Figure20">20 
</a> illustrates the use of these four  
functions.  
<CENTER><P><IMG WIDTH=539 HEIGHT=281 SRC="2party.gif"><P>
</CENTER>  
<BR> 
<b>Figure 20: </b><A NAME="Figure20">Active target communication.  Dashed arrows represent
synchronizations and solid arrows represent data transfer.</a><P> 
  
  
Process 0 puts data in the windows of processes 1 and 2 and process 3  
puts data in the window of process 2.  Each start call lists the ranks  
of the processes whose windows will be accessed;  
each post call lists the ranks of the  
processes that access the local window.  The figure illustrates a  
possible timing for the events, assuming strong synchronization; in a   
weak synchronization, the start, put or complete calls  
may occur ahead of the matching post calls.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_TEST(win, flag)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
<TR><TD> OUT flag</TD><TD>success flag (logical)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_test(MPI_Win win, int *flag) <BR></tt>  
<P> 
 <tt> MPI_WIN_TEST(WIN, FLAG, IERROR)<BR> INTEGER WIN, IERROR<BR>LOGICAL FLAG <BR></tt>  
<P> 
  
 <font color="red">{<font color="black"> bool MPI::Win::Test() const <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
This is the nonblocking version of <font face="sans-serif"> MPI_WIN_WAIT</font>.    
<font color="red">It returns <font face="sans-serif"> flag = true</font> if all accesses to the local window by the group to  
which it was exposed by the corresponding <font face="sans-serif"> MPI_WIN_POST</font> call have  
been completed as signalled by matching <font face="sans-serif"> MPI_WIN_COMPLETE</font> calls,  
and <font face="sans-serif"> flag = false</font> otherwise. In the former case <font face="sans-serif"> MPI_WIN_WAIT</font>  
would have returned immediately.  
<font color="black">The effect of return of <font face="sans-serif"> MPI_WIN_TEST</font> with  
<font face="sans-serif"> flag = true</font> is the same as the effect of a return   
of <font face="sans-serif"> MPI_WIN_WAIT</font>.  If <font face="sans-serif"> flag = false</font> is returned,  
then the call has no visible effect.  
<P> 
<font face="sans-serif"> MPI_WIN_TEST</font> should be invoked only where  
<font face="sans-serif"> MPI_WIN_WAIT</font>  
can be invoked.  
Once the call has returned <font face="sans-serif"> flag = true</font>, it must not be  
invoked anew, until the window is posted anew.  
<P> 
  
Assume that window <font face="sans-serif"> win</font> is associated with a ``hidden''  
communicator <font face="sans-serif"> wincomm</font>, used for communication by the processes  
of <font face="sans-serif"> win</font>.  The rules for matching of post and start calls and  
for matching complete and wait call can be derived from the rules for  
matching sends and receives, by considering the following (partial) model  
implementation.   
<P> 
<dl> 
 
<dt> 
<b>{</b><font face="sans-serif"> MPI_WIN_POST(group,0,win)}</font></b><dd> 
initiate a nonblocking send with tag <font face="sans-serif"> tag0</font> to each  
process in <font face="sans-serif"> group</font>, using <font face="sans-serif"> wincomm</font>.  No need to wait for the  
completion of these sends.  
 
<dt> 
<b>{</b><font face="sans-serif"> MPI_WIN_START(group,0,win)}</font></b><dd> 
initiate a nonblocking receive with tag <font face="sans-serif"> tag0</font> from each  
process in <font face="sans-serif"> group</font>, using <font face="sans-serif"> wincomm</font>.  An <font face="sans-serif"> RMA</font> access to  
a window in target process <font face="sans-serif"> i</font> is delayed until the receive  
from <font face="sans-serif"> i</font> is completed.  
 
<dt> 
<b>{</b><font face="sans-serif"> MPI_WIN_COMPLETE(win)}</font></b><dd> 
initiate a nonblocking send with tag <font face="sans-serif"> tag1</font> to each process in  
the group of the preceding start call.  No need to wait for the  
completion of these sends.  
 
<dt> 
<b>{</b><font face="sans-serif"> MPI_WIN_WAIT(win)}</font></b><dd> 
initiate a nonblocking receive with tag <font face="sans-serif"> tag1</font> from each  
process in the group of the preceding post call.  Wait for the  
completion of all receives.   
</dl> 
<BR> 
No races can occur in a correct program: each of the sends matches a  
unique receive, and vice-versa.   
  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The design for general active target synchronization requires the  
user to provide complete information on the communication pattern, at  
each end of a communication link: each origin specifies a list of  
targets, and each target specifies a list of origins.  This provides  
maximum flexibility (hence, efficiency) for the implementor:   
each  
synchronization can be initiated by either side, since each ``knows''  
the identity of the other.  This also provides maximum protection from  
possible races.  On the other hand, the design requires more  
information than <font face="sans-serif"> RMA</font> needs, in general: in general, it is sufficient  
for the origin to know the rank of the target, but not vice  
versa.  
Users that want more ``anonymous'' communication will be required to  
use the fence or lock mechanisms.  
 (<em> End of rationale.</em>) <BR> 
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
Assume a communication pattern that is represented by a directed graph  
<IMG WIDTH=65 HEIGHT=10 SRC="img138.gif">
, where <I>V = {0, ..., n-1}</I> and <IMG WIDTH=31 HEIGHT=10 SRC="img139.gif">
 if origin process  
<I>i</I> accesses the window at target process <I>j</I>.  Then each process <I>i</I>  
issues a call to   
<font face="sans-serif"> MPI_WIN_POST(<I>ingroup<SUB>i</SUB></I>, ...)</font>,   
followed by a call to  
<font face="sans-serif"> MPI_WIN_START(<I>outgroup<SUB>i</SUB></I>,...)</font>,  
where   
<IMG WIDTH=124 HEIGHT=12 SRC="img140.gif">
 and <IMG WIDTH=119 HEIGHT=12 SRC="img141.gif">
.  A call is a noop, and can be skipped, if the group argument is  
empty. After the communications calls, each process that issued  
a start will issue a complete.  Finally, each process that  
issued  a post will issue a wait.   
<P> 
Note that each process may call with a group argument that has  
different members.  
 (<em> End of advice to users.</em>) <BR> 
  
  <P> 

<P>
<HR>
<A HREF="node239.htm#Node239"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node238.htm#Node238"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node241.htm#Node241"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node238.htm#Node238"> Synchronization Calls</a>
<b>Next: </b><A HREF="node241.htm#Node241"> Lock</a>
<b>Previous: </b><A HREF="node239.htm#Node239"> Fence</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
