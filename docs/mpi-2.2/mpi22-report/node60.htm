<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Communication Completion</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node60">59. Communication Completion</a></H2>
<A HREF="node59.htm#Node59"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node57.htm#Node57"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node61.htm#Node61"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node57.htm#Node57"> Nonblocking Communication</a>
<b>Next: </b><A HREF="node61.htm#Node61"> Semantics of Nonblocking Communications</a>
<b>Previous: </b><A HREF="node59.htm#Node59"> Communication Initiation</a>
<P>
  
<P> 
The functions <font face="sans-serif"> MPI_WAIT</font> and <font face="sans-serif"> MPI_TEST</font> are used to complete a  
nonblocking communication.  The completion of a send operation indicates that  
the sender is now free  
to update the locations in the send buffer  
(the send operation itself leaves the content  
of the send buffer unchanged). It does not indicate that the  
message has been received,  
rather, it may have been buffered by the communication  
subsystem.  However, if a <font face="sans-serif"> synchronous</font>  
mode send was used, the completion of the  
send operation indicates that a matching receive was initiated, and that the  
message will eventually be received by this matching receive.  
<P> 
The completion of a receive operation indicates that the receive buffer  
contains the received message, the receiver is now free to access it,  
and that the status object is set.  It does  
not indicate that the matching send operation has completed (but indicates, of  
course, that the send was initiated).  
<P> 
We shall use the following terminology:  
A <b> null</b> handle is a handle with  
value <BR><font face="sans-serif">  MPI_REQUEST_NULL</font>.  
A persistent  
request and the handle to it are <b> inactive</b>  
if the request is not associated with any ongoing  
communication (see Section <a href="node65.htm#Node65">Persistent Communication Requests 
</a>).  
A handle is <b> active</b> if it is neither null nor inactive.  
  
  
  
An   
<b> empty</b> status is a status which is set to return <font face="sans-serif"> tag =</font>  
<font face="sans-serif">  MPI_ANY_TAG</font>, <font face="sans-serif"> source =</font> <font face="sans-serif">  MPI_ANY_SOURCE</font>, <font face="sans-serif"> error =</font>  
<font face="sans-serif">  MPI_SUCCESS</font>,  and is also internally configured so that calls to  
<font face="sans-serif"> MPI_GET_COUNT</font> and <font face="sans-serif"> MPI_GET_ELEMENTS</font> return  
<font face="sans-serif"> count = 0</font>  
and <font face="sans-serif"> MPI_TEST_CANCELLED</font> returns <font face="sans-serif">  false</font>.  
<P> 
We set a status variable to empty when the value returned by it is not  
significant. Status is set in this  
way so as to prevent errors due to accesses of stale information.  
  
<P> 
  
The fields in a <font face="sans-serif"> status</font> object returned by a call to  
<font face="sans-serif"> MPI_WAIT</font>, <font face="sans-serif"> MPI_TEST</font>, or any of the other derived functions   
(<font face="sans-serif"> MPI_</font>{<font face="sans-serif"> TEST<I>|</I>WAIT</font>}{<font face="sans-serif"> ALL<I>|</I>SOME<I>|</I>ANY</font>}),   
where the <font face="sans-serif"> request</font> corresponds to a send call, are undefined, with two  
exceptions: The error status field will contain valid information if the wait  
or test call returned with <font face="sans-serif">  MPI_ERR_IN_STATUS</font>; and the returned  
status can be queried by the call <font face="sans-serif"> MPI_TEST_CANCELLED</font>.  
<P> 
Error codes belonging to the error class <font face="sans-serif">  MPI_ERR_IN_STATUS</font> should  
be returned only by the <font face="sans-serif"> MPI</font> completion functions that take arrays of  
<font face="sans-serif"> MPI_STATUS</font>.    
For the functions <font face="sans-serif"> MPI_TEST</font>, <font face="sans-serif"> MPI_TESTANY</font>, <font face="sans-serif"> MPI_WAIT</font>, and <font face="sans-serif"> MPI_WAITANY</font>, which  
return a single <font face="sans-serif"> MPI_STATUS</font> value,  
the normal <font face="sans-serif"> MPI</font> error return process should be used (not the <font face="sans-serif">  MPI_ERROR</font>  
field in the <font face="sans-serif"> MPI_STATUS</font> argument).  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WAIT(request, status)</TD></TR>  
<TR><TD> INOUT request</TD><TD>request (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Wait(MPI_Request *request, MPI_Status *status) <BR></tt>  
<P> 
 <tt> MPI_WAIT(REQUEST, STATUS, IERROR)<BR> INTEGER  REQUEST, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Request::Wait(MPI::Status&amp; status) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> void MPI::Request::Wait() <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
A call to <font face="sans-serif"> MPI_WAIT</font> returns when the operation  
identified by <font face="sans-serif"> request</font> is complete.  If the communication object  
associated with this request was created by a nonblocking send or  
receive call, then the object is deallocated by the call to <font face="sans-serif"> MPI_WAIT</font>  
and the request handle is set to <font face="sans-serif">  MPI_REQUEST_NULL</font>.  
<font face="sans-serif"> MPI_WAIT</font> is a non-local operation.  
<P> 
The call returns, in <font face="sans-serif"> status</font>, information on  
the completed operation.  The content of the status object for a receive  
operation can be accessed as  
described in Section <a href="node47.htm#Node47">Return Status 
</a>.  
The status object for a send operation may be queried by  
a call to <font face="sans-serif"> MPI_TEST_CANCELLED</font>  
(see Section <a href="node64.htm#Node64">Probe and Cancel 
</a>).  
<P> 
  
One is allowed to call <font face="sans-serif"> MPI_WAIT</font> with a null or inactive  
<font face="sans-serif"> request</font> argument.  
In this case the operation returns immediately with empty <font face="sans-serif"> status</font>.  
  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Successful return of <font face="sans-serif"> MPI_WAIT</font> after a <font face="sans-serif"> MPI_IBSEND</font> implies  
that the user send buffer can be reused --- i.e., data has been sent  
out or copied into a  
buffer attached with <font face="sans-serif"> MPI_BUFFER_ATTACH</font>.   Note that, at this point,  
we can no longer cancel the send (see Section <a href="node64.htm#Node64">Probe and Cancel 
</a>).  
If a matching receive is never  
posted, then the buffer cannot be freed.  This runs somewhat  
counter to the stated goal of <font face="sans-serif"> MPI_CANCEL</font> (always being able to free  
program space that was committed to the communication subsystem).  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
In a multi-threaded environment, a call to  
<font face="sans-serif"> MPI_WAIT</font> should block only the calling thread, allowing the thread  
scheduler to schedule another thread for execution.  
 (<em> End of advice to implementors.</em>) <BR> 
<TABLE><TR><TD COLSPAN=2>MPI_TEST(request, flag, status)</TD></TR>  
<TR><TD> INOUT request</TD><TD>communication request (handle)</TD></TR>  
<TR><TD> OUT flag</TD><TD><font face="sans-serif"> true</font> if operation completed (logical)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Test(MPI_Request *request, int *flag, MPI_Status *status) <BR></tt>  
<P> 
 <tt> MPI_TEST(REQUEST, FLAG, STATUS, IERROR)<BR> LOGICAL  FLAG <BR>INTEGER  REQUEST, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <font color="red">{<font color="black"> bool MPI::Request::Test(MPI::Status&amp; status) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
 <font color="red">{<font color="black"> bool MPI::Request::Test() <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<P> 
A call to <font face="sans-serif"> MPI_TEST</font> returns <font face="sans-serif"> flag = true</font> if the  
operation identified by <font face="sans-serif"> request</font> is complete.  In such a case, the  
status object is set to contain information on the completed  
operation;  if the communication object was created by a nonblocking  
send or receive, then it is deallocated and the request handle is set to  
<font face="sans-serif">  MPI_REQUEST_NULL</font>. The call returns  
<font face="sans-serif"> flag = false</font>, otherwise. In this case, the value  
of the status object is undefined.  
<font face="sans-serif"> MPI_TEST</font> is a local operation.  
<P> 
The return status object for a receive operation carries information that  
can be accessed as described in  
Section <a href="node47.htm#Node47">Return Status 
</a>.  
The status object for a send operation carries information that can be  
accessed by  
a call to <font face="sans-serif"> MPI_TEST_CANCELLED</font>  
(see Section <a href="node64.htm#Node64">Probe and Cancel 
</a>).  
<P> 
  
One  
is allowed to call <font face="sans-serif"> MPI_TEST</font> with a null or inactive <font face="sans-serif"> request</font>  
argument. In such a case the operation returns with <font face="sans-serif"> flag = true</font> and  
empty <font face="sans-serif"> status</font>.  
  
<P> 
The functions <font face="sans-serif"> MPI_WAIT</font> and <font face="sans-serif"> MPI_TEST</font> can be used to  
complete both sends and receives.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
The use of  
the nonblocking <font face="sans-serif"> MPI_TEST</font> call allows the user to  
schedule alternative activities within a single thread of execution.  
An event-driven thread scheduler can be emulated with periodic calls to  
<font face="sans-serif"> MPI_TEST</font>.  
 (<em> End of advice to users.</em>) <BR> 
  
  
2.2  
  
<P> 
<BR><b> Example</b>   
  
  
  
  
  
Simple usage of nonblocking operations and <font face="sans-serif"> MPI_WAIT</font>.  
<BR> 
<pre><tt>CALL MPI_COMM_RANK(comm, rank, ierr) 
IF (rank.EQ.0) THEN 
    CALL MPI_ISEND(a(1), 10, MPI_REAL, 1, tag, comm, request, ierr) 
    **** do some computation to mask latency **** 
    CALL MPI_WAIT(request, status, ierr) 
ELSE IF (rank.EQ.1) THEN 
    CALL MPI_IRECV(a(1), 15, MPI_REAL, 0, tag, comm, request, ierr) 
    **** do some computation to mask latency **** 
    CALL MPI_WAIT(request, status, ierr) 
END IF 
</tt></pre> 
   
<P> 
A request object can be deallocated without waiting for the associated  
communication to complete, by using the following operation.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_REQUEST_FREE(request)</TD></TR>  
<TR><TD> INOUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Request_free(MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_REQUEST_FREE(REQUEST, IERROR)<BR> INTEGER  REQUEST, IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Request::Free() <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Mark the request object for deallocation and set <font face="sans-serif"> request</font> to  
<font face="sans-serif">  MPI_REQUEST_NULL</font>.  
An ongoing communication that is associated with the request will be allowed  
to complete. The request will be deallocated only after its completion.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The <font face="sans-serif"> MPI_REQUEST_FREE</font> mechanism is provided for  
reasons of performance and convenience on the sending side.  
 (<em> End of rationale.</em>) <BR> 
  
2.2  
<P> 
<font color="red">  
 
<BR> 
<em> Advice to users.</em>  
<P> 
Once a request is freed by a call to <font face="sans-serif"> MPI_REQUEST_FREE</font>, it is not possible   
to check for the successful completion of the associated communication   
with calls to <font face="sans-serif"> MPI_WAIT</font> or <font face="sans-serif"> MPI_TEST</font>. Also, if an error occurs subsequently   
during the communication, an error code cannot be returned to the user ---  
such an error must be treated as fatal. An active receive request should   
never be freed as the receiver will have no way to verify that the receive   
has completed and the receive buffer can be reused.  
 (<em> End of advice to users.</em>) <BR> 
<font color="black">  
<P> 
<P> 
<BR><b> Example</b>   
  
  
  
  
  
  
An example using <font face="sans-serif"> MPI_REQUEST_FREE</font>.  
<P> 
  
  
<BR> 
<pre><tt>CALL MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr) 
IF (rank.EQ.0) THEN 
    DO i=1, n 
      CALL MPI_ISEND(outval, 1, MPI_REAL, 1, 0, MPI_COMM_WORLD, req, ierr) 
      CALL MPI_REQUEST_FREE(req, ierr) 
      CALL MPI_IRECV(inval, 1, MPI_REAL, 1, 0, MPI_COMM_WORLD, req, ierr) 
      CALL MPI_WAIT(req, status, ierr) 
    END DO 
ELSE IF (rank.EQ.1) THEN 
    CALL MPI_IRECV(inval, 1, MPI_REAL, 0, 0, MPI_COMM_WORLD, req, ierr) 
    CALL MPI_WAIT(req, status, ierr) 
    DO I=1, n-1 
       CALL MPI_ISEND(outval, 1, MPI_REAL, 0, 0, MPI_COMM_WORLD, req, ierr) 
       CALL MPI_REQUEST_FREE(req, ierr) 
       CALL MPI_IRECV(inval, 1, MPI_REAL, 0, 0, MPI_COMM_WORLD, req, ierr) 
       CALL MPI_WAIT(req, status, ierr) 
    END DO 
    CALL MPI_ISEND(outval, 1, MPI_REAL, 0, 0, MPI_COMM_WORLD, req, ierr) 
    CALL MPI_WAIT(req, status, ierr) 
END IF 
</tt></pre> 
   
<P> 

<P>
<HR>
<A HREF="node59.htm#Node59"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node57.htm#Node57"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node61.htm#Node61"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node57.htm#Node57"> Nonblocking Communication</a>
<b>Next: </b><A HREF="node61.htm#Node61"> Semantics of Nonblocking Communications</a>
<b>Previous: </b><A HREF="node59.htm#Node59"> Communication Initiation</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
