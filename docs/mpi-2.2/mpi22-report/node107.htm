<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-coll/coll.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>User-Defined Reduction Operations</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node107">106. User-Defined Reduction Operations</a></H2>
<A HREF="node106.htm#Node106"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node102.htm#Node102"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node107.htm#Node108"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node102.htm#Node102"> Global Reduction Operations</a>
<b>Next: </b><A HREF="node107.htm#Node108"> Example of User-defined Reduce</a>
<b>Previous: </b><A HREF="node106.htm#Node106"> MINLOC and MAXLOC</a>
<P>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_OP_CREATE(function, commute, op)</TD></TR>  
<TR><TD> IN function</TD><TD> user defined function (function)</TD></TR>  
<TR><TD> IN commute</TD><TD> <tt> true</tt> if commutative; <tt> false</tt> otherwise.</TD></TR>  
<TR><TD> OUT op</TD><TD> operation (handle) </TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Op_create(MPI_User_function *function, int commute, MPI_Op *op) <BR></tt>  
<P> 
 <tt> MPI_OP_CREATE( FUNCTION, COMMUTE, OP, IERROR) <BR> EXTERNAL FUNCTION <BR>LOGICAL COMMUTE <BR>INTEGER OP, IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Op::Init(MPI::User_function* function, bool commute) <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
<font face="sans-serif"> MPI_OP_CREATE</font> binds a user-defined <font color="red">reduction<font color="black"> operationto an <font face="sans-serif"> op</font> handle that can subsequently be used in  
<font face="sans-serif"> MPI_REDUCE</font>, <font face="sans-serif"> MPI_ALLREDUCE</font>,  
<font face="sans-serif"> MPI_REDUCE_SCATTER</font>,   
<font face="sans-serif"> MPI_SCAN</font>, and <font face="sans-serif"> MPI_EXSCAN</font>.  
The user-defined operation is assumed to be associative.  
If <font face="sans-serif"> commute</font> <I>=</I> <tt> true</tt>, then the operation should be both  
commutative and associative. If  <font face="sans-serif"> commute</font> <I>=</I> <tt> false</tt>,  
  
then the order of operands is fixed and is defined to be in ascending, process  
rank order, beginning with process zero.  The order of evaluation can be  
changed, talking advantage of the associativity of the operation.  If  
<font face="sans-serif"> commute</font> <I>=</I> <tt> true</tt> then the order of evaluation can be changed,  
taking advantage of commutativity and associativity.  
  
<P> 
<font color="red">The argument <font color="black"><font face="sans-serif"> function</font> is the user-defined function, which must have thefollowing four arguments: <font face="sans-serif"> invec, inoutvec, len</font> and <font face="sans-serif"> datatype</font>.  
<P> 
The   
ISO C   
prototype for the function is the following.  
<P> 
 <tt> typedef void MPI_User_function(void *invec, void *inoutvec, int *len, MPI_Datatype *datatype); <BR></tt>  
  
The Fortran declaration of the user-defined function appears below.  
  
<P> 
 <tt> SUBROUTINE USER_FUNCTION(INVEC, INOUTVEC, LEN, TYPE) <BR> &lt;type&gt; INVEC(LEN), INOUTVEC(LEN) <BR>INTEGER LEN, TYPE <BR></tt>  
  
The C++ declaration of the user-defined function appears below.  
<P> 
 <font color="red">{<font color="black"><tt> typedef void MPI::User_function(const void* invec, void *inoutvec, int len, const Datatype&amp; datatype); <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR></tt>  
  
The <font face="sans-serif"> datatype</font> argument  
is a handle to the data type that was passed into the call  
to <font face="sans-serif"> MPI_REDUCE</font>.  
The user reduce function should be written such that the following  
holds:  
Let <font face="sans-serif"> u[0], ... , u[len-1]</font> be the <font face="sans-serif"> len</font> elements in the  
communication buffer described by the arguments <font face="sans-serif"> invec, len</font>  
and <font face="sans-serif"> datatype</font> when the function is invoked;  
let <font face="sans-serif"> v[0], ... , v[len-1]</font> be <font face="sans-serif"> len</font> elements in the  
communication buffer described by the arguments <font face="sans-serif"> inoutvec, len</font>  
and <font face="sans-serif"> datatype</font> when the function is invoked;  
let <font face="sans-serif"> w[0], ... , w[len-1]</font> be  <font face="sans-serif"> len</font> elements in the  
communication buffer described by the arguments <font face="sans-serif"> inoutvec, len</font>  
and <font face="sans-serif"> datatype</font> when the function returns;  
then <font face="sans-serif"> w[i] = u[i]<I>&#176;</I>v[i]</font>, for <font face="sans-serif"> i=0 , ... , len-1</font>,  
where <I>&#176;</I> is the reduce operation that the function computes.  
<P> 
Informally, we can think of  
<font face="sans-serif"> invec</font> and <font face="sans-serif"> inoutvec</font> as arrays of <font face="sans-serif"> len</font> elements that  
<font face="sans-serif"> function</font>  
is combining.  The result of the reduction over-writes values in  
<font face="sans-serif"> inoutvec</font>, hence the name.  Each invocation of the function results in  
the pointwise evaluation of the reduce operator on <font face="sans-serif"> len</font>  
elements:  
<font color="red">i.e.<font color="black">, the function returns in <font face="sans-serif"> inoutvec[i]</font> the value<I> invec[i] &#176; inoutvec[i]</I>, for <I> i=0, ... , count-1</I>,  
where <I> &#176;</I> is the combining operation computed by the function.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The   
<font face="sans-serif"> len</font>   
argument allows  
<font face="sans-serif"> MPI_REDUCE</font> to avoid calling the function for each element  
in the input buffer.  Rather, the system can choose to apply  
the function to chunks of input.  In C, it is passed in as  
a reference for reasons of compatibility with Fortran.  
<P> 
By internally comparing the value of the <font face="sans-serif"> datatype</font> argument to  
known, global handles,  
it is possible to overload the use of a single user-defined function  
for several, different data types.  
 (<em> End of rationale.</em>) <BR> 
General datatypes may be passed to the user function.  
However, use of datatypes that are not contiguous is likely to lead to  
inefficiencies.  
<P> 
No <font face="sans-serif"> MPI</font> communication function may be called inside the user function.  
<font face="sans-serif"> MPI_ABORT</font> may be called inside the  
function in case of an error.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Suppose one defines a library of user-defined reduce  
functions that are overloaded: the <font face="sans-serif"> datatype</font> argument is used  
to select the right execution path at each invocation, according to  
the types of the operands.  
The user-defined reduce function cannot ``decode'' the  
<font face="sans-serif"> datatype</font> argument that it is passed, and cannot identify,  
by itself, the correspondence between the datatype handles and the datatype  
they represent.  This correspondence was established when the datatypes  
were created.  Before the library is used, a library initialization  
preamble must be executed.  This preamble code will define the  
datatypes that are used by the library, and store handles to these  
datatypes in global, static variables that are shared by the user code and the  
library code.  
<P> 
The Fortran version of <font face="sans-serif"> MPI_REDUCE</font> will invoke a user-defined reduce  
function using the Fortran calling conventions and will pass a Fortran-type  
datatype argument;  the C version will use C calling convention and the C  
representation of a datatype handle.  Users who plan to mix languages should  
define their reduction functions accordingly.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
We outline below a naive and inefficient implementation of <font face="sans-serif"> MPI_REDUCE</font>  
not   
supporting the ``in place'' option.  
  
<BR> 
<pre><tt>      MPI_Comm_size(comm, &amp;groupsize); 
      MPI_Comm_rank(comm, &amp;rank); 
      if (rank &gt; 0) { 
          MPI_Recv(tempbuf, count, datatype, rank-1,...); 
          User_reduce(tempbuf, sendbuf, count, datatype); 
      } 
      if (rank &lt; groupsize-1) { 
          MPI_Send(sendbuf, count, datatype, rank+1, ...); 
      } 
      /* answer now resides in process groupsize-1 ... now send to root 
       */ 
      if (rank == root) { 
          MPI_Irecv(recvbuf, count, datatype, groupsize-1,..., &amp;req); 
      } 
      if (rank == groupsize-1) { 
          MPI_Send(sendbuf, count, datatype, root, ...); 
      } 
      if (rank == root) { 
          MPI_Wait(&amp;req, &amp;status); 
      } 
</tt></pre> 
The reduction computation proceeds, sequentially, from process <tt> 0</tt>  
to process   
<tt> groupsize-1</tt>.    
This order is chosen so as to respect  
the order of a possibly non-commutative operator defined by the  
function <tt> User_reduce()</tt>.  
A more efficient implementation is achieved by taking advantage  
of associativity and  
using a logarithmic tree reduction.  Commutativity can be used  
to advantage, for those cases in which the <font face="sans-serif"> commute</font> argument  
to <font face="sans-serif"> MPI_OP_CREATE</font> is true.  Also, the amount of temporary buffer  
required can be reduced, and communication can be pipelined with  
computation, by transferring and reducing the elements in chunks of  
size <tt> len</tt> <I>&lt;</I><tt> count</tt>.  
<P> 
The predefined reduce operations can be implemented as a library of  
user-defined operations.  However, better performance might be  
achieved if <font face="sans-serif"> MPI_REDUCE</font> handles these functions as a special  
case.  
 (<em> End of advice to implementors.</em>) <BR> 
  
<TABLE><TR><TD COLSPAN=2>MPI_OP_FREE( op)</TD></TR>  
<TR><TD> INOUT op</TD><TD> operation (handle) </TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_op_free( MPI_Op *op) <BR></tt>  
<P> 
 <tt> MPI_OP_FREE( OP, IERROR) <BR> INTEGER OP, IERROR <BR></tt>  
 <font color="red">{<font color="black"> void MPI::Op::Free() <font color="red"><em> (binding deprecated, see Section <a href="node328.htm#Node328">Deprecated since <font face="sans-serif"> MPI-2.2</font> 
</a>)</em> }<font color="black"><BR>  
  
Marks a user-defined reduction operation for deallocation and sets  
<font face="sans-serif"> op</font> to <font face="sans-serif">  MPI_OP_NULL</font>.  
<P> 
<menu> 
</menu> 

<P>
<HR>
<A HREF="node106.htm#Node106"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node102.htm#Node102"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node107.htm#Node108"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node102.htm#Node102"> Global Reduction Operations</a>
<b>Next: </b><A HREF="node107.htm#Node108"> Example of User-defined Reduce</a>
<b>Previous: </b><A HREF="node106.htm#Node106"> MINLOC and MAXLOC</a>
<P>
<HR><H3><A NAME="Node108">106.1. Example of User-defined Reduce</a></H3>
<A HREF="node107.htm#Node107"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node107.htm#Node107"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node109.htm#Node109"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node107.htm#Node107"> User-Defined Reduction Operations</a>
<b>Next: </b><A HREF="node109.htm#Node109"> All-Reduce</a>
<b>Previous: </b><A HREF="node107.htm#Node107"> User-Defined Reduction Operations</a>
<P>
  
<P> 
It is time for an example of user-defined reduction.  
The example in this section uses an intracommunicator.  
  
<BR><b> Example</b>   
  
Compute the product of an array of complex numbers, in C.  
<P><IMG WIDTH=410 HEIGHT=605 SRC="img80.gif"><P>
   

<P>
<HR>
<A HREF="node107.htm#Node107"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node107.htm#Node107"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node109.htm#Node109"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node107.htm#Node107"> User-Defined Reduction Operations</a>
<b>Next: </b><A HREF="node109.htm#Node109"> All-Reduce</a>
<b>Previous: </b><A HREF="node107.htm#Node107"> User-Defined Reduction Operations</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
