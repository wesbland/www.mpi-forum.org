<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Type Matching Rules</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node50">50. Type Matching Rules</a></H2>
<A HREF="node49.htm#Node49"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node49.htm#Node49"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node50.htm#Node51"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node49.htm#Node49"> Data Type Matching and Data Conversion</a>
<b>Next: </b><A HREF="node50.htm#Node51"> Type <font face="sans-serif">  MPI_CHARACTER</font></a>
<b>Previous: </b><A HREF="node49.htm#Node49"> Data Type Matching and Data Conversion</a>
<P>
  
<P> 
One can think of message transfer as consisting of the following three phases.  
<ol> 
 
1. Data is pulled out of the send buffer and a message is assembled.  
 
<BR> 
2. A message is transferred from sender to receiver.  
 
<BR> 
3. Data is pulled from the incoming message and disassembled into the receive  
buffer.  
</ol> 
Type matching has to be observed at each of these three phases:  The type  
of each variable in the sender buffer has to match  
the type specified for that entry by the send operation;  
the type specified by the send operation has to match the type specified by  
the receive operation; and  
the type of each  
variable in the receive buffer has to match the type specified for  
that entry by the receive operation.  
A program that fails to observe these  
three rules is erroneous.  
<P> 
To define type matching more precisely, we need to deal with two issues:  
matching of types of the host language with types specified in  
communication operations;  
and matching of types at sender and receiver.  
<P> 
The types of a send and receive match (phase two) if  
both operations use identical names. That is, <font face="sans-serif"> MPI_INTEGER</font>  
matches <font face="sans-serif"> MPI_INTEGER</font>, <font face="sans-serif"> MPI_REAL</font> matches <font face="sans-serif"> MPI_REAL</font>,  
and so on.  
There is one exception to this rule, discussed in  
Section <a href="node84.htm#Node84">Pack and Unpack 
</a>, the type <font face="sans-serif"> MPI_PACKED</font> can match  
any other type.  
<P> 
The type of a variable in a host program matches the type specified in the  
communication operation  
if the datatype name used by that operation corresponds  
to the basic type of the host program variable.  For example, an entry with type  
name <font face="sans-serif"> MPI_INTEGER</font> matches a Fortran variable of type <tt> INTEGER</tt>.  
A table giving this correspondence for Fortran and C appears in  
Section <a href="node44.htm#Node44">Message Data 
</a>.  
There are two exceptions to this last rule: an entry with type name  
<font face="sans-serif"> MPI_BYTE</font> or <font face="sans-serif"> MPI_PACKED</font> can be used to match  
any byte of storage (on a byte-addressable machine),  
irrespective of the datatype of the variable that contains this byte.  
The type <font face="sans-serif"> MPI_PACKED</font> is used to send data that has been  
explicitly packed, or receive data that will be explicitly unpacked,  
see Section <a href="node84.htm#Node84">Pack and Unpack 
</a>.  
The type <font face="sans-serif"> MPI_BYTE</font> allows one to transfer the binary value of a byte in  
memory unchanged.  
<P> 
To summarize, the type matching rules fall into the three categories below.  
<ul> 
 
<li>Communication of typed values (e.g., with datatype different from   
<font face="sans-serif"> MPI_BYTE</font>),   
where the datatypes of the corresponding entries in the sender  
program, in the send call,  
in the receive call and in the receiver program  
must all match.  
 
<li>Communication of untyped values (e.g., of datatype <font face="sans-serif"> MPI_BYTE</font>), where  
both sender and receiver use the  
datatype <font face="sans-serif"> MPI_BYTE</font>.  In this case, there are no  
requirements on the types of the corresponding entries in the sender and the  
receiver programs, nor is it required that they be the same.  
 
<li>Communication involving packed data, where <font face="sans-serif"> MPI_PACKED</font> is used.  
</ul> 
<BR> 
The following examples illustrate the first two cases.  
  
<P> 
<BR><b> Example</b>   
  
  
  
  
Sender and receiver specify matching types.  
<BR> 
<pre><tt>CALL MPI_COMM_RANK(comm, rank, ierr) 
IF (rank.EQ.0) THEN 
    CALL MPI_SEND(a(1), 10, MPI_REAL, 1, tag, comm, ierr) 
ELSE IF (rank.EQ.1) THEN 
    CALL MPI_RECV(b(1), 15, MPI_REAL, 0, tag, comm, status, ierr) 
END IF 
</tt></pre> 
This code is correct if both <font face="sans-serif"> a</font> and <font face="sans-serif"> b</font> are real arrays of  
size <IMG WIDTH=21 HEIGHT=9 SRC="img4.gif">
. (In Fortran, it might be correct to use this code  
even if <font face="sans-serif"> a</font> or <font face="sans-serif"> b</font> have size <I>&lt; 10</I>: e.g., when <font face="sans-serif"> a(1)</font> can  
be equivalenced to an array with ten reals.)  
   
<P> 
<BR><b> Example</b>   
  
  
  
  
Sender and receiver do not specify matching types.  
<P> 
<BR> 
<pre><tt>CALL MPI_COMM_RANK(comm, rank, ierr) 
IF (rank.EQ.0) THEN 
    CALL MPI_SEND(a(1), 10, MPI_REAL, 1, tag, comm, ierr) 
ELSE IF (rank.EQ.1) THEN 
    CALL MPI_RECV(b(1), 40, MPI_BYTE, 0, tag, comm, status, ierr) 
END IF 
</tt></pre> 
This code is erroneous, since sender and receiver do not provide  
matching datatype arguments.  
   
<P> 
<BR><b> Example</b>   
  
  
  
  
  
Sender and receiver specify communication of untyped values.  
<BR> 
<pre><tt>CALL MPI_COMM_RANK(comm, rank, ierr) 
IF (rank.EQ.0) THEN 
    CALL MPI_SEND(a(1), 40, MPI_BYTE, 1, tag, comm, ierr) 
ELSE IF (rank.EQ.1) THEN 
    CALL MPI_RECV(b(1), 60, MPI_BYTE, 0, tag, comm, status, ierr) 
END IF 
</tt></pre> 
This code is correct, irrespective of the type and size of <font face="sans-serif"> a</font> and  
<font face="sans-serif"> b</font> (unless this results in an out of bound memory access).  
   
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
If a buffer of type <font face="sans-serif">  MPI_BYTE</font> is passed as an argument to  
<font face="sans-serif"> MPI_SEND</font>, then <font face="sans-serif"> MPI</font> will send the data stored at contiguous  
locations, starting from the address  
indicated by the <font face="sans-serif"> buf</font> argument.  This may have unexpected results when  
the data layout is not as a casual user would expect it to be.  
For example, some Fortran compilers implement variables of type  
<font face="sans-serif">  CHARACTER</font>  
as a structure that contains the character length and a pointer to  
the actual string.  In such an environment, sending and receiving a Fortran  
<font face="sans-serif">  CHARACTER</font> variable using the <font face="sans-serif">  MPI_BYTE</font> type will not  
have the anticipated result of transferring the character string.  
For this reason, the user is advised to use typed communications  
whenever possible.  
 (<em> End of advice to users.</em>) <BR> 
<menu> 
</menu> 

<P>
<HR>
<A HREF="node49.htm#Node49"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node49.htm#Node49"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node50.htm#Node51"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node49.htm#Node49"> Data Type Matching and Data Conversion</a>
<b>Next: </b><A HREF="node50.htm#Node51"> Type <font face="sans-serif">  MPI_CHARACTER</font></a>
<b>Previous: </b><A HREF="node49.htm#Node49"> Data Type Matching and Data Conversion</a>
<P>
<HR><H3><A NAME="Node51">50.1. Type   MPI_CHARACTER</a></H3>
<A HREF="node50.htm#Node50"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node50.htm#Node50"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node52.htm#Node52"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node50.htm#Node50"> Type Matching Rules</a>
<b>Next: </b><A HREF="node52.htm#Node52"> Data Conversion</a>
<b>Previous: </b><A HREF="node50.htm#Node50"> Type Matching Rules</a>
<P>
The  
type <font face="sans-serif"> MPI_CHARACTER</font> matches one character of a Fortran variable of  
type <tt> CHARACTER</tt>, rather then the entire character string stored in the  
variable.  Fortran variables of type <font face="sans-serif">  CHARACTER</font>  
or substrings are transferred as if they were arrays of characters.  
This is illustrated in the example below.  
<P> 
<BR><b> Example</b>   
  
  
  
  
<P> 
Transfer of Fortran <font face="sans-serif">  CHARACTER</font>s.  
<P> 
<BR> 
<pre><tt>CHARACTER*10 a 
CHARACTER*10 b 
 
CALL MPI_COMM_RANK(comm, rank, ierr) 
IF (rank.EQ.0) THEN 
    CALL MPI_SEND(a, 5, MPI_CHARACTER, 1, tag, comm, ierr) 
ELSE IF (rank.EQ.1) THEN 
    CALL MPI_RECV(b(6:10), 5, MPI_CHARACTER, 0, tag, comm, status, ierr) 
END IF 
</tt></pre> 
The last five characters of string <font face="sans-serif">  b</font> at process 1 are replaced by the  
first five characters of string <font face="sans-serif">  a</font> at process 0.  
   
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The alternative choice would be for <font face="sans-serif"> MPI_CHARACTER</font> to  
match a character of arbitrary length.  This runs into problems.  
<P> 
A Fortran character variable is a constant length string, with no special  
termination symbol.  There is no fixed convention on how to represent  
characters, and how to store their length.  
Some compilers pass a character argument to  
a routine as a pair of arguments, one holding the address of the string and the  
other holding the length of string.   Consider the case of an <font face="sans-serif"> MPI</font>  
communication call that is passed a communication buffer  
with type defined by a derived datatype (Section <a href="node69.htm#Node69">Derived Datatypes 
</a>).  
If this communicator buffer contains variables of type <tt> CHARACTER</tt> then  
the information on their length will not be passed to the <font face="sans-serif"> MPI</font> routine.  
<P> 
This problem forces us to provide explicit information on character  
length with the <font face="sans-serif"> MPI</font> call.  One could add a length parameter to the  
type <font face="sans-serif"> MPI_CHARACTER</font>, but this does not add much convenience and the same  
functionality can be achieved by defining a suitable derived datatype.  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Some compilers pass Fortran <font face="sans-serif">  CHARACTER</font> arguments as a structure with a  
length and a pointer to the actual string.  In such an environment, the <font face="sans-serif"> MPI</font>  
call needs to dereference the pointer in order to reach the string.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node50.htm#Node50"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node50.htm#Node50"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node52.htm#Node52"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node50.htm#Node50"> Type Matching Rules</a>
<b>Next: </b><A HREF="node52.htm#Node52"> Data Conversion</a>
<b>Previous: </b><A HREF="node50.htm#Node50"> Type Matching Rules</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
