<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml erif"> MPI-2.0</font>
-->
<TITLE>Examples</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node83">82. Examples</a></H2>
<A HREF="node82.htm#Node82"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node69.htm#Node69"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node84.htm#Node84"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node69.htm#Node69"> Derived Datatypes</a>
<b>Next: </b><A HREF="node84.htm#Node84"> Pack and Unpack</a>
<b>Previous: </b><A HREF="node82.htm#Node82"> Decoding a Datatype</a>
<P>
  
<P> 
The following examples illustrate the use of derived datatypes.  
<P> 
<BR><b> Example</b>   
  
Send and receive a section of a 3D array.  
  
<P> 
<BR> 
<pre><tt>      REAL a(100,100,100), e(9,9,9) 
      INTEGER oneslice, twoslice, threeslice, sizeofreal, myrank, ierr 
      INTEGER status(MPI_STATUS_SIZE) 
 
C      extract the section a(1:17:2, 3:11, 2:10) 
C      and store it in e(:,:,:). 
 
      CALL MPI_COMM_RANK(MPI_COMM_WORLD, myrank, ierr) 
 
      CALL MPI_TYPE_EXTENT( MPI_REAL, sizeofreal, ierr) 
 
C     create datatype for a 1D section 
      CALL MPI_TYPE_VECTOR( 9, 1, 2, MPI_REAL, oneslice, ierr) 
 
C     create datatype for a 2D section 
      CALL MPI_TYPE_HVECTOR(9, 1, 100*sizeofreal, oneslice, twoslice, ierr) 
 
C     create datatype for the entire section 
      CALL MPI_TYPE_HVECTOR( 9, 1, 100*100*sizeofreal, twoslice, 
                             threeslice, ierr) 
 
      CALL MPI_TYPE_COMMIT( threeslice, ierr) 
      CALL MPI_SENDRECV(a(1,3,2), 1, threeslice, myrank, 0, e, 9*9*9, 
                        MPI_REAL, myrank, 0, MPI_COMM_WORLD, status, ierr) 
</tt></pre> 
   
<P> 
<BR><b> Example</b>   
  
Copy the (strictly) lower triangular part of a matrix.  
<P><IMG WIDTH=511 HEIGHT=294 SRC="img49.gif"><P>
   
<P> 
<BR><b> Example</b>   
  
Transpose a matrix.  
<P> 
<BR> 
<pre><tt>      REAL a(100,100), b(100,100) 
      INTEGER row, xpose, sizeofreal, myrank, ierr 
      INTEGER status(MPI_STATUS_SIZE) 
 
C     transpose matrix a onto b 
 
      CALL MPI_COMM_RANK(MPI_COMM_WORLD, myrank, ierr) 
 
      CALL MPI_TYPE_EXTENT( MPI_REAL, sizeofreal, ierr) 
 
C     create datatype for one row 
      CALL MPI_TYPE_VECTOR( 100, 1, 100, MPI_REAL, row, ierr) 
 
C     create datatype for matrix in row-major order 
      CALL MPI_TYPE_HVECTOR( 100, 1, sizeofreal, row, xpose, ierr) 
 
      CALL MPI_TYPE_COMMIT( xpose, ierr) 
 
C     send matrix in row-major order and receive in column major order 
      CALL MPI_SENDRECV( a, 1, xpose, myrank, 0, b, 100*100, 
                MPI_REAL, myrank, 0, MPI_COMM_WORLD, status, ierr) 
</tt></pre> 
   
<P> 
<BR><b> Example</b>   
  
Another approach to the transpose problem:  
<BR> 
<pre><tt>      REAL a(100,100), b(100,100) 
      INTEGER  disp(2), blocklen(2), type(2), row, row1, sizeofreal 
      INTEGER  myrank, ierr 
      INTEGER status(MPI_STATUS_SIZE) 
 
      CALL MPI_COMM_RANK(MPI_COMM_WORLD, myrank, ierr) 
 
C     transpose matrix a onto b 
 
      CALL MPI_TYPE_EXTENT( MPI_REAL, sizeofreal, ierr) 
 
C     create datatype for one row 
      CALL MPI_TYPE_VECTOR( 100, 1, 100, MPI_REAL, row, ierr) 
 
C     create datatype for one row, with the extent of one real number 
      disp(1) = 0 
      disp(2) = sizeofreal 
      type(1)  = row 
      type(2)  = MPI_UB 
      blocklen(1)  = 1 
      blocklen(2)  = 1 
      CALL MPI_TYPE_STRUCT( 2, blocklen, disp, type, row1, ierr) 
 
      CALL MPI_TYPE_COMMIT( row1, ierr) 
 
C     send 100 rows and receive in column major order 
      CALL MPI_SENDRECV( a, 100, row1, myrank, 0, b, 100*100, 
                MPI_REAL, myrank, 0, MPI_COMM_WORLD, status, ierr) 
</tt></pre> 
   
<P> 
<BR><b> Example</b>   
  
We manipulate an array of structures.  
<P> 
  
<P><IMG WIDTH=365 HEIGHT=646 SRC="img50.gif"><P>
   
<P> 
<BR><b> Example</b>   
  
The same manipulations as in the previous example, but use absolute  
addresses in datatypes.  
<P> 
<P><IMG WIDTH=491 HEIGHT=660 SRC="img51.gif"><P>
  
<P> 
<BR><b> Example</b>   
  
Handling of unions.  
<P> 
<P><IMG WIDTH=319 HEIGHT=484 SRC="img52.gif"><P>
   
<P> 
  
<BR><b> Example</b>  
This   
example shows how a datatype can be decoded.  The routine   
<tt> printdatatype</tt> prints out the elements of the datatype.  Note the use   
of <font face="sans-serif"> MPI_Type_free</font> for datatypes that are not predefined.  
<BR> 
<pre><tt>/* 
  Example of decoding a datatype.  
 
  Returns 0 if the datatype is predefined, 1 otherwise 
 */ 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include "mpi.h" 
int printdatatype( MPI_Datatype datatype )  
{ 
    int *array_of_ints; 
    MPI_Aint *array_of_adds; 
    MPI_Datatype *array_of_dtypes; 
    int num_ints, num_adds, num_dtypes, combiner; 
    int i; 
 
    MPI_Type_get_envelope( datatype,  
                           &amp;num_ints, &amp;num_adds, &amp;num_dtypes, &amp;combiner ); 
    switch (combiner) { 
    case MPI_COMBINER_NAMED: 
        printf( "Datatype is named:" ); 
        /* To print the specific type, we can match against the 
           predefined forms. We can NOT use a switch statement here  
           We could also use MPI_TYPE_GET_NAME if we prefered to use 
           names that the user may have changed. 
         */ 
        if      (datatype == MPI_INT)    printf( "MPI_INT\n" ); 
        else if (datatype == MPI_DOUBLE) printf( "MPI_DOUBLE\n" ); 
        ... else test for other types ... 
        return 0; 
        break; 
    case MPI_COMBINER_STRUCT: 
    case MPI_COMBINER_STRUCT_INTEGER: 
        printf( "Datatype is struct containing" ); 
        array_of_ints   = (int *)malloc( num_ints * sizeof(int) ); 
        array_of_adds   =  
                   (MPI_Aint *) malloc( num_adds * sizeof(MPI_Aint) ); 
        array_of_dtypes = (MPI_Datatype *) 
            malloc( num_dtypes * sizeof(MPI_Datatype) ); 
        MPI_Type_get_contents( datatype, num_ints, num_adds, num_dtypes, 
                         array_of_ints, array_of_adds, array_of_dtypes ); 
        printf( " %d datatypes:\n", array_of_ints[0] ); 
        for (i=0; i&lt;array_of_ints[0]; i++) { 
            printf( "blocklength %d, displacement %ld, type:\n",  
                    array_of_ints[i+1], array_of_adds[i] ); 
            if (printdatatype( array_of_dtypes[i] )) { 
                /* Note that we free the type ONLY if it  
                   is not predefined */ 
                MPI_Type_free( &amp;array_of_dtypes[i] ); 
            } 
        } 
        free( array_of_ints ); 
        free( array_of_adds ); 
        free( array_of_dtypes ); 
        break; 
        ... other combiner values ... 
    default: 
        printf( "Unrecognized combiner type\n" ); 
    } 
    return 1; 
} 
</tt></pre> 
  
  
<P> 
  
<P> 

<P>
<HR>
<A HREF="node82.htm#Node82"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node69.htm#Node69"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node84.htm#Node84"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node69.htm#Node69"> Derived Datatypes</a>
<b>Next: </b><A HREF="node84.htm#Node84"> Pack and Unpack</a>
<b>Previous: </b><A HREF="node82.htm#Node82"> Decoding a Datatype</a>
<P>
<HR>
Return to <A HREF="node434.htm">MPI-2.2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-2.2 of September 4, 2009<BR>
HTML Generated on September 10, 2009
</FONT>
</BODY>
</HTML>
