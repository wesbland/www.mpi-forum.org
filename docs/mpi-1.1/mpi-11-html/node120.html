<HTML>
<!-- This file was generated by tohtml from context.tex -->
<TITLE>Attributes Example</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node120">5.7.2. Attributes Example</a></H2>
<A HREF="node119.html#Node119"><IMG SRC="previous.gif"></A><A HREF="node118.html#Node118"><IMG SRC="up.gif"></A><A HREF="node121.html#Node121"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node118.html#Node118"> Caching</a>
<b>Next: </b><A HREF="node121.html#Node121"> Formalizing the Loosely Synchronous Model</a>
<b>Previous: </b><A HREF="node119.html#Node119"> Functionality</a>
<P>
  
<P> 
 
<BR> 
[]<em> Advice to users.</em>  
<P> 
This example shows how to write a collective communication operation  
that uses caching to be more efficient after the first call.  
The coding style assumes that  MPI function results return only  
error statuses.  
 (<em> End of advice to users.</em>) <BR> 
<BR> 
<pre><tt>/* key for this module's stuff: */ 
   static int gop_key = MPI_KEYVAL_INVALID; 
<P> 
typedef struct 
   { 
      int ref_count;          /* reference count */ 
      /* other stuff, whatever else we want */ 
   } gop_stuff_type; 
<P> 
Efficient_Collective_Op (comm, ...) 
   MPI_Comm comm; 
   { 
     gop_stuff_type *gop_stuff; 
     MPI_Group       group; 
     int             foundflag; 
<P> 
MPI_Comm_group(comm, &amp;group); 
<P> 
if (gop_key == MPI_KEYVAL_INVALID) /* get a key on first call ever */ 
     { 
       if ( ! MPI_keyval_create( gop_stuff_copier, 
                                gop_stuff_destructor, 
                                &amp;gop_key, (void *)0)); 
       /* get the key while assigning its copy and delete callback 
          behavior. */ 
<P> 
MPI_Abort (comm, 99); 
     } 
<P> 
MPI_Attr_get (comm, gop_key, &amp;gop_stuff, &amp;foundflag); 
     if (foundflag) 
     { /* This module has executed in this group before. 
          We will use the cached information */ 
     } 
     else 
     { /* This is a group that we have not yet cached anything in. 
          We will now do so. 
       */ 
<P> 
/* First, allocate storage for the stuff we want, 
          and initialize the reference count */ 
<P> 
gop_stuff = (gop_stuff_type *) malloc (sizeof(gop_stuff_type)); 
       if (gop_stuff == NULL) { /* abort on out-of-memory error */ } 
<P> 
gop_stuff -&gt; ref_count = 1; 
<P> 
/* Second, fill in *gop_stuff with whatever we want. 
          This part isn't shown here */ 
<P> 
/* Third, store gop_stuff as the attribute value */ 
       MPI_Attr_put ( comm, gop_key, gop_stuff); 
     } 
     /* Then, in any case, use contents of *gop_stuff 
        to do the global op ... */ 
   } 
<P> 
/* The following routine is called by MPI when a group is freed */ 
<P> 
gop_stuff_destructor (comm, keyval, gop_stuff, extra) 
   MPI_Comm comm; 
   int keyval; 
   gop_stuff_type *gop_stuff; 
   void *extra; 
   { 
     if (keyval != gop_key) { /* abort -- programming error */ } 
<P> 
/* The group's being freed removes one reference to gop_stuff */ 
     gop_stuff -&gt; ref_count -= 1; 
<P> 
/* If no references remain, then free the storage */ 
     if (gop_stuff -&gt; ref_count == 0) { 
       free((void *)gop_stuff); 
     } 
   } 
<P> 
/* The following routine is called by MPI when a group is copied */ 
   gop_stuff_copier (comm, keyval, extra, gop_stuff_in, gop_stuff_out, flag) 
   MPI_Comm comm; 
   int keyval; 
   gop_stuff_type *gop_stuff_in, *gop_stuff_out; 
   void *extra; 
   { 
     if (keyval != gop_key) { /* abort -- programming error */ } 
<P> 
/* The new group adds one reference to this gop_stuff */ 
     gop_stuff -&gt; ref_count += 1; 
     gop_stuff_out = gop_stuff_in; 
   } 
</tt></pre> 

<P>
<HR>
<A HREF="node119.html#Node119"><IMG SRC="previous.gif"></A><A HREF="node118.html#Node118"><IMG SRC="up.gif"></A><A HREF="node121.html#Node121"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node118.html#Node118"> Caching</a>
<b>Next: </b><A HREF="node121.html#Node121"> Formalizing the Loosely Synchronous Model</a>
<b>Previous: </b><A HREF="node119.html#Node119"> Functionality</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
