<HTML>
<!-- This file was generated by tohtml from prof.tex -->
<TITLE>Complications</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node162">8.4.3. Complications</a></H2>
<A HREF="node159.html#Node161"><IMG SRC="previous.gif"></A><A HREF="node157.html#Node157"><IMG SRC="up.gif"></A><A HREF="node162.html#Node163"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node157.html#Node157"> Examples</a>
<b>Next: </b><A HREF="node162.html#Node163"> Multiple counting</a>
<b>Previous: </b><A HREF="node159.html#Node161"> Systems without weak symbols</a>
<P>
<menu> 
</menu> 

<P>
<HR>
<A HREF="node159.html#Node161"><IMG SRC="previous.gif"></A><A HREF="node157.html#Node157"><IMG SRC="up.gif"></A><A HREF="node162.html#Node163"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node157.html#Node157"> Examples</a>
<b>Next: </b><A HREF="node162.html#Node163"> Multiple counting</a>
<b>Previous: </b><A HREF="node159.html#Node161"> Systems without weak symbols</a>
<P>
<HR><H3><A NAME="Node163">8.4.3.1. Multiple counting</a></H3>
<A HREF="node162.html#Node162"><IMG SRC="previous.gif"></A><A HREF="node162.html#Node162"><IMG SRC="up.gif"></A><A HREF="node162.html#Node164"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node162.html#Node162"> Complications</a>
<b>Next: </b><A HREF="node162.html#Node164"> Linker oddities</a>
<b>Previous: </b><A HREF="node162.html#Node162"> Complications</a>
<P>
Since parts of the  MPI library may themselves be implemented using  
more basic  MPI functions (e.g. a portable implementation of the  
collective operations implemented using point to point communications),  
there is potential for profiling functions to be called from within an  
 MPI function which was called from a profiling function. This could  
lead to ``double counting'' of the time spent in the inner routine.  
Since this effect could actually be useful under some circumstances  
(e.g. it might allow one to answer the question ``How much time is  
spent in the point to point routines when they're called from  
collective functions ?''), we have decided not to enforce any  
restrictions on the author of the  MPI library which would overcome  
this. Therefore the author of the profiling library should be aware of  
this problem, and guard against it herself. In a single threaded  
world this is easily achieved through use of a static variable in the  
profiling code which remembers if you are already inside a profiling  
routine. It becomes more complex in a multi-threaded environment (as  
does the meaning of the times recorded !)  
<P> 

<P>
<HR>
<A HREF="node162.html#Node162"><IMG SRC="previous.gif"></A><A HREF="node162.html#Node162"><IMG SRC="up.gif"></A><A HREF="node162.html#Node164"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node162.html#Node162"> Complications</a>
<b>Next: </b><A HREF="node162.html#Node164"> Linker oddities</a>
<b>Previous: </b><A HREF="node162.html#Node162"> Complications</a>
<P>
<HR><H3><A NAME="Node164">8.4.3.2. Linker oddities</a></H3>
<A HREF="node162.html#Node163"><IMG SRC="previous.gif"></A><A HREF="node162.html#Node162"><IMG SRC="up.gif"></A><A HREF="node165.html#Node165"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node162.html#Node162"> Complications</a>
<b>Next: </b><A HREF="node165.html#Node165"> Multiple levels of interception</a>
<b>Previous: </b><A HREF="node162.html#Node163"> Multiple counting</a>
<P>
The Unix linker traditionally operates in one pass : the effect of this  
is that functions from libraries are only included in the image if  
they are needed at the time the library is scanned. When combined with  
weak symbols, or multiple definitions of the same function, this can  
cause odd (and unexpected) effects.   
<P> 
Consider, for instance, an implementation of  MPI in which the Fortran  
binding is achieved by using wrapper functions on top of the C  
implementation. The author of the profile library then assumes that it  
is reasonable only to provide profile functions for the C binding,  
since Fortran will eventually call these, and the cost of the wrappers  
is assumed to be small. However, if the wrapper functions are not in  
the profiling library, then none of the profiled entry points will be  
undefined when the profiling library is called. Therefore none of the  
profiling code will be included in the image. When the standard  MPI  
library is scanned, the Fortran wrappers will be resolved, and will  
also pull in the base versions of the  MPI functions. The overall  
effect is that the code will link successfully, but will not be  
profiled.  
<P> 
To overcome this we must ensure that the Fortran wrapper functions are  
included in the profiling version of the library. We ensure that this  
is possible by requiring that these be separable from the rest of the  
base  MPI library. This allows them to be <tt> ar</tt>ed out of the base  
library and into the profiling one.  
<P> 

<P>
<HR>
<A HREF="node162.html#Node163"><IMG SRC="previous.gif"></A><A HREF="node162.html#Node162"><IMG SRC="up.gif"></A><A HREF="node165.html#Node165"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node162.html#Node162"> Complications</a>
<b>Next: </b><A HREF="node165.html#Node165"> Multiple levels of interception</a>
<b>Previous: </b><A HREF="node162.html#Node163"> Multiple counting</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
