<HTML>
<!-- This file was generated by tohtml from pt2pt.tex -->
<TITLE>Send-receive</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node52">3.10. Send-receive</a></H1>
<A HREF="node51.html#Node51"><IMG SRC="previous.gif"></A><A HREF="node28.html#Node28"><IMG SRC="up.gif"></A><A HREF="node53.html#Node53"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node28.html#Node28"> Point-to-Point Communication</a>
<b>Next: </b><A HREF="node53.html#Node53"> Null processes</a>
<b>Previous: </b><A HREF="node51.html#Node51"> Persistent communication requests</a>
<P>
  
<P> 
The <b> send-receive</b> operations combine in one call the sending of a  
message to one destination and the receiving of another message, from  
another process.  The two (source and destination) are possibly the same.  
A send-receive operation is  
very useful for executing a shift operation across a chain of  
processes.  If blocking sends and receives are used for such a shift,  
then one needs to order the sends and receives correctly (for  
example, even processes  
send, then receive, odd processes receive first, then send) so as to prevent  
cyclic dependencies that may lead to deadlock.  When a send-receive  
operation is used, the communication subsystem takes care of  
these issues.  The send-receive operation can be used in conjunction  
with the functions described in Chapter <a href="node127.html#Node127">Process Topologies
</a> in order to  
perform shifts on various logical topologies.  
Also, a send-receive operation is useful for implementing  
remote procedure calls.  
<P> 
A message sent by a  
send-receive operation can be received by a regular receive  
operation or probed by a probe operation; a send-receive operation can  
receive a message sent by a regular send operation.  
<P> 
    
      
      
      
      
     MPI_SENDRECV(sendbuf, sendcount, sendtype, dest,  
sendtag, recvbuf, recvcount, recvtype, source, recvtag, comm, status)  
     
<BR> 
[  IN   sendbuf] initial address of send buffer (choice)  
 
<BR> 
[  IN   sendcount] number of elements in send buffer (integer)  
 
<BR> 
[  IN   sendtype] type of elements in send buffer (handle)  
 
<BR> 
[  IN   dest] rank of destination (integer)  
 
<BR> 
[  IN   sendtag] send tag (integer)  
 
<BR> 
[  OUT   recvbuf] initial address of receive buffer (choice)  
 
<BR> 
[  IN   recvcount] number of elements in receive buffer (integer)  
 
<BR> 
[  IN   recvtype]  type of elements in receive buffer (handle)  
 
<BR> 
[  IN   source] rank of source (integer)  
 
<BR> 
[  IN   recvtag] receive tag (integer)  
 
<BR> 
[  IN   comm] communicator (handle)  
 
<BR> 
[  OUT   status] status object (Status)  
<BR> 
  
<P> 
 <tt> int MPI_Sendrecv(void *sendbuf, int sendcount, MPI_Datatype sendtype, int dest, int sendtag, void *recvbuf, int recvcount, MPI_Datatype recvtype, int source, int recvtag, MPI_Comm comm, MPI_Status *status) <BR></tt>  
<P> 
 <tt> MPI_SENDRECV(SENDBUF, SENDCOUNT, SENDTYPE, DEST, SENDTAG, RECVBUF, RECVCOUNT, RECVTYPE, SOURCE, RECVTAG, COMM, STATUS, IERROR)<BR> &lt;type&gt; SENDBUF(*), RECVBUF(*) <BR>INTEGER  SENDCOUNT, SENDTYPE, DEST, SENDTAG, RECVCOUNT, RECVTYPE, SOURCE, RECV  
TAG, COMM, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
<P> 
Execute a blocking send and receive operation.  Both send and receive  
use the same communicator, but  
possibly different tags.  The send buffer and receive buffers must be  
disjoint, and may have different lengths and datatypes.  
<P> 
    
      
      
      
      
     MPI_SENDRECV_REPLACE(buf, count, datatype, dest,  
sendtag, source, recvtag, comm, status)  
     
<BR> 
[  INOUT   buf] initial address of send and receive buffer (choice)  
 
<BR> 
[  IN   count] number of elements in send and receive buffer (integer)  
 
<BR> 
[  IN   datatype] type of elements in send and receive buffer (handle)  
 
<BR> 
[  IN   dest] rank of destination (integer)  
 
<BR> 
[  IN   sendtag] send message tag (integer)  
 
<BR> 
[  IN   source] rank of source (integer)  
 
<BR> 
[  IN   recvtag] receive message tag (integer)  
 
<BR> 
[  IN   comm] communicator (handle)  
 
<BR> 
[  OUT   status] status object (Status)  
<BR> 
  
<P> 
 <tt> int MPI_Sendrecv_replace(void* buf, int count, MPI_Datatype datatype, int dest, int sendtag, int source, int recvtag, MPI_Comm comm, MPI_Status *status) <BR></tt>  
<P> 
 <tt> MPI_SENDRECV_REPLACE(BUF, COUNT, DATATYPE, DEST, SENDTAG, SOURCE, RECVTAG, COMM, STATUS, IERROR)<BR> &lt;type&gt; BUF(*) <BR>INTEGER COUNT, DATATYPE, DEST, SENDTAG, SOURCE, RECVTAG, COMM, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
<P> 
Execute a blocking send and receive. The same buffer is used both for  
the send and for the receive, so that the message sent is replaced by  
the message received.  
<P> 
The semantics of a send-receive operation is what would be obtained  
if the caller forked two concurrent threads, one to execute the send,  
and one to execute the receive, followed by a join of these two  
threads.  
<P> 
 
<BR> 
[]<em> Advice  
 to implementors.</em>  
<P> 
Additional intermediate buffering is needed for the  
``replace'' variant.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node51.html#Node51"><IMG SRC="previous.gif"></A><A HREF="node28.html#Node28"><IMG SRC="up.gif"></A><A HREF="node53.html#Node53"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node28.html#Node28"> Point-to-Point Communication</a>
<b>Next: </b><A HREF="node53.html#Node53"> Null processes</a>
<b>Previous: </b><A HREF="node51.html#Node51"> Persistent communication requests</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
