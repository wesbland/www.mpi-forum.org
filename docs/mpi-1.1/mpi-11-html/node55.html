<HTML>
<!-- This file was generated by tohtml from pt2pt.tex -->
<TITLE>Datatype constructors</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node55">3.12.1. Datatype constructors</a></H2>
<A HREF="node54.html#Node54"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node56.html#Node56"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node56.html#Node56"> Address and extent functions</a>
<b>Previous: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<P>
  
<P> 
<P> 
Contiguous The simplest datatype constructor is  
 MPI_TYPE_CONTIGUOUS which  
allows replication of a datatype into contiguous locations.  
<P> 
    
      
      
      
      
     MPI_TYPE_CONTIGUOUS(count, oldtype, newtype)  
     
<BR> 
[  IN   count] replication count (nonnegative integer)  
 
<BR> 
[  IN   oldtype] old datatype (handle)  
 
<BR> 
[  OUT   newtype] new datatype (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Type_contiguous(int count, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CONTIGUOUS(COUNT, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER  COUNT, OLDTYPE, NEWTYPE, IERROR <BR></tt>  
<P> 
 newtype is the datatype obtained by concatenating  
 count copies of  
 oldtype.   Concatenation is defined using <em> extent</em> as the size of  
the concatenated copies.  
<P> 
<BR><b> Example</b>   
  
Let  oldtype have type map  
<IMG SRC="img15.gif">
with extent 16,  
and let <IMG SRC="img16.gif">
.  The type map of  
the datatype returned by  newtype is  
<P><IMG SRC="img17.gif"><P>
i.e., alternating  double and  char elements, with displacements  
<I>0, 8, 16, 24, 32, 40</i>.  
   
<P> 
  
In general,  
assume that the type map of  oldtype is  
<P><IMG SRC="img18.gif"><P>
with extent <I>ex</i>.  
Then  newtype has a type map with <IMG SRC="img19.gif">
 entries  
defined by:  
<P><IMG SRC="img20.gif"><P>
<P><IMG SRC="img21.gif"><P>
  
<P> 
<P> 
Vector The function  
 MPI_TYPE_VECTOR is a more general constructor that  
allows replication of a datatype  
into locations that consist of equally spaced blocks.  Each block  
is obtained by concatenating the same number of copies of the old datatype.  
The spacing between blocks is a multiple of the extent of the old datatype.  
<P> 
    
      
      
      
      
     MPI_TYPE_VECTOR( count, blocklength, stride, oldtype,  
newtype)  
     
<BR> 
[  IN   count] number of blocks (nonnegative integer)  
 
<BR> 
[  IN   blocklength] number of elements in each block  
(nonnegative integer)  
 
<BR> 
[  IN   stride] number of elements between start of each block (integer)  
 
<BR> 
[  IN   oldtype] old datatype (handle)  
 
<BR> 
[  OUT   newtype] new datatype (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Type_vector(int count, int blocklength, int stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_VECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER  COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR <BR></tt>  
<P> 
<BR><b> Example</b>   
  
Assume, again, that  oldtype has type map  
<IMG SRC="img22.gif">
with extent 16.  
A call to  MPI_TYPE_VECTOR( 2, 3, 4, oldtype, newtype) will  
create the datatype with type map,  
<P><IMG SRC="img23.gif"><P>
<P><IMG SRC="img24.gif"><P>
That is, two blocks with three copies each of the old  
type, with a stride of 4 elements (<IMG SRC="img25.gif">
 bytes) between the blocks.  
   
<P> 
<BR><b> Example</b>   
  
A call to  MPI_TYPE_VECTOR(3, 1, -2, oldtype, newtype) will create  
the datatype,  
<P><IMG SRC="img26.gif"><P>
   
<P> 
  
In general, assume that  oldtype has type map,  
<P><IMG SRC="img27.gif"><P>
with extent <I>ex</i>.  Let  bl be the  blocklength.  
The newly created  datatype has a type map with  
<IMG SRC="img28.gif">
<P> 
entries:  
<P><IMG SRC="img29.gif"><P>
<P><IMG SRC="img30.gif"><P>
<P><IMG SRC="img31.gif"><P>
<P><IMG SRC="img32.gif"><P>
<P><IMG SRC="img33.gif"><P>
<P><IMG SRC="img34.gif"><P>
<P><IMG SRC="img35.gif"><P>
<P><IMG SRC="img36.gif"><P>
<P><IMG SRC="img37.gif"><P>
  
<P> 
A call to  MPI_TYPE_CONTIGUOUS(count, oldtype, newtype) is  
equivalent to a call to  
 MPI_TYPE_VECTOR(count, 1, 1, oldtype, newtype), or to a call to  
 MPI_TYPE_VECTOR(1, count, n, oldtype, newtype),  n arbitrary.  
<P> 
<P> 
Hvector The function  MPI_TYPE_HVECTOR is identical to  
 MPI_TYPE_VECTOR, except that  stride is given in bytes,  
rather than in elements.  The use for both types of vector  
constructors is illustrated in Sec. <a href="node61.html#Node61">Examples
</a>.  
( H stands for ``heterogeneous'').  
<P> 
    
      
      
      
      
     MPI_TYPE_HVECTOR( count, blocklength, stride,  
oldtype, newtype)  
     
<BR> 
[  IN   count] number of blocks (nonnegative integer)  
 
<BR> 
[  IN   blocklength] number of elements in each block  
(nonnegative integer)  
 
<BR> 
[  IN   stride] number of bytes between start of each block (integer)  
 
<BR> 
[  IN   oldtype] old datatype (handle)  
 
<BR> 
[  OUT   newtype] new datatype (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Type_hvector(int count, int blocklength, MPI_Aint stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_HVECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER  COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR <BR></tt>  
<P> 
  
Assume that  oldtype has type map,  
<P><IMG SRC="img38.gif"><P>
with extent <I>ex</i>.  Let  bl be the  blocklength.  
The newly created  datatype has a type map with  
<IMG SRC="img39.gif">
<P> 
entries:  
<P><IMG SRC="img40.gif"><P>
<P><IMG SRC="img41.gif"><P>
<P><IMG SRC="img42.gif"><P>
<P><IMG SRC="img43.gif"><P>
<P><IMG SRC="img44.gif"><P>
<P><IMG SRC="img45.gif"><P>
<P><IMG SRC="img46.gif"><P>
<P><IMG SRC="img47.gif"><P>
<P><IMG SRC="img48.gif"><P>
  
<P> 
<P> 
Indexed The function  
 MPI_TYPE_INDEXED allows  
replication of an old datatype into a sequence of blocks (each block is  
a concatenation of the old datatype), where  
each block can contain a different number of copies and have a different  
displacement.  All block displacements are multiples of the old type  
extent.  
<P> 
    
      
      
      
      
     MPI_TYPE_INDEXED( count, array_of_blocklengths,  
array_of_displacements, oldtype, newtype)  
     
<BR> 
[  IN   count] number of blocks -- also number of entries in  
<BR> array_of_displacements and  
 array_of_blocklengths (nonnegative integer)  
 
<BR> 
[  IN   array_of_blocklengths] number of elements per block  
(array of nonnegative integers)  
 
<BR> 
[  IN   array_of_displacements] displacement for each block,  
in multiples of  oldtype extent (array of integer)  
 
<BR> 
[  IN   oldtype] old datatype (handle)  
 
<BR> 
[  OUT   newtype] new datatype (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Type_indexed(int count, int *array_of_blocklengths, int *array_of_displacements, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_INDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_DISPLACEMENTS(*), OLDTYPE, NEWTYPE, IERROR <BR></tt>  
<P> 
<BR><b> Example</b>   
  
<P> 
Let  oldtype have type map  
<IMG SRC="img49.gif">
with extent 16.  
Let   B = (3, 1) and let  D = (4, 0).  A call to  
 MPI_TYPE_INDEXED(2, B, D, oldtype, newtype) returns a datatype with  
type map,  
<P><IMG SRC="img50.gif"><P>
<P><IMG SRC="img51.gif"><P>
That is, three copies of the old type starting at displacement  
64, and one copy starting at displacement 0.  
   
<P> 
  
In general,  
assume that  oldtype has type map,  
<P><IMG SRC="img52.gif"><P>
with extent <em> ex</em>.  
Let  B be the  array_of_blocklength argument and  
 D be the  
<BR>  
 array_of_displacements argument. The newly created datatype  
has <IMG SRC="img53.gif">
 entries:  
<P><IMG SRC="img54.gif"><P>
<P><IMG SRC="img55.gif"><P>
<P><IMG SRC="img56.gif"><P>
<P><IMG SRC="img57.gif"><P>
<P><IMG SRC="img58.gif"><P>
  
<P> 
A call to  MPI_TYPE_VECTOR(count, blocklength, stride, oldtype,  
newtype) is equivalent to a call to  
 MPI_TYPE_INDEXED(count, B, D, oldtype, newtype) where  
<P><IMG SRC="img59.gif"><P>
and  
<P><IMG SRC="img60.gif"><P>
<P> 
Hindexed The function  MPI_TYPE_HINDEXED is identical to  
 MPI_TYPE_INDEXED, except that block displacements in  
 array_of_displacements are specified in  
bytes, rather than in multiples of the  oldtype extent.  
<P> 
    
      
      
      
      
     MPI_TYPE_HINDEXED( count, array_of_blocklengths,  
array_of_displacements, oldtype, newtype)  
     
<BR> 
[  IN   count] number of blocks  -- also number of entries in  
<BR> array_of_displacements and  
 array_of_blocklengths (integer)  
 
<BR> 
[  IN   array_of_blocklengths] number of elements in each block  
(array of nonnegative integers)  
 
<BR> 
[  IN   array_of_displacements] byte displacement of each block  
(array of integer)  
 
<BR> 
[  IN   oldtype] old datatype (handle)  
 
<BR> 
[  OUT   newtype] new datatype (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Type_hindexed(int count, int *array_of_blocklengths, MPI_Aint *array_of_displacements, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_HINDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_DISPLACEMENTS(*), OLDTYPE, NEWTYPE, IERROR <BR></tt>  
<P> 
  
Assume that  oldtype has type map,  
<P><IMG SRC="img61.gif"><P>
with extent <I>ex</i>.  
Let  B be the  array_of_blocklength argument and  
 D be the  
<BR>  
 array_of_displacements argument. The newly created datatype  
has a type map with  
<IMG SRC="img62.gif">
 entries:  
<P><IMG SRC="img63.gif"><P>
<P><IMG SRC="img64.gif"><P>
<P><IMG SRC="img65.gif"><P>
<P><IMG SRC="img66.gif"><P>
<P><IMG SRC="img67.gif"><P>
<P><IMG SRC="img68.gif"><P>
  
<P> 
<P> 
Struct  MPI_TYPE_STRUCT is the most general type constructor.  
It further generalizes  
the previous one in that it allows each block to consist of replications of  
different datatypes.  
<P> 
    
      
      
      
      
     MPI_TYPE_STRUCT(count, array_of_blocklengths,  
array_of_displacements, array_of_types, newtype)  
     
<BR> 
[  IN   count] number of blocks (integer) -- also number of  
entries in arrays  array_of_types,  
 array_of_displacements and  array_of_blocklengths  
 
<BR> 
[  IN   array_of_blocklength] number of elements in each block  
(array of integer)  
 
<BR> 
[  IN   array_of_displacements] byte displacement of each block  
(array of integer)  
 
<BR> 
[  IN   array_of_types] type of elements in each block (array  
of handles to datatype objects)  
 
<BR> 
[  OUT   newtype] new datatype (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Type_struct(int count, int *array_of_blocklengths, MPI_Aint *array_of_displacements, MPI_Datatype *array_of_types, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_STRUCT(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, ARRAY_OF_TYPES, NEWTYPE, IERROR)<BR> INTEGER  COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_DISPLACEMENTS(*), ARRAY_OF_TYPES(*), NEWTYPE, IERROR <BR></tt>  
<P> 
<BR><b> Example</b>   
  
Let  type1 have type map,  
<P><IMG SRC="img69.gif"><P>
with extent 16.  
Let  B = (2, 1, 3),  D = (0, 16, 26),  
and  T = (MPI_FLOAT, type1, MPI_CHAR).  Then a call to  
 MPI_TYPE_STRUCT(3, B, D, T, newtype) returns  
a datatype with type map,  
<P><IMG SRC="img70.gif"><P>
That is, two copies of  MPI_FLOAT starting at 0, followed by  
one copy of  type1 starting at 16, followed by three copies of  
 MPI_CHAR, starting at 26.  
(We assume that a float occupies four bytes.)  
   
<P> 
  
In general,  
let  T be the  array_of_types argument, where  T[i]  
is a handle to,  
<P><IMG SRC="img71.gif"><P>
with extent <I>ex<SUB>i</SUB></i>.  
Let  
 B be the  array_of_blocklength argument and  D be  
the  array_of_displacements argument.Let  c be the  
 count argument.  
Then the newly created datatype has a type map with  
<IMG SRC="img72.gif">
<P> 
entries:  
<P><IMG SRC="img73.gif"><P>
<P><IMG SRC="img74.gif"><P>
<P><IMG SRC="img75.gif"><P>
<P><IMG SRC="img76.gif"><P>
<P><IMG SRC="img77.gif"><P>
  
<P> 
A call to  MPI_TYPE_HINDEXED( count, B, D, oldtype, newtype) is  
equivalent to a call to  
 MPI_TYPE_STRUCT( count, B, D, T, newtype), where each entry  
of  T is equal to  oldtype.  
<P> 

<P>
<HR>
<A HREF="node54.html#Node54"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node56.html#Node56"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node56.html#Node56"> Address and extent functions</a>
<b>Previous: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
