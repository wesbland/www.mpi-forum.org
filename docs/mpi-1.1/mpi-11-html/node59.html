<HTML>
<!-- This file was generated by tohtml from pt2pt.tex -->
<TITLE>Use of general datatypes in communication</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node59">3.12.5. Use of general datatypes in communication</a></H2>
<A HREF="node58.html#Node58"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node60.html#Node60"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node60.html#Node60"> Correct use of addresses</a>
<b>Previous: </b><A HREF="node58.html#Node58"> Commit and free</a>
<P>
  
<P> 
Handles to derived datatypes can be passed to a communication call wherever a  
datatype argument is required.  
A call of the form  MPI_SEND(buf, count, datatype , ...), where  
<IMG SRC="img85.gif">
, is interpreted as if the call was passed a new datatype  
which is the  
concatenation of  count copies of  datatype.  
Thus,  
 MPI_SEND(buf, count, datatype, dest, tag, comm) is equivalent to,  
<BR> 
<pre><tt>MPI_TYPE_CONTIGUOUS(count, datatype, newtype) 
MPI_TYPE_COMMIT(newtype) 
MPI_SEND(buf, 1, newtype, dest, tag, comm). 
</tt></pre> 
Similar statements apply to all other communication functions that have a  
 count and  datatype argument.  
<P> 
Suppose that a send operation  MPI_SEND(buf, count,  
datatype, dest, tag, comm) is executed, where  
 datatype has type map,  
<P><IMG SRC="img86.gif"><P>
and extent <I>extent</i>.  (Empty entries of ``pseudo-type''    
MPI_UB and   MPI_LB are not listed in the type map, but  
they affect the value of <I>extent</i>.)  
The send  
operation sends <IMG SRC="img87.gif">
 entries, where entry <IMG SRC="img88.gif">
 is at location  
<IMG SRC="img89.gif">
<P> 
and has type <I>type<SUB>j</SUB></i>,  
for <IMG SRC="img90.gif">
 and <I>j = 0 ,..., n-1</i>.  
These entries need not be contiguous, nor distinct; their order can be  
arbitrary.  
<P> 
The variable stored at address <I>addr<SUB>i,j</SUB></i> in the calling program  
should be of a type that matches <I>type<SUB>j</SUB></i>, where  
type matching is defined as in section <a href="node37.html#Node37">Type matching rules
</a>.  
The message sent contains <IMG SRC="img91.gif">
 entries, where entry  
<IMG SRC="img92.gif">
 has type <I>type<SUB>j</SUB></i>.  
<P> 
Similarly, suppose that a receive operation  
 MPI_RECV(buf, count, datatype, source, tag, comm, status) is  
executed, where  datatype has type map,  
<P><IMG SRC="img93.gif"><P>
  
with extent <I>extent</i>.  (Again, empty entries of ``pseudo-type''    
MPI_UB and   MPI_LB are not listed in the type map, but  
they affect the value of <I>extent</i>.)  
This receive operation receives  
<IMG SRC="img94.gif">
 entries, where entry <IMG SRC="img95.gif">
 is at location  
<IMG SRC="img96.gif">
<P> 
and has type <I>type<SUB>j</SUB></i>.  If the incoming message consists of <I>k</i>  
elements, then we must have <IMG SRC="img97.gif">
; the <IMG SRC="img98.gif">
-th element of the message should have a type that matches <I>type<SUB>j</SUB></i>.  
<P> 
Type matching is defined according to the type signature of  
the corresponding datatypes, that is, the sequence of basic type  
components.  Type matching does not depend on some aspects of the  
datatype definition, such as the displacements (layout in memory) or the  
intermediate types used.  
<P> 
<BR><b> Example</b>   
  
This example shows that type matching is defined in terms of  
the basic types that a derived type consists of.  
<BR> 
<pre><tt>... 
CALL MPI_TYPE_CONTIGUOUS( 2, MPI_REAL, type2, ...) 
CALL MPI_TYPE_CONTIGUOUS( 4, MPI_REAL, type4, ...) 
CALL MPI_TYPE_CONTIGUOUS( 2, type2, type22, ...) 
... 
CALL MPI_SEND( a, 4, MPI_REAL, ...) 
CALL MPI_SEND( a, 2, type2, ...) 
CALL MPI_SEND( a, 1, type22, ...) 
CALL MPI_SEND( a, 1, type4, ...) 
... 
CALL MPI_RECV( a, 4, MPI_REAL, ...) 
CALL MPI_RECV( a, 2, type2, ...) 
CALL MPI_RECV( a, 1, type22, ...) 
CALL MPI_RECV( a, 1, type4, ...) 
</tt></pre> 
Each of the sends matches any of the receives.  
   
<P> 
  
A datatype may specify overlapping entries. The use of such a  
datatype in a receive operation is erroneous. (This is erroneous even  
if the actual message received is short enough not to write any entry  
more than once.)  
  
<P> 
A datatype may specify overlapping entries.  If such a datatype is used  
in a receive operation, that is, if some part of the receive buffer  
is written more than once by the receive operation, then the  
call is erroneous.  
<P> 
Suppose that  
 MPI_RECV(buf, count, datatype, dest, tag, comm, status) is  
executed, where  datatype has type map,  
<P><IMG SRC="img99.gif"><P>
The received message need not fill all the receive buffer, nor does it  
need to fill a number of locations which is a multiple of <I>n</i>.  
Any number, <I>k</i>, of basic  
elements can be received, where <IMG SRC="img100.gif">
.  
The number of basic elements received can be retrieved from  
 status using the query function  MPI_GET_ELEMENTS.  
<P> 
    
      
      
      
      
     MPI_GET_ELEMENTS( status, datatype, count)  
     
<BR> 
[  IN   status] return status of receive operation (Status)  
 
<BR> 
[  IN   datatype] datatype used by receive operation (handle)  
 
<BR> 
[  OUT   count] number of received basic elements (integer)  
<BR> 
  
<P> 
  
 <tt> int MPI_Get_elements(MPI_Status *status, MPI_Datatype datatype, int *count) <BR></tt>  
  
<P> 
 <tt> MPI_GET_ELEMENTS(STATUS, DATATYPE, COUNT, IERROR)<BR> INTEGER  STATUS(MPI_STATUS_SIZE), DATATYPE, COUNT, IERROR <BR></tt>  
<P> 
The previously defined  
function,  MPI_GET_COUNT (Sec. <a href="node35.html#Node35">Return status
</a>), has  
a different behavior.  
  
It returns the number of ``top-level  
entries'' received, i.e. the number of ``copies'' of type  
 datatype.  
  
In the previous example,  MPI_GET_COUNT  
may return any integer value <I>k</i>, where <IMG SRC="img101.gif">
.  
If  MPI_GET_COUNT returns <I>k</i>, then the number of basic  
elements received (and the value returned by <BR>  
 MPI_GET_ELEMENTS)  
is <IMG SRC="img102.gif">
.   If the number of basic elements received is not a  
multiple of <I>n</i>, that is, if the receive operation has not received an  
integral number of  datatype ``copies,'' then  
 MPI_GET_COUNT returns the value  MPI_UNDEFINED.  
<P> 
<BR><b> Example</b>   
  
Usage of  MPI_GET_COUNT and  MPI_GET_ELEMENT.  
<BR> 
<pre><tt>... 
CALL MPI_TYPE_CONTIGUOUS(2, MPI_REAL, Type2, ierr) 
CALL MPI_TYPE_COMMIT(Type2, ierr) 
... 
CALL MPI_COMM_RANK(comm, rank, ierr) 
IF(rank.EQ.0) THEN 
      CALL MPI_SEND(a, 2, MPI_REAL, 1, 0, comm, ierr) 
      CALL MPI_SEND(a, 3, MPI_REAL, 1, 0, comm, ierr) 
ELSE 
      CALL MPI_RECV(a, 2, Type2, 0, 0, comm, stat, ierr) 
      CALL MPI_GET_COUNT(stat, Type2, i, ierr)     ! returns i=1 
      CALL MPI_GET_ELEMENTS(stat, Type2, i, ierr)  ! returns i=2 
      CALL MPI_RECV(a, 2, Type2, 0, 0, comm, stat, ierr) 
      CALL MPI_GET_COUNT(stat, Type2, i, ierr)     ! returns i=MPI_UNDEFINED 
      CALL MPI_GET_ELEMENTS(stat, Type2, i, ierr)  ! returns i=3 
END IF 
</tt></pre> 
   
<P> 
The function  MPI_GET_ELEMENTS can also be used after a probe  
to find the number of elements in the probed message.  
Note that the two functions  MPI_GET_COUNT and  
 MPI_GET_ELEMENTS return the same values when they are used  
with basic datatypes.  
<P> 
 
<BR> 
[]<em> Rationale.</em>  
<P> 
The extension given to the definition of  MPI_GET_COUNT seems  
natural: one would expect this function to return the value of the  
 count argument, when the receive buffer is filled.  
Sometimes  datatype represents  
a basic unit of data one wants to transfer,  
for example, a record in an array of records (structures).  
One should be able to find out how many components were received  
without bothering to divide by the number of elements in each  
component.   However, on other occasions,  datatype is used to  
define a complex layout of data in the receiver memory, and does not represent  
a basic unit of data for transfers.  In such cases, one needs to use  
the function  MPI_GET_ELEMENTS.  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
[]<em> Advice  
 to implementors.</em>  
<P> 
The definition implies that a receive cannot change the value of  
storage outside the entries defined to compose the communication  
buffer.  
In particular, the definition implies that padding space in a structure  
should not be modified when such a structure is copied from one process to  
another. This would  
prevent the obvious optimization of copying the structure, together  
with the padding, as one contiguous block.  
The implementation is free to do this optimization when it does not  
impact the outcome of the computation.  
The user can ``force'' this optimization by explicitly including  
padding as part of the message.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node58.html#Node58"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node60.html#Node60"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node60.html#Node60"> Correct use of addresses</a>
<b>Previous: </b><A HREF="node58.html#Node58"> Commit and free</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
