<HTML>
<!-- This file was generated by tohtml from pt2pt.tex -->
<TITLE>Derived datatypes</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node54">3.12. Derived datatypes</a></H1>
<A HREF="node53.html#Node53"><IMG SRC="previous.gif"></A><A HREF="node28.html#Node28"><IMG SRC="up.gif"></A><A HREF="node55.html#Node55"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node28.html#Node28"> Point-to-Point Communication</a>
<b>Next: </b><A HREF="node55.html#Node55"> Datatype constructors</a>
<b>Previous: </b><A HREF="node53.html#Node53"> Null processes</a>
<P>
  
<P> 
Up to here, all point to point communication have involved only contiguous  
buffers containing a sequence of elements of the same type.  
This is too constraining on two accounts.  One often wants to pass  
messages that contain values with different datatypes (e.g., an integer count,  
followed by a sequence of real numbers); and one often wants to send  
noncontiguous data (e.g., a sub-block of a matrix).  One solution is to  
pack noncontiguous data into a contiguous buffer  
at the sender site and unpack it back at the receiver site.   This has  
the disadvantage of requiring additional memory-to-memory copy operations  
at both sites, even when the communication  
subsystem has scatter-gather capabilities.   Instead,  MPI provides  
mechanisms to specify more general, mixed, and noncontiguous  
communication buffers. It is up to the implementation to decide  
whether data should be first packed in a contiguous buffer before being  
transmitted, or whether it can be collected directly from where it  
resides.  
<P> 
The general mechanisms provided here allow one to transfer directly,  
without copying, objects of various shape and size.  It is not assumed  
that the  MPI library is cognizant of the objects declared in the host  
language. Thus, if one wants to transfer a structure, or an array  
section, it will be necessary to provide in  MPI a definition of a  
communication buffer that mimics the definition of the structure or  
array section in question.  These facilities can be used by library  
designers to define communication functions that can transfer objects  
defined in the host language --- by decoding their definitions as  
available in a symbol table or a dope vector.  Such higher-level  
communication functions are not part of  MPI.  
<P> 
More general communication buffers are specified by replacing the  
basic datatypes that have been used so far with derived datatypes that  
are constructed from basic datatypes using the constructors described  
in this section.  These methods of constructing derived datatypes can  
be applied recursively.  
<P> 
A <b> general datatype</b> is an opaque object that specifies two  
things:  
<ul> 
 
<li>A sequence of basic datatypes  
 
<li>A sequence of integer (byte) displacements  
</ul> 
<BR> 
The displacements are not required to be positive, distinct, or  
in increasing order. Therefore, the order of items need not  
coincide with their order in store, and an item may appear more than  
once.  
We call such a pair of sequences (or sequence of pairs) a <b> type map</b>.  
The sequence of basic datatypes (displacements ignored) is the <b>  
type signature</b> of the datatype.  
<P> 
<P> 
Let  
<P><IMG SRC="img7.gif"><P>
be such a type map, where <I>type<SUB>i</SUB></i> are basic types, and  
<I>disp<SUB>i</SUB></i> are  displacements.  
Let  
<P><IMG SRC="img8.gif"><P>
be the associated type signature.  
This type map, together with a base address <em> buf</em>,  
specifies a communication buffer: the communication buffer that consists of <I>n</i>  
entries, where the <I>i</i>-th entry is at address <I>buf + 
disp<SUB>i</SUB></i> and has type <I>type<SUB>i</SUB></i>.  
A message assembled from such a  
communication buffer will consist of <I>n</i> values, of the types defined  
by <I>Typesig</i>.  
<P> 
We can use a handle to a general datatype as an argument in a send or  
receive operation, instead of a basic datatype argument.  The  
operation  
 MPI_SEND(buf, 1, datatype,...) will use the send buffer  
defined by the base address  buf and the general datatype  
associated with  datatype; it will generate a message with the type  
signature determined by the  datatype argument.  
 MPI_RECV(buf, 1, datatype,...) will use the receive buffer  
defined by the base address  buf and the general datatype  
associated with  datatype.  
<P> 
General datatypes can be used in all send and receive  
operations.  We discuss, in Sec. <a href="node59.html#Node59">Use of general datatypes in communication
</a>, the  
case where the second argument  count has value <I>&gt; 1</i>.  
<P> 
The basic datatypes presented in  
section <a href="node32.html#Node32">Message data
</a>  
are particular cases of a general datatype, and are predefined.  
Thus,  MPI_INT is a predefined handle to a datatype with type  
map <IMG SRC="img9.gif">
, with one entry of type  int and  
displacement zero.  The other basic datatypes are similar.  
<P> 
The <b> extent</b> of a datatype is defined to  
be the span from the first byte to the last byte occupied by entries in this  
datatype, rounded up to satisfy alignment requirements.  
That is, if  
<P><IMG SRC="img10.gif"><P>
then  
  
<P><A NAME="node54.html#Equation1"><IMG SRC="img11.gif"></a><P>
If <I>type<SUB>i</SUB></i> requires alignment to a byte address that is is a multiple  
of <I>k<SUB>i</SUB></i>,  
then <IMG SRC="img12.gif">
 is the least nonnegative increment needed to round  
<I>extent(Typemap)</i> to the next multiple of <IMG SRC="img13.gif">
.  
The complete definition of <b> extent</b> is given.  
<P> 
  
<P> 
<P> 
<BR><b> Example</b>   
  
Assume that  
<IMG SRC="img14.gif">
<P> 
(a  double at  
displacement zero, followed by a  char at displacement eight).  
Assume, furthermore, that  
doubles have to be strictly aligned at addresses that are multiples of eight.  
Then, the extent of this datatype is 16 (9 rounded to the next multiple of 8).  
A datatype that consists of a character immediately followed by a double will  
also have an extent of 16.  
   
<P> 
 
<BR> 
[]<em> Rationale.</em>  
<P> 
The definition of extent is motivated by the assumption that  
the amount of padding added at the end of each structure in an array of  
structures is the least needed to fulfill alignment constraints.  
More explicit control of the extent is provided in  
section <a href="node57.html#Node57">Lower-bound and upper-bound markers
</a>.  Such explicit control is needed  
in cases where the assumption does not hold, for example, where union types  
are used.  
 (<em> End of rationale.</em>) <BR> 
<menu> 
</menu> 

<P>
<HR>
<A HREF="node53.html#Node53"><IMG SRC="previous.gif"></A><A HREF="node28.html#Node28"><IMG SRC="up.gif"></A><A HREF="node55.html#Node55"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node28.html#Node28"> Point-to-Point Communication</a>
<b>Next: </b><A HREF="node55.html#Node55"> Datatype constructors</a>
<b>Previous: </b><A HREF="node53.html#Node53"> Null processes</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
