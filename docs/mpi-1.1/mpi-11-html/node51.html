<HTML>
<!-- This file was generated by tohtml from pt2pt.tex -->
<TITLE>Persistent communication requests</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node51">3.9. Persistent communication requests</a></H1>
<A HREF="node50.html#Node50"><IMG SRC="previous.gif"></A><A HREF="node28.html#Node28"><IMG SRC="up.gif"></A><A HREF="node52.html#Node52"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node28.html#Node28"> Point-to-Point Communication</a>
<b>Next: </b><A HREF="node52.html#Node52"> Send-receive</a>
<b>Previous: </b><A HREF="node50.html#Node50"> Probe and Cancel</a>
<P>
  
<P> 
Often a communication with the same argument list is repeatedly  
executed within the inner loop of a parallel computation.  In such a  
situation, it may be possible to optimize the communication by  
binding the list of communication arguments to a <b> persistent</b> communication  
request once and, then, repeatedly using  
the request to initiate and complete messages.  The  
persistent request thus created can be thought of as a  
communication port or a ``half-channel.''  
It does not provide the full functionality of a conventional channel,  
since there is no binding of the send port to the receive port. This  
construct allows reduction of the overhead for communication  
between the process and communication controller, but not of the overhead for  
communication between one communication controller and another.  
It is not necessary that messages sent with a persistent request be received  
by a receive operation using a persistent request, or vice versa.  
<P> 
A persistent communication request is created using one of the four following  
calls.  These calls involve no communication.  
<P> 
    
      
      
      
      
     MPI_SEND_INIT(buf, count, datatype, dest, tag,  
comm, request)  
     
<BR> 
[  IN   buf] initial address of send buffer (choice)  
 
<BR> 
[  IN   count] number of elements sent (integer)  
 
<BR> 
[  IN   datatype] type of each element (handle)  
 
<BR> 
[  IN   dest] rank of destination (integer)  
 
<BR> 
[  IN   tag] message tag (integer)  
 
<BR> 
[  IN   comm] communicator (handle)  
 
<BR> 
[  OUT   request] communication request (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Send_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_SEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  REQUEST, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
<P> 
Creates a persistent communication request  
for a standard mode send operation, and binds to it all the  
arguments of a send operation.  
<P> 
    
      
      
      
      
     MPI_BSEND_INIT(buf, count, datatype, dest, tag,  
comm, request)  
     
<BR> 
[  IN   buf] initial address of send buffer (choice)  
 
<BR> 
[  IN   count] number of elements sent (integer)  
 
<BR> 
[  IN   datatype] type of each element (handle)  
 
<BR> 
[  IN   dest] rank of destination (integer)  
 
<BR> 
[  IN   tag] message tag (integer)  
 
<BR> 
[  IN   comm] communicator (handle)  
 
<BR> 
[  OUT   request] communication request (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Bsend_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_BSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  REQUEST, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
<P> 
Creates a persistent communication request for a buffered mode send.  
<P> 
    
      
      
      
      
     MPI_SSEND_INIT(buf, count, datatype, dest, tag,  
comm, request)  
     
<BR> 
[  IN   buf] initial address of send buffer (choice)  
 
<BR> 
[  IN   count] number of elements sent (integer)  
 
<BR> 
[  IN   datatype] type of each element (handle)  
 
<BR> 
[  IN   dest] rank of destination (integer)  
 
<BR> 
[  IN   tag] message tag (integer)  
 
<BR> 
[  IN   comm] communicator (handle)  
 
<BR> 
[  OUT   request] communication request (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Ssend_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_SSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
<P> 
Creates a persistent communication object  
for a synchronous mode send operation.  
<P> 
    
      
      
      
      
     MPI_RSEND_INIT(buf, count, datatype, dest, tag,  
comm, request)  
     
<BR> 
[  IN   buf] initial address of send buffer (choice)  
 
<BR> 
[  IN   count] number of elements sent (integer)  
 
<BR> 
[  IN   datatype] type of each element (handle)  
 
<BR> 
[  IN   dest] rank of destination (integer)  
 
<BR> 
[  IN   tag] message tag (integer)  
 
<BR> 
[  IN   comm] communicator (handle)  
 
<BR> 
[  OUT   request] communication request (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Rsend_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_RSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
<P> 
Creates a persistent communication object  
for a ready mode send operation.  
<P> 
    
      
      
      
      
     MPI_RECV_INIT(buf, count, datatype, source, tag,  
comm, request)  
     
<BR> 
[  OUT   buf] initial address of receive buffer (choice)  
 
<BR> 
[  IN   count] number of elements received (integer)  
 
<BR> 
[  IN   datatype] type of each element (handle)  
 
<BR> 
[  IN   source] rank of source or MPI_ANY_SOURCE (integer)  
 
<BR> 
[  IN   tag] message tag or MPI_ANY_TAG (integer)  
 
<BR> 
[  IN   comm] communicator (handle)  
 
<BR> 
[  OUT   request] communication request (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Recv_init(void* buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_RECV_INIT(BUF, COUNT, DATATYPE, SOURCE, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  COUNT, DATATYPE, SOURCE, TAG, COMM, REQUEST, IERROR <BR></tt>  
<P> 
Creates a persistent communication request  
for a receive operation.  The argument  buf is marked as  OUT  
because the user gives permission to write on the receive buffer by passing the  
argument to  MPI_RECV_INIT.  
<P> 
A persistent communication request is inactive after it was created  
--- no active communication is attached to the request.  
<P> 
A communication (send or receive) that uses a persistent request  
is initiated by the function  MPI_START.  
<P> 
    
      
      
      
      
     MPI_START(request)  
     
<BR> 
[  INOUT   request] communication request (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Start(MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_START(REQUEST, IERROR)<BR> INTEGER  REQUEST, IERROR <BR></tt>  
<P> 
The argument,  request, is a handle returned  
by one of the previous five calls.   The associated request should be  
inactive.  The request becomes active once the call is made.  
<P> 
If the request is for a send with ready mode, then  
a matching receive should be posted before the call is made.  The  
communication buffer should not be accessed after the call, and  
until the operation completes.  
<P> 
The call is local, with similar semantics to the nonblocking  
communication operations described in  
section <a href="node44.html#Node44">Nonblocking communication
</a>.  That is,  
a call to  MPI_START with a  
request created by  MPI_SEND_INIT  
starts a  
communication in the same manner as a call to  MPI_ISEND;  
a call to  MPI_START with a  
request created by  MPI_BSEND_INIT  
starts a  
communication in the same manner as a call to  
 MPI_IBSEND;  and so on.  
<P> 
    
      
      
      
      
     MPI_STARTALL(count, array_of_requests)  
     
<BR> 
[  IN   count] list length (integer)  
 
<BR> 
[  INOUT   array_of_requests] array of requests (array of handle)  
<BR> 
  
<P> 
 <tt> int MPI_Startall(int count, MPI_Request *array_of_requests) <BR></tt>  
<P> 
 <tt> MPI_STARTALL(COUNT, ARRAY_OF_REQUESTS, IERROR)<BR> INTEGER  COUNT, ARRAY_OF_REQUESTS(*), IERROR <BR></tt>  
<P> 
Start all communications associated with requests in  
 array_of_requests.  A call to  
<BR>  
 MPI_STARTALL(count, array_of_requests) has the  
same effect as calls to  
 MPI_START  (&amp;array_of_requests[i]),executed for  i=0 ,..., count-1, in some arbitrary order.  
<P> 
A communication started with a call to  MPI_START or  
 MPI_STARTALL is  
completed by a call to  MPI_WAIT,  MPI_TEST, or  
one of the derived functions described in  
section <a href="node49.html#Node49">Multiple Completions
</a>.  The request becomes inactive after  
successful completion of such call.   The request is not deallocated  
and it can be activated anew by an  MPI_START or  
 MPI_STARTALL call.  
<P> 
A persistent request is deallocated by a call to  
 MPI_REQUEST_FREE  
(Section <a href="node47.html#Node47">Communication Completion
</a>).  
<P> 
The call to  MPI_REQUEST_FREE can occur at any point in the program  
after the persistent request was created.  However, the request will be  
deallocated only after it becomes inactive.  
Active receive requests should not be freed. Otherwise, it will not be  
possible to check that the receive has completed.  
It is preferable, in general, to free requests when they are inactive.  If this  
rule is followed, then the functions  
described in this section will be invoked  
in a sequence of the form,  
<P> 
  
<IMG SRC="img6.gif">
  
where <I>*</i> indicates zero or more repetitions.  
If the same communication object is used in several concurrent  
threads, it is the user's responsibility to coordinate calls so that the  
correct sequence is obeyed.  
<P> 
A send operation initiated with  MPI_START can be matched with  
any receive operation and, likewise, a receive operation initiated  
with  MPI_START can receive messages generated by any send  
operation.  
<P> 

<P>
<HR>
<A HREF="node50.html#Node50"><IMG SRC="previous.gif"></A><A HREF="node28.html#Node28"><IMG SRC="up.gif"></A><A HREF="node52.html#Node52"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node28.html#Node28"> Point-to-Point Communication</a>
<b>Next: </b><A HREF="node52.html#Node52"> Send-receive</a>
<b>Previous: </b><A HREF="node50.html#Node50"> Probe and Cancel</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
