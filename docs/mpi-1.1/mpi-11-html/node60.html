<HTML>
<!-- This file was generated by tohtml from pt2pt.tex -->
<TITLE>Correct use of addresses</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node60">3.12.6. Correct use of addresses</a></H2>
<A HREF="node59.html#Node59"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node61.html#Node61"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node61.html#Node61"> Examples</a>
<b>Previous: </b><A HREF="node59.html#Node59"> Use of general datatypes in communication</a>
<P>
  
<P> 
Successively declared variables in C or Fortran are not necessarily  
stored at contiguous locations.  Thus, care must be exercised  
that displacements do not cross from one variable  
to another.  Also, in machines with a segmented address space,  
addresses are not unique and address arithmetic has some peculiar  
properties.   Thus, the use of <b> addresses</b>,  
that is, displacements relative to the  
start address  MPI_BOTTOM, has to be restricted.  
<P> 
Variables belong  
to the same <b> sequential storage</b> if they belong to the same  
array,  
to the same  COMMON block in Fortran, or to the same structure in C.  
Valid addresses are defined recursively as follows:  
<P> 
<ol> 
 
1. The function  MPI_ADDRESS returns a valid address, when  
passed as argument a variable of the calling program.  
 
<BR> 
2. The  buf argument of a communication function evaluates to a  
valid address, when passed as argument a variable of the calling program.  
 
<BR> 
3. If  v is a valid address, and  i is an  
integer, then  v+i is a valid address, provided  v and  
 v+i are in the same sequential storage.  
 
<BR> 
4. If  v is a valid address then  MPI_BOTTOM + v is a valid  
address.  
</ol> 
A correct program uses only valid addresses to identify the  
locations of entries in communication buffers.  
Furthermore, if  u and  v are two valid addresses, then  
the (integer)  
difference  u - v can be computed only if both  u and  v  
are in the same sequential storage.  
No other arithmetic operations can be meaningfully executed on addresses.  
<P> 
The rules above impose no constraints on the use of derived  
datatypes, as long as they are used to define a communication buffer  
that is wholly contained within the same sequential storage.  
However, the construction of a communication buffer that contains  
variables that are not within the same sequential storage must obey  
certain restrictions.  Basically, a communication buffer with  
variables that are not within the same sequential storage can be used  
only by specifying in the communication call  buf =  
MPI_BOTTOM,  count = 1, and using a  datatype  
argument where all displacements are valid (absolute) addresses.  
<P> 
 
<BR> 
[]<em> Advice to users.</em>  
<P> 
It is not expected that  MPI implementations will be able to detect  
erroneous, ``out of bound'' displacements --- unless those overflow the  
user address space --- since the  MPI call may not know the extent of the  
arrays and records in the host program.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
[]<em> Advice  
 to implementors.</em>  
<P> 
There is no need to distinguish (absolute) addresses and (relative)  
displacements on a machine with contiguous address space:  
 MPI_BOTTOM is  
zero, and both addresses and displacements are integers.  On machines where the  
distinction is required, addresses are recognized as expressions that involve  
 MPI_BOTTOM.  
 (<em> End of advice to implementors.</em>) <BR> 
Note that in Fortran, Fortran INTEGERs may be too small to contain an  
address (e.g., 32 bit INTEGERs on a machine with 64bit pointers).   
Because of this, in Fortran, implementations may restrict the use of  
absolute addresses to only part of the process memory, and restrict the  
use of relative displacements to subranges of the process memory where they  
are constrained by the size of Fortran INTEGERs.  
<P> 

<P>
<HR>
<A HREF="node59.html#Node59"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node61.html#Node61"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node61.html#Node61"> Examples</a>
<b>Previous: </b><A HREF="node59.html#Node59"> Use of general datatypes in communication</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
