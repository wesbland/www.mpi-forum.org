<HTML>
<!-- This file was generated by tohtml from pt2pt.tex -->
<TITLE>Lower-bound and upper-bound markers</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node57">3.12.3. Lower-bound and upper-bound markers</a></H2>
<A HREF="node56.html#Node56"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node58.html#Node58"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node58.html#Node58"> Commit and free</a>
<b>Previous: </b><A HREF="node56.html#Node56"> Address and extent functions</a>
<P>
  
<P> 
It is often convenient to define explicitly the lower bound and upper  
bound of a type map, and override the definition given   
on page <a href="node57.html#Node57">Lower-bound and upper-bound markers
</a>.  
This allows one to define a datatype that  
has ``holes'' at its beginning or its end, or a datatype with  
entries that extend above the upper bound or below the lower bound.  
Examples of  
such usage are provided in Sec. <a href="node61.html#Node61">Examples
</a>.  
  
Also, the user may want to overide the alignment rules that are  
used to compute upper bounds and extents.  E.g., a C compiler may allow  
the user to overide default alignment rules for some of the  
structures within  
a program.  The user has to specify explicitly the bounds of the datatypes  
that match these structures.  
  
<P> 
To achieve this, we add  
two additional ``pseudo-datatypes,''  MPI_LB and  MPI_UB,  
that can be used, respectively, to mark the lower bound or the upper  
bound of a datatype.  These pseudo-datatypes occupy no space  
(<IMG SRC="img78.gif">
). They do not  
affect the size or count of a datatype, and do not affect the  
the content of a message created with this datatype.  However, they do  
affect the definition of the  
extent of a datatype and, therefore, affect the outcome of a replication of  
this datatype by a datatype constructor.  
<P> 
<BR><b> Example</b>   
  
Let  D = (-3, 0, 6);  T = (MPI_LB, MPI_INT, MPI_UB),  
and  B = (1, 1, 1).  Then a call to  
 MPI_TYPE_STRUCT(3, B, D, T, type1)  
creates a new datatype that has an  
extent of 9 (from -3 to 5, 5 included), and contains an integer at  
displacement 0.   This is the datatype defined by the sequence  
 {(lb, -3), (int, 0), (ub, 6)} .  
If this type is replicated twice by a call to  
 MPI_TYPE_CONTIGUOUS(2, type1, type2) then the newly created  
type can  
be described by the sequence  
 {(lb, -3), (int, 0), (int,9), (ub, 15)} .  
  
(An entry of type  
 ub  
can be deleted if there is another entry of type  ub with a higher  
displacement; an entry of type  lb can be deleted if there is another  
entry of type  lb with a lower displacement.)  
    
<P> 
In general, if  
<P><IMG SRC="img79.gif"><P>
then the <b> lower bound</b> of <I>Typemap</i> is defined to be  
<P><IMG SRC="img80.gif"><P>
Similarly,  
the <b> upper bound</b> of <I>Typemap</i> is defined to be  
  
<P><IMG SRC="img81.gif"><P>
Then  
  
<P><IMG SRC="img82.gif"><P>
  
If <I>type<SUB>i</SUB></i> requires alignment to a byte address that is a multiple of <I>k<SUB>i</SUB></i>,  
then <IMG SRC="img83.gif">
 is the least nonnegative increment needed to round  
<I>extent(Typemap)</i> to the next multiple of <IMG SRC="img84.gif">
.  
<P> 
The formal definitions given for the various datatype constructors  
apply now, with the amended definition of <b> extent</b>.  
<P> 
The two functions below can be used for finding the lower bound and  
the upper bound of a datatype.  
<P> 
    
      
      
      
      
     MPI_TYPE_LB( datatype, displacement)  
     
<BR> 
[  IN   datatype] datatype (handle)  
 
<BR> 
[  OUT   displacement] displacement of lower bound from origin,  
                             in bytes (integer)  
<BR> 
  
<P> 
  
 <tt> int MPI_Type_lb(MPI_Datatype datatype, MPI_Aint* displacement) <BR></tt>  
  
<P> 
 <tt> MPI_TYPE_LB( DATATYPE, DISPLACEMENT, IERROR)<BR> INTEGER DATATYPE, DISPLACEMENT, IERROR <BR></tt>  
<P> 
    
      
      
      
      
     MPI_TYPE_UB( datatype, displacement)  
     
<BR> 
[  IN   datatype] datatype (handle)  
 
<BR> 
[  OUT   displacement] displacement of upper bound from origin,  
                             in bytes (integer)  
<BR> 
  
<P> 
  
 <tt> int MPI_Type_ub(MPI_Datatype datatype, MPI_Aint* displacement) <BR></tt>  
  
<P> 
 <tt> MPI_TYPE_UB( DATATYPE, DISPLACEMENT, IERROR)<BR> INTEGER DATATYPE, DISPLACEMENT, IERROR <BR></tt>  
<P> 
  
<P> 
  
<P> 

<P>
<HR>
<A HREF="node56.html#Node56"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node58.html#Node58"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node58.html#Node58"> Commit and free</a>
<b>Previous: </b><A HREF="node56.html#Node56"> Address and extent functions</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
