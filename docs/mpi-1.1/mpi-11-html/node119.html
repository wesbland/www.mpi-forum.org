<HTML>
<!-- This file was generated by tohtml from context.tex -->
<TITLE>Functionality</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node119">5.7.1. Functionality</a></H2>
<A HREF="node118.html#Node118"><IMG SRC="previous.gif"></A><A HREF="node118.html#Node118"><IMG SRC="up.gif"></A><A HREF="node120.html#Node120"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node118.html#Node118"> Caching</a>
<b>Next: </b><A HREF="node120.html#Node120"> Attributes Example</a>
<b>Previous: </b><A HREF="node118.html#Node118"> Caching</a>
<P>
  
<P> 
Attributes are attached to communicators.  
Attributes are local to the process and specific to the communicator  
to which they are attached.  Attributes are not propagated by  MPI from one  
communicator to another except when the communicator is duplicated  
using  MPI_COMM_DUP (and even then the application must give  
specific permission through  
callback functions for the attribute to be copied).  
<P> 
  
 
<BR> 
[]<em> Advice to users.</em>  
<P> 
Attributes in C are of type  void *.  Typically, such an attribute  
will be a pointer to a structure that contains further information, or  
a handle to an  MPI object.  
In Fortran, attributes are of type  INTEGER.  Such attribute  
can be a handle to an  MPI object, or just an integer-valued  
attribute.  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
 
<BR> 
[]<em> Advice  
 to implementors.</em>  
<P> 
Attributes are scalar values, equal in size to, or larger than a C-language  
pointer.  Attributes can always hold an  MPI handle.  
 (<em> End of advice to implementors.</em>) <BR> 
The caching interface defined here represents that attributes be  
stored by  MPI opaquely within a communicator.  
Accessor functions include the following:  
<ul> 
 
<li>obtain a key value (used to identify an attribute); the user  
 specifies ``callback'' functions by which  MPI informs the application  
 when the communicator is destroyed or  
 copied.  
 
<li>store and retrieve the value of an attribute;  
</ul> 
<BR> 
 
<BR> 
[]<em> Advice  
 to implementors.</em>  
<P> 
Caching and callback functions are only called synchronously,  
in response to explicit application requests.  This avoid problems  
that result from repeated crossings between user and system space.  
(This synchronous calling rule is a general property of  MPI.)  
<P> 
The choice of key values is under control of  MPI.  This allows  MPI to optimize  
its implementation of attribute sets.  It also avoids conflict between  
independent modules caching information on the same communicators.  
<P> 
A much smaller interface, consisting of just a callback facility, would allow  
the entire caching facility to be implemented by portable code.  However, with  
the minimal callback interface, some form of table searching is implied by the  
need to handle arbitrary communicators.  In contrast, the more complete  
interface defined here permits rapid access to attributes through the use of  
pointers in communicators (to find the attribute table) and cleverly chosen  
key values (to retrieve individual attributes).  In light of the efficiency  
``hit'' inherent in the minimal interface, the more complete interface defined  
here is seen to be superior.  
 (<em> End of advice to implementors.</em>) <BR> 
  MPI provides the following services related to caching.  They are  
all process local.  
<P> 
    
      
      
      
      
     MPI_KEYVAL_CREATE(copy_fn, delete_fn, keyval, extra_state)  
     
<BR> 
[  IN   copy_fn] Copy callback function for  keyval  
 
<BR> 
[  IN   delete_fn] Delete callback function for  keyval  
 
<BR> 
[  OUT   keyval]   key value for future access (integer)  
 
<BR> 
[  IN   extra_state] Extra state for callback functions  
<BR> 
  
<P> 
 <tt> int MPI_Keyval_create(MPI_Copy_function *copy_fn, MPI_Delete_function *delete_fn, int *keyval, void* extra_state) <BR></tt>  
<P> 
 <tt> MPI_KEYVAL_CREATE(COPY_FN, DELETE_FN, KEYVAL, EXTRA_STATE, IERROR)<BR> EXTERNAL COPY_FN, DELETE_FN <BR>INTEGER KEYVAL, EXTRA_STATE, IERROR <BR></tt>  
<P> 
Generates a new attribute key.  Keys are locally unique in a process,  
and opaque to user, though they are explicitly stored in integers.  
Once allocated, the key value can be used to associate attributes  
and access them on any locally defined communicator.  
<P> 
The  copy_fn function is invoked when a communicator is  
duplicated by  MPI_COMM_DUP.   copy_fn should be  
of type  MPI_Copy_function, which is defined as follows:  
  
<BR> 
<pre><tt>typedef int MPI_Copy_function(MPI_Comm oldcomm, int keyval, 
                              void *extra_state, void *attribute_val_in, 
                              void *attribute_val_out, int *flag) 
</tt></pre> 
  
<P> 
A Fortran declaration for such a function is as follows:  
<P> 
  
 <tt> SUBROUTINE COPY_FUNCTION(OLDCOMM, KEYVAL, EXTRA_STATE,  
ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERR)<BR> INTEGER  
OLDCOMM, KEYVAL, EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, IERR <BR>LOGICAL FLAG <BR></tt>  
  
The copy callback function is invoked for each key value in  
 oldcomm in arbitrary order.  Each call  
to the copy callback is made with a key value and its corresponding attribute.  
If it returns  flag = 0, then the  
attribute is deleted in the duplicated communicator.  Otherwise  
( flag = 1),  
  
the new attribute value is set to the value  
returned in  
 attribute_val_out.  
  
The function returns  MPI_SUCCESS on  
success and an error code on failure (in which case  
 MPI_COMM_DUP will fail).  
<P> 
  
 copy_fn may be specified as  
 MPI_NULL_COPY_FN or  
 MPI_DUP_FN  
from either C or FORTRAN;  
 MPI_NULL_COPY_FN  
is a function that does nothing other than returning  flag = 0  
and  MPI_SUCCESS.  
 MPI_DUP_FN is a simple-minded  
copy function that sets  flag = 1,  
returns the value of  
 attribute_val_in in  attribute_val_out, and  
returns  MPI_SUCCESS.  
<P> 
<P> 
 
<BR> 
[]<em> Advice to users.</em>  
<P> 
Even though both formal arguments  attribute_val_in and  
 attribute_val_out are of type  void *, their usage differs.  
The C copy function is passed by  MPI in  attribute_val_in  
the <em> value</em> of the attribute, and in  
 attribute_val_out the <em> address</em> of the attribute, so as  
to allow the function to return the (new) attribute value.  
The use of type  void * for both is to avoid messy type casts.  
  
<P> 
A valid copy function is one that completely duplicates the  
information by making a full duplicate copy of the data structures  
implied by an attribute; another might just make another reference to  
that data structure, while using a reference-count mechanism.  Other  
types of attributes might not copy at all (they might be specific to  
 oldcomm only).  
 (<em> End of advice to users.</em>) <BR> 
  
 
<BR> 
[]<em> Advice  
 to implementors.</em>  
<P> 
A C interface should be assumed for copy and delete functions  
associated with key values created in C; a Fortran calling interface  
should be assumed for key values created in Fortran.  
 (<em> End of advice to implementors.</em>) <BR> 
  
<P> 
Analogous to  copy_fn is a callback deletion function, defined  
as follows.  The  delete_fn function is invoked when a communicator is  
deleted by  MPI_COMM_FREE or when a call is made explicitly  
to  MPI_ATTR_DELETE.   delete_fn should be  
of type  MPI_Delete_function, which is defined as follows:  
<P> 
  
<BR> 
<pre><tt>typedef int MPI_Delete_function(MPI_Comm comm, int keyval, 
    void *attribute_val, void *extra_state); 
</tt></pre> 
A Fortran declaration for such a function is as follows:  
<P> 
 <tt> SUBROUTINE DELETE_FUNCTION(COMM, KEYVAL, ATTRIBUTE_VAL, EXTRA_STATE, IERR)<BR> INTEGER COMM, KEYVAL, ATTRIBUTE_VAL, EXTRA_STATE, IERR <BR></tt>  
  
<P> 
This function is called by  MPI_COMM_FREE,  
 MPI_ATTR_DELETE,  
  
and  MPI_ATTR_PUT  
  
to do whatever is needed to remove an attribute.  
  
The function returns  MPI_SUCCESS on  
success and an error code on failure (in which case  
 MPI_COMM_FREE will fail).  
<P> 
 delete_fn may be specified as  
 MPI_NULL_DELETE_FN from either C or FORTRAN;  
 MPI_NULL_DELETE_FN is a function that does nothing, other  
than returning  MPI_SUCCESS.  
  
<P> 
The special key value  MPI_KEYVAL_INVALID is never returned  
by  MPI_KEYVAL_CREATE.  Therefore, it can be used for  
static initialization of key values.  
<P> 
    
      
      
      
      
     MPI_KEYVAL_FREE(keyval)  
     
<BR> 
[  INOUT   keyval]  Frees the integer key value (integer)  
<BR> 
  
<P> 
 <tt> int MPI_Keyval_free(int *keyval) <BR></tt>  
<P> 
 <tt> MPI_KEYVAL_FREE(KEYVAL, IERROR)<BR> INTEGER KEYVAL, IERROR <BR></tt>  
<P> 
Frees an extant attribute key.  
This function sets the value of  keyval to  
<BR> MPI_KEYVAL_INVALID.  
Note that it is not erroneous to free an attribute key  
that is in use, because the actual free does not transpire until after all  
references (in other communicators on the process) to the key have been freed.  
These references need to be explictly freed by the program, either via calls  
to  MPI_ATTR_DELETE that free one attribute instance, or by calls  
to  MPI_COMM_FREE that free all attribute instances associated with  
the freed communicator.  
<P> 
  
  
<P> 
    
      
      
      
      
     MPI_ATTR_PUT(comm, keyval, attribute_val)  
     
<BR> 
[  IN   comm] communicator to which attribute will be attached (handle)  
 
<BR> 
[  IN   keyval]  key value, as returned by <BR> MPI_KEYVAL_CREATE (integer)  
 
<BR> 
[  IN   attribute_val] attribute value  
<BR> 
  
<P> 
 <tt> int MPI_Attr_put(MPI_Comm comm, int keyval, void* attribute_val) <BR></tt>  
<P> 
 <tt> MPI_ATTR_PUT(COMM, KEYVAL, ATTRIBUTE_VAL, IERROR)<BR> INTEGER COMM, KEYVAL, ATTRIBUTE_VAL, IERROR <BR></tt>  
<P> 
This function stores the stipulated attribute value  attribute_val  
for subsequent retrieval by  MPI_ATTR_GET.  
If the value is already present, then the outcome  
is as if  MPI_ATTR_DELETEwas first called to delete the previous  
value (and the callback function  delete_fn was executed), and a new  
value was next stored.  The call is erroneous if there is no key with value  
 keyval; in particular  
 MPI_KEYVAL_INVALID is an erroneous key value.  
  
The call will fail if the  delete_fn function returned an error code  
other than  MPI_SUCCESS.  
  
<P> 
    
      
      
      
      
     MPI_ATTR_GET(comm, keyval, attribute_val, flag)  
     
<BR> 
[  IN   comm] communicator to which attribute is attached (handle)  
 
<BR> 
[  IN   keyval] key value (integer)  
 
<BR> 
[  OUT   attribute_val] attribute value, unless  flag = false  
 
<BR> 
[  OUT   flag] <tt> true</tt> if an attribute value was extracted; <tt> false</tt> if no attribute is associated with the key  
<BR> 
  
<P> 
  
 <tt> int MPI_Attr_get(MPI_Comm comm, int keyval, void *attribute_val, int *flag) <BR></tt>  
  
<P> 
 <tt> MPI_ATTR_GET(COMM, KEYVAL, ATTRIBUTE_VAL, FLAG, IERROR)<BR> INTEGER COMM, KEYVAL, ATTRIBUTE_VAL, IERROR <BR>LOGICAL FLAG <BR></tt>  
<P> 
Retrieves attribute value by key.  
The call is erroneous if there is no key with value  
 keyval.  On the other hand, the call is correct if the key value  
exists, but no attribute is attached on <tt> comm</tt> for that key; in such case,  
the call returns <tt> flag = false</tt>.  In particular  
 MPI_KEYVAL_INVALID is an erroneous key value.  
<P> 
  
 
<BR> 
[]<em> Advice to users.</em>  
<P> 
The call to  MPI_Attr_put passes in  attribute_val  
the <em> value</em> of the attribute; the call to  MPI_Attr_get  
passes in  attribute_val the <em> address</em> of the  
the location where the attribute value is to be returned.  
Thus, if the attribute value itself is a pointer of type  
 void*, the the actual  attribute_val parameter to  
 MPI_Attr_put will be of type  void* and the actual  
 attribute_val parameter to  MPI_Attr_put will be  
of type  void**.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
[]<em> Rationale.</em>  
<P> 
The use of a formal parameter  attribute_val or type  
 void* (rather than  void**) avoids the messy type  
casting that would be needed if the attribute value is declared with a  
type other than  void*.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
    
      
      
      
      
     MPI_ATTR_DELETE(comm, keyval)  
     
<BR> 
[  IN   comm] communicator to which attribute is attached (handle)  
 
<BR> 
[  IN   keyval] The key value of the deleted attribute (integer)  
<BR> 
  
<P> 
 <tt> int MPI_Attr_delete(MPI_Comm comm, int keyval) <BR></tt>  
<P> 
 <tt> MPI_ATTR_DELETE(COMM, KEYVAL, IERROR)<BR> INTEGER COMM, KEYVAL, IERROR <BR></tt>  
<P> 
Delete attribute from cache by key.  This function invokes the  
attribute delete function  delete_fn  
specified when the  keyval was created.  
  
The call will fail if the  delete_fn function returns an  
error code other than  MPI_SUCCESS.  
  
<P> 
Whenever a communicator is replicated using the function  
 MPI_COMM_DUP, all call-back copy functions for attributes  
that are currently set are invoked (in arbitrary order).  
Whenever a communicator is deleted using the function  
 MPI_COMM_FREE all callback delete functions for attributes  
that are currently set are invoked.  
<P> 

<P>
<HR>
<A HREF="node118.html#Node118"><IMG SRC="previous.gif"></A><A HREF="node118.html#Node118"><IMG SRC="up.gif"></A><A HREF="node120.html#Node120"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node118.html#Node118"> Caching</a>
<b>Next: </b><A HREF="node120.html#Node120"> Attributes Example</a>
<b>Previous: </b><A HREF="node118.html#Node118"> Caching</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
