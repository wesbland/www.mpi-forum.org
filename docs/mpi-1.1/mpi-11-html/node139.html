<HTML>
<!-- This file was generated by tohtml from topol.tex -->
<TITLE>Low-level topology functions</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node139">6.5.7. Low-level topology functions</a></H2>
<A HREF="node138.html#Node138"><IMG SRC="previous.gif"></A><A HREF="node132.html#Node132"><IMG SRC="up.gif"></A><A HREF="node140.html#Node140"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node132.html#Node132"> Topology Constructors</a>
<b>Next: </b><A HREF="node140.html#Node140"> An Application Example</a>
<b>Previous: </b><A HREF="node138.html#Node138"> Partitioning of Cartesian structures</a>
<P>
  
The two additional functions introduced in this section can be used to  
implement all other topology functions. In general they will not be  
called by the user directly, unless he or she is creating additional  
virtual topology capability other than that provided by  MPI.  
<P> 
    
      
      
      
      
     MPI_CART_MAP(comm, ndims, dims, periods, newrank)  
     
<BR> 
[  IN    comm]  input communicator (handle)  
 
<BR> 
[  IN    ndims]  number of dimensions of cartesian structure (integer)  
 
<BR> 
[  IN    dims]  integer array of size <tt> ndims</tt> specifying the number of processes in each coordinate direction   
 
<BR> 
[  IN     periods]  logical array of size <tt> ndims</tt> specifying the periodicity specification in each coordinate direction  
 
<BR> 
[  OUT    newrank]  reordered rank of the calling process;  MPI_UNDEFINED if calling process does not belong to grid (integer)  
<BR> 
  
<P> 
 <tt> int MPI_Cart_map(MPI_Comm comm, int ndims, int *dims, int *periods, int *newrank) <BR></tt>  
<P> 
 <tt> MPI_CART_MAP(COMM, NDIMS, DIMS, PERIODS, NEWRANK, IERROR)<BR> INTEGER COMM, NDIMS, DIMS(*), NEWRANK, IERROR <BR>LOGICAL PERIODS(*) <BR></tt>  
<P> 
 MPI_CART_MAP  
computes an ``optimal'' placement for the calling process on the  
physical machine.  A possible implementation of this function is to always  
return the rank of the calling process, that is, not to perform any reordering.  
<P> 
 
<BR> 
[]<em> Advice  
 to implementors.</em>  
<P> 
The function  MPI_CART_CREATE(comm, ndims, dims,  
periods, reorder, comm_cart), with <tt> reorder = true</tt> can be implemented by  
calling  
 MPI_CART_MAP(comm, ndims, dims, periods, newrank), then calling  
<BR>  
 MPI_COMM_SPLIT(comm, color, key, comm_cart), with  
<tt> color = 0</tt> if <tt> newrank <IMG SRC="img190.gif">
  
<BR>  
MPI_UNDEFINED</tt>, <tt> color = MPI_UNDEFINED</tt> otherwise,  
and <tt> key = newrank</tt>.  
<P> 
The function  MPI_CART_SUB(comm, remain_dims, comm_new) can be  
implemented by a call to  MPI_COMM_SPLIT(comm, color, key, comm_new),  
using a single number encoding of the lost dimensions as <tt> color</tt> and a  
single number encoding of the preserved dimensions as <tt> key</tt>.  
<P> 
All other cartesian topology functions can be implemented locally, using  
the topology information that is cached with the communicator.  
 (<em> End of advice to implementors.</em>) <BR> 
The corresponding new function for general graph structures is as follows.  
<P> 
    
      
      
      
      
     MPI_GRAPH_MAP(comm, nnodes, index, edges, newrank)  
     
<BR> 
[  IN    comm]  input communicator (handle)  
 
<BR> 
[  IN    nnodes]  number of graph nodes (integer)  
 
<BR> 
[  IN    index] integer array specifying the graph structure, see <BR> MPI_GRAPH_CREATE  
 
<BR> 
[  IN    edges] integer array specifying the graph structure  
 
<BR> 
[  OUT    newrank]  reordered rank of the calling process;  MPI_UNDEFINED if the calling process does not belong to graph (integer)  
<BR> 
  
<P> 
 <tt> int MPI_Graph_map(MPI_Comm comm, int nnodes, int *index, int *edges, int *newrank) <BR></tt>  
<P> 
 <tt> MPI_GRAPH_MAP(COMM, NNODES, INDEX, EDGES, NEWRANK, IERROR)<BR> INTEGER COMM, NNODES, INDEX(*), EDGES(*), NEWRANK, IERROR <BR></tt>  
<P> 
 
<BR> 
[]<em> Advice  
 to implementors.</em>  
<P> 
The function  MPI_GRAPH_CREATE(comm, nnodes, index, edges,  
reorder, comm_graph),  
with <tt> reorder = true</tt> can be implemented by calling  
 MPI_GRAPH_MAP(comm, nnodes, index, edges, newrank),  
then calling  
<BR>  
 MPI_COMM_SPLIT(comm, color, key, comm_graph), with <tt> color = 0</tt>  
if <tt> newrank <IMG SRC="img191.gif">
  
<BR>  
MPI_UNDEFINED</tt>, <tt> color = MPI_UNDEFINED</tt>  
otherwise, and <tt> key = newrank</tt>.  
<P> 
All other graph topology functions can be implemented locally, using the  
topology information that is cached with the communicator.  
 (<em> End of advice to implementors.</em>) <BR> 
  

<P>
<HR>
<A HREF="node138.html#Node138"><IMG SRC="previous.gif"></A><A HREF="node132.html#Node132"><IMG SRC="up.gif"></A><A HREF="node140.html#Node140"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node132.html#Node132"> Topology Constructors</a>
<b>Next: </b><A HREF="node140.html#Node140"> An Application Example</a>
<b>Previous: </b><A HREF="node138.html#Node138"> Partitioning of Cartesian structures</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
