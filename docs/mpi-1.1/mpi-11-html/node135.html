<HTML>
<!-- This file was generated by tohtml from topol.tex -->
<TITLE>General (Graph) Constructor</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node135">6.5.3. General (Graph) Constructor</a></H2>
<A HREF="node134.html#Node134"><IMG SRC="previous.gif"></A><A HREF="node132.html#Node132"><IMG SRC="up.gif"></A><A HREF="node136.html#Node136"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node132.html#Node132"> Topology Constructors</a>
<b>Next: </b><A HREF="node136.html#Node136"> Topology inquiry functions</a>
<b>Previous: </b><A HREF="node134.html#Node134"> Cartesian Convenience Function:  MPI_DIMS_CREATE</a>
<P>
    
      
      
      
      
     MPI_GRAPH_CREATE(comm_old, nnodes, index, edges, reorder, comm_graph)  
      
 
<BR> 
[  IN    comm_old]  input communicator (handle)  
  
 
<BR> 
[  IN    nnodes]  number of nodes in graph (integer)  
 
<BR> 
[  IN    index] array of integers describing node degrees (see below)  
 
<BR> 
[  IN    edges] array of integers describing graph edges (see below)  
 
<BR> 
[  IN    reorder]  ranking may be reordered ( true) or not ( false) (logical)  
 
<BR> 
[  OUT    comm_graph]  communicator with graph topology added (handle)  
<BR> 
  
<P> 
 <tt> int MPI_Graph_create(MPI_Comm comm_old, int nnodes, int *index, int *edges, int reorder, MPI_Comm *comm_graph) <BR></tt>  
<P> 
 <tt> MPI_GRAPH_CREATE(COMM_OLD, NNODES, INDEX, EDGES, REORDER, COMM_GRAPH, IERROR)<BR> INTEGER COMM_OLD, NNODES, INDEX(*), EDGES(*), COMM_GRAPH, IERROR <BR>LOGICAL REORDER <BR></tt>  
<P> 
 MPI_GRAPH_CREATE returns a handle to a new communicator to which the  
graph topology information is attached.  If  reorder = false then the  
rank of each process in the new group is identical to its rank in the old  
group.  Otherwise, the function may reorder the processes.  If the size,  
 nnodes, of the graph is smaller than the size of the group of  
 comm, then some processes are returned  MPI_COMM_NULL, in  
analogy to  MPI_CART_CREATE and  MPI_COMM_SPLIT.  The call  
is erroneous if it specifies a graph that is larger than the group size of the  
input communicator.  
<P> 
The three parameters  nnodes, index and  edges define the graph  
structure.  
 nnodes is the number of nodes of the graph.   The nodes are numbered  
from <tt> 0</tt> to <tt> nnodes-1</tt>.  
The <tt> i</tt>th entry of array  index stores the total number of  
neighbors of the first <tt> i</tt> graph nodes.   The lists of neighbors of  
nodes <tt> 0, 1, ..., nnodes-1</tt> are stored in consecutive locations in array  
 edges.  The array  edges is a flattened representation  
of the edge lists.  
The total number of entries in  index is  nnodes and  
the total number of entries in  edges is equal to the number of  
graph edges.  
<P> 
The definitions of the arguments <tt> nnodes</tt>, <tt> index</tt>, and  
<tt> edges</tt> are illustrated with the following simple example.  
<P> 
<BR><b> Example</b>   
  
<P> 
Assume there are four processes 0, 1, 2, 3 with the following  
adjacency matrix: <BR>  
  
<P><IMG SRC="img171.gif"><P>
  
<P> 
Then, the input arguments are: <BR>  
  
<P><IMG SRC="img172.gif"><P>
  
<P> 
Thus, in C, <tt> index[0]</tt> is the degree of node zero, and <tt> index[i] -  
index[i-1]</tt> is the degree of node <tt> i, i=1, ..., nnodes-1</tt>;  
the list of neighbors of node zero is stored in <tt> edges[j]</tt>, for  
<IMG SRC="img173.gif">
 and the list of neighbors of node <tt> i</tt>,  
<IMG SRC="img174.gif">
,  
is stored in <tt> edges[j]</tt>, <IMG SRC="img175.gif">
.  
<P> 
In Fortran, <tt> index(1)</tt> is the degree of node zero, and <tt> index(i+1) -  
index(i)</tt> is the degree of node <tt> i, i=1, ..., nnodes-1</tt>;  
the list of neighbors of node zero is stored in <tt> edges(j)</tt>, for  
<IMG SRC="img176.gif">
 and the list of neighbors of node  
<tt> i</tt>, <IMG SRC="img177.gif">
,  
is stored in <tt> edges(j)</tt>, <IMG SRC="img178.gif">
.  
<P> 
   
<P> 
<P> 
 
<BR> 
[]<em> Advice  
 to implementors.</em>  
<P> 
The following topology information is likely to be stored with a communicator:  
<ul> 
 
<li>Type of topology (cartesian/graph),  
 
<li>For a cartesian topology:  
   <ol> 
 
1. ndims (number of dimensions),  
    
<BR> 
2. dims (numbers of processes per coordinate direction),  
    
<BR> 
3. periods (periodicity information),  
    
<BR> 
4. own_position (own position in grid, could also be computed  
                          from rank and dims)  
   </ol> 
 
<li>For a graph topology:  
   <ol> 
 
1. index,  
    
<BR> 
2. edges,  
   </ol> 
which are the vectors defining the graph structure.  
</ul> 
<BR> 
For a graph structure the number of nodes is equal to the number of processes  
in the group. Therefore, the number of nodes does not have to be stored explicitly.  An  
additional zero entry at the start of array  index simplifies  
access to the topology information.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node134.html#Node134"><IMG SRC="previous.gif"></A><A HREF="node132.html#Node132"><IMG SRC="up.gif"></A><A HREF="node136.html#Node136"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node132.html#Node132"> Topology Constructors</a>
<b>Next: </b><A HREF="node136.html#Node136"> Topology inquiry functions</a>
<b>Previous: </b><A HREF="node134.html#Node134"> Cartesian Convenience Function:  MPI_DIMS_CREATE</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
