<HTML>
<!-- This file was generated by tohtml from pt2pt.tex -->
<TITLE>Model implementation of buffered mode</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node43">3.6.1. Model implementation of buffered mode</a></H2>
<A HREF="node42.html#Node42"><IMG SRC="previous.gif"></A><A HREF="node42.html#Node42"><IMG SRC="up.gif"></A><A HREF="node44.html#Node44"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node42.html#Node42"> Buffer allocation and usage</a>
<b>Next: </b><A HREF="node44.html#Node44"> Nonblocking communication</a>
<b>Previous: </b><A HREF="node42.html#Node42"> Buffer allocation and usage</a>
<P>
  
<P> 
The model implementation uses the packing and unpacking functions described in  
Section <a href="node62.html#Node62">Pack and unpack
</a> and the nonblocking communication functions  
described in Section <a href="node44.html#Node44">Nonblocking communication
</a>.  
<P> 
We assume that a circular queue  
of pending message entries (PME) is maintained.  Each  
entry contains a communication request handle  
that identifies a pending nonblocking  
send, a pointer to the next entry and the packed message data.  The  
entries are stored in successive locations in the buffer.  Free space is  
available between the queue tail and the queue head.  
<P> 
A buffered send call results in the execution of the following code.  
<ul> 
 
<li>Traverse sequentially the PME queue from head towards the tail,  
deleting all entries for  
communications that have completed, up to the first entry with an uncompleted  
request; update queue head to point to that entry.  
 
<li>Compute the number,  n, of bytes needed to store an entry for the new message.  
  
An upper bound on  n can be computed  
as follows: A call to the function <BR>  
 MPI_PACK_SIZE(count, datatype,  
comm, size), with the <tt> count, datatype</tt> and <tt> comm</tt> arguments  
used in the  
 MPI_BSEND call, returns an upper bound on the amount of  
space needed to buffer the message data (see Section <a href="node62.html#Node62">Pack and unpack
</a>).  
The MPI constant  
 MPI_BSEND_OVERHEAD provides an upper bound on the  
additional space consumed by the entry (e.g., for pointers or envelope  
information).  
  
 
<li>Find the next contiguous empty space of  n bytes in  
buffer (space following queue tail, or space at start of buffer if  
queue tail is  
too close to end of buffer).  If space is not found then raise buffer  
overflow error.  
 
<li>Append to end of PME queue in contiguous space the new entry  
that contains request  
handle, next pointer and packed message data;  MPI_PACK is used to  
pack data.  
 
<li>Post nonblocking send (standard mode) for packed data.  
 
<li>Return  
</ul> 
<BR> 

<P>
<HR>
<A HREF="node42.html#Node42"><IMG SRC="previous.gif"></A><A HREF="node42.html#Node42"><IMG SRC="up.gif"></A><A HREF="node44.html#Node44"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node42.html#Node42"> Buffer allocation and usage</a>
<b>Next: </b><A HREF="node44.html#Node44"> Nonblocking communication</a>
<b>Previous: </b><A HREF="node42.html#Node42"> Buffer allocation and usage</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
