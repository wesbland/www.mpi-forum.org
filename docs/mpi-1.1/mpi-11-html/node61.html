<HTML>
<!-- This file was generated by tohtml from pt2pt.tex -->
<TITLE>Examples</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node61">3.12.7. Examples</a></H2>
<A HREF="node60.html#Node60"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node62.html#Node62"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node62.html#Node62"> Pack and unpack</a>
<b>Previous: </b><A HREF="node60.html#Node60"> Correct use of addresses</a>
<P>
  
<P> 
The following examples illustrate the use of derived datatypes.  
<P> 
<BR><b> Example</b>   
  
Send and receive a section of a 3D array.  
<P> 
<BR> 
<pre><tt>REAL a(100,100,100), e(9,9,9) 
      INTEGER oneslice, twoslice, threeslice, sizeofreal, myrank, ierr 
      INTEGER status(MPI_STATUS_SIZE) 
<P> 
C      extract the section a(1:17:2, 3:11, 2:10) 
C      and store it in e(:,:,:). 
<P> 
CALL MPI_COMM_RANK(MPI_COMM_WORLD, myrank) 
<P> 
CALL MPI_TYPE_EXTENT( MPI_REAL, sizeofreal, ierr) 
<P> 
C     create datatype for a 1D section 
      CALL MPI_TYPE_VECTOR( 9, 1, 2, MPI_REAL, oneslice, ierr) 
<P> 
C     create datatype for a 2D section 
      CALL MPI_TYPE_HVECTOR(9, 1, 100*sizeofreal, oneslice, twoslice, ierr) 
<P> 
C     create datatype for the entire section 
      CALL MPI_TYPE_HVECTOR( 9, 1, 100*100*sizeofreal, twoslice, 1, 
                             threeslice, ierr) 
<P> 
CALL MPI_TYPE_COMMIT( threeslice, ierr) 
      CALL MPI_SENDRECV(a(1,3,2), 1, threeslice, myrank, 0, e, 9*9*9, 
                        MPI_REAL, myrank, 0, MPI_COMM_WORLD, status, ierr) 
</tt></pre> 
   
<P> 
<BR><b> Example</b>   
  
Copy the (strictly) lower triangular part of a matrix.  
<P> 
<BR> 
<pre><tt>REAL a(100,100), b(100,100) 
      INTEGER  disp(100), blocklen(100), ltype, myrank, ierr 
      INTEGER status(MPI_STATUS_SIZE) 
<P> 
C     copy lower triangular part of array a 
C     onto lower triangular part of array b 
<P> 
CALL MPI_COMM_RANK(MPI_COMM_WORLD, myrank) 
<P> 
C     compute start and size of each column 
      DO i=1, 100 
        disp(i) = 100*(i-1) + i 
        block(i) = 100-i 
      END DO 
<P> 
C     create datatype for lower triangular part 
      CALL MPI_TYPE_INDEXED( 100, block, disp, MPI_REAL, ltype, ierr) 
<P> 
CALL MPI_TYPE_COMMIT(ltype, ierr) 
      CALL MPI_SENDRECV( a, 1, ltype, myrank, 0, b, 1, 
                    ltype, myrank, 0, MPI_COMM_WORLD, status, ierr) 
</tt></pre> 
   
<P> 
<BR><b> Example</b>   
  
Transpose a matrix.  
<P> 
<BR> 
<pre><tt>REAL a(100,100), b(100,100) 
      INTEGER row, xpose, sizeofreal, myrank, ierr 
      INTEGER status(MPI_STATUS_SIZE) 
<P> 
C     transpose matrix a onto b 
<P> 
CALL MPI_COMM_RANK(MPI_COMM_WORLD, myrank) 
<P> 
CALL MPI_TYPE_EXTENT( MPI_REAL, sizeofreal, ierr) 
<P> 
C     create datatype for one row 
      CALL MPI_TYPE_VECTOR( 100, 1, 100, MPI_REAL, row, ierr) 
<P> 
C     create datatype for matrix in row-major order 
      CALL MPI_TYPE_HVECTOR( 100, 1, sizeofreal, row, xpose, ierr) 
<P> 
CALL MPI_TYPE_COMMIT( xpose, ierr) 
<P> 
C     send matrix in row-major order and receive in column major order 
      CALL MPI_SENDRECV( a, 1, xpose, myrank, 0, b, 100*100, 
                MPI_REAL, myrank, 0, MPI_COMM_WORLD, status, ierr) 
</tt></pre> 
   
<P> 
<BR><b> Example</b>   
  
Another approach to the transpose problem:  
<BR> 
<pre><tt>REAL a(100,100), b(100,100) 
      INTEGER  disp(2), blocklen(2), type(2), row, row1, sizeofreal 
      INTEGER  myrank, ierr 
      INTEGER status(MPI_STATUS_SIZE) 
<P> 
CALL MPI_COMM_RANK(MPI_COMM_WORLD, myrank) 
<P> 
C     transpose matrix a onto b 
<P> 
CALL MPI_TYPE_EXTENT( MPI_REAL, sizeofreal, ierr) 
<P> 
C     create datatype for one row 
      CALL MPI_TYPE_VECTOR( 100, 1, 100, MPI_REAL, row, ierr) 
<P> 
C     create datatype for one row, with the extent of one real number 
      disp(1) = 0 
      disp(2) = sizeofreal 
      type(1)  = row 
      type(2)  = MPI_UB 
      blocklen(1)  = 1 
      blocklen(2)  = 1 
      CALL MPI_TYPE_STRUCT( 2, blocklen, disp, type, row1, ierr) 
<P> 
CALL MPI_TYPE_COMMIT( row1, ierr) 
<P> 
C     send 100 rows and receive in column major order 
      CALL MPI_SENDRECV( a, 100, row1, myrank, 0, b, 100*100, 
                MPI_REAL, myrank, 0, MPI_COMM_WORLD, status, ierr) 
</tt></pre> 
   
<P> 
<BR><b> Example</b>   
  
We manipulate an array of structures.  
<P> 
<BR> 
<pre><tt>struct Partstruct 
   { 
   int    class;  /* particle class */ 
   double d[6];   /* particle coordinates */ 
   char   b[7];   /* some additional information */ 
   }; 
<P> 
struct Partstruct    particle[1000]; 
<P> 
int                  i, dest, rank; 
MPI_Comm     comm; 
<P> 
/* build datatype describing structure */ 
<P> 
MPI_Datatype Particletype; 
MPI_Datatype type[3] = {MPI_INT, MPI_DOUBLE, MPI_CHAR}; 
int          blocklen[3] = {1, 6, 7}; 
MPI_Aint     disp[3]; 
int          base; 
<P> 
/* compute displacements of structure components */ 
<P> 
MPI_Address( particle, disp); 
MPI_Address( particle[0].d, disp+1); 
MPI_Address( particle[0].b, disp+2); 
base = disp[0]; 
for (i=0; i &lt;3; i++) disp[i] -= base; 
<P> 
MPI_Type_struct( 3, blocklen, disp, type, &amp;Particletype); 
<P> 
/* If compiler does padding in mysterious ways, 
   the following may be safer */ 
<P> 
MPI_Datatype type1[4] = {MPI_INT, MPI_DOUBLE, MPI_CHAR, MPI_UB}; 
int          blocklen1[4] = {1, 6, 7, 1}; 
MPI_Aint     disp1[4]; 
<P> 
/* compute displacements of structure components */ 
<P> 
MPI_Address( particle, disp1); 
MPI_Address( particle[0].d, disp1+1); 
MPI_Address( particle[0].b, disp1+2); 
MPI_Address( particle+1, disp1+3); 
base = disp1[0]; 
for (i=0; i &lt;4; i++) disp1[i] -= base; 
<P> 
/* build datatype describing structure */ 
<P> 
MPI_Type_struct( 4, blocklen1, disp1, type1, &amp;Particletype); 
<P> 
/* 4.1: 
        send the entire array */ 
<P> 
MPI_Type_commit( &amp;Particletype); 
MPI_Send( particle, 1000, Particletype, dest, tag, comm); 
<P> 
/* 4.2: 
        send only the entries of class zero particles, 
        preceded by the number of such entries */ 
<P> 
MPI_Datatype Zparticles;   /* datatype describing all particles 
                              with class zero (needs to be recomputed 
                              if classes change) */ 
MPI_Datatype Ztype; 
<P> 
MPI_Aint     zdisp[1000]; 
int zblock[1000], j, k; 
int zzblock[2] = {1,1}; 
MPI_Aint     zzdisp[2]; 
MPI_Datatype zztype[2]; 
<P> 
/* compute displacements of class zero particles */ 
j = 0; 
for(i=0; i &lt; 1000; i++) 
  if (particle[i].class==0) 
     { 
     zdisp[j] = i; 
     zblock[j] = 1; 
     j++; 
     } 
<P> 
/* create datatype for class zero particles  */ 
MPI_Type_indexed( j, zblock, zdisp, Particletype, &amp;Zparticles); 
<P> 
/* prepend particle count */ 
MPI_Address(&amp;j, zzdisp); 
MPI_Address(particle, zzdisp+1); 
zztype[0] = MPI_INT; 
zztype[1] = Zparticles; 
MPI_Type_struct(2, zzblock, zzdisp, zztype, &amp;Ztype); 
<P> 
MPI_Type_commit( &amp;Ztype); 
MPI_Send( MPI_BOTTOM, 1, Ztype, dest, tag, comm); 
<P> 
/* A probably more efficient way of defining Zparticles */ 
<P> 
/* consecutive particles with index zero are handled as one block */ 
j=0; 
for (i=0; i &lt; 1000; i++) 
  if (particle[i].index==0) 
    { 
    for (k=i+1; (k &lt; 1000)&amp;&amp;(particle[k].index == 0) ; k++); 
    zdisp[j] = i; 
    zblock[j] = k-i; 
    j++; 
    i = k; 
    } 
MPI_Type_indexed( j, zblock, zdisp, Particletype, &amp;Zparticles); 
<P> 
/* 4.3: 
          send the first two coordinates of all entries */ 
<P> 
MPI_Datatype Allpairs;      /* datatype for all pairs of coordinates */ 
<P> 
MPI_Aint sizeofentry; 
<P> 
MPI_Type_extent( Particletype, &amp;sizeofentry); 
<P> 
/* sizeofentry can also be computed by subtracting the address 
        of particle[0] from the address of particle[1] */ 
<P> 
MPI_Type_hvector( 1000, 2, sizeofentry, MPI_DOUBLE, &amp;Allpairs); 
MPI_Type_commit( &amp;Allpairs); 
MPI_Send( particle[0].d, 1, Allpairs, dest, tag, comm); 
<P> 
/* an alternative solution to 4.3 */ 
<P> 
MPI_Datatype Onepair;   /* datatype for one pair of coordinates, with 
                          the extent of one particle entry */ 
MPI_Aint disp2[3]; 
MPI_Datatype type2[3] = {MPI_LB, MPI_DOUBLE, MPI_UB}; 
int blocklen2[3] = {1, 2, 1}; 
<P> 
MPI_Address( particle, disp2); 
MPI_Address( particle[0].d, disp2+1); 
MPI_Address( particle+1, disp2+2); 
base = disp2[0]; 
for (i=0; i&lt;2; i++) disp2[i] -= base; 
<P> 
MPI_Type_struct( 3, blocklen2, disp2, type2, &amp;Onepair); 
MPI_Type_commit( &amp;Onepair); 
MPI_Send( particle[0].d, 1000, Onepair, dest, tag, comm); 
<P> 
</tt></pre> 
   
<P> 
<BR><b> Example</b>   
  
The same manipulations as in the previous example, but use absolute  
addresses in datatypes.  
<P> 
<BR> 
<pre><tt>struct Partstruct 
   { 
   int class; 
   double d[6]; 
   char b[7]; 
   }; 
<P> 
struct Partstruct particle[1000]; 
<P> 
/* build datatype describing first array entry */ 
<P> 
MPI_Datatype Particletype; 
MPI_Datatype type[3] = {MPI_INT, MPI_DOUBLE, MPI_CHAR}; 
int          block[3] = {1, 6, 7}; 
MPI_Aint     disp[3]; 
<P> 
MPI_Address( particle, disp); 
MPI_Address( particle[0].d, disp+1); 
MPI_Address( particle[0].b, disp+2); 
MPI_Type_struct( 3, block, disp, type, &amp;Particletype); 
<P> 
/* Particletype describes first array entry -- using absolute 
   addresses */ 
<P> 
/* 5.1: 
            send the entire array */ 
<P> 
MPI_Type_commit( &amp;Particletype); 
MPI_Send( MPI_BOTTOM, 1000, Particletype, dest, tag, comm); 
<P> 
/* 5.2: 
         send the entries of class zero, 
         preceded by the number of such entries */ 
<P> 
MPI_Datatype Zparticles, Ztype; 
<P> 
MPI_Aint zdisp[1000] 
int zblock[1000], i, j, k; 
int zzblock[2] = {1,1}; 
MPI_Datatype zztype[2]; 
MPI_Aint     zzdisp[2]; 
<P> 
j=0; 
for (i=0; i &lt; 1000; i++) 
  if (particle[i].index==0) 
    { 
    for (k=i+1; (k &lt; 1000)&amp;&amp;(particle[k].index = 0) ; k++); 
    zdisp[j] = i; 
    zblock[j] = k-i; 
    j++; 
    i = k; 
    } 
MPI_Type_indexed( j, zblock, zdisp, Particletype, &amp;Zparticles); 
/* Zparticles describe particles with class zero, using 
   their absolute addresses*/ 
<P> 
/* prepend particle count */ 
MPI_Address(&amp;j, zzdisp); 
zzdisp[1] = MPI_BOTTOM; 
zztype[0] = MPI_INT; 
zztype[1] = Zparticles; 
MPI_Type_struct(2, zzblock, zzdisp, zztype, &amp;Ztype); 
<P> 
MPI_Type_commit( &amp;Ztype); 
MPI_Send( MPI_BOTTOM, 1, Ztype, dest, tag, comm); 
<P> 
</tt></pre> 
   
<P> 
<BR><b> Example</b>   
  
Handling of unions.  
<P> 
<BR> 
<pre><tt>union { 
   int     ival; 
   float   fval; 
      } u[1000] 
<P> 
int     utype; 
<P> 
/* All entries of u have identical type; variable 
   utype keeps track of their current type */ 
<P> 
MPI_Datatype   type[2]; 
int            blocklen[2] = {1,1}; 
MPI_Aint       disp[2]; 
MPI_Datatype   mpi_utype[2]; 
MPI_Aint       i,j; 
<P> 
/* compute an MPI datatype for each possible union type; 
   assume values are left-aligned in union storage. */ 
<P> 
MPI_Address( u, &amp;i); 
MPI_Address( u+1, &amp;j); 
disp[0] = 0; disp[1] = j-i; 
type[1] = MPI_UB; 
<P> 
type[0] = MPI_INT; 
MPI_Type_struct(2, blocklen, disp, type, &amp;mpi_utype[0]); 
<P> 
type[0] = MPI_FLOAT; 
MPI_Type_struct(2, blocklen, disp, type, &amp;mpi_utype[1]); 
<P> 
for(i=0; i&lt;2; i++) MPI_Type_commit(&amp;mpi_utype[i]); 
<P> 
/* actual communication */ 
<P> 
MPI_Send(u, 1000, mpi_utype[utype], dest, tag, comm); 
</tt></pre> 
   
<P> 

<P>
<HR>
<A HREF="node60.html#Node60"><IMG SRC="previous.gif"></A><A HREF="node54.html#Node54"><IMG SRC="up.gif"></A><A HREF="node62.html#Node62"><IMG SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node54.html#Node54"> Derived datatypes</a>
<b>Next: </b><A HREF="node62.html#Node62"> Pack and unpack</a>
<b>Previous: </b><A HREF="node60.html#Node60"> Correct use of addresses</a>
<P>
<HR>
Return to <A HREF="node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-20-html/node306.html">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-1.1 of June 12, 1995<BR>
HTML Generated on August 6, 1997
</FONT>
</BODY>
</HTML>
