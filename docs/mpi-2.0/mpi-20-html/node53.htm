<HTML>
<!-- This file was generated by tohtml from misc-2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>The  Info Object</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node53">4.10. The  Info Object</a></H1>
<A HREF="node52.htm#Node52"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node41.htm#Node41"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node54.htm#Node54"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node41.htm#Node41"> Miscellany</a>
<b>Next: </b><A HREF="node54.htm#Node54"> Memory Allocation</a>
<b>Previous: </b><A HREF="node52.htm#Node52"> Determining Whether  MPI Has Finished</a>
<P>
  
<P> 
Many of the routines in  MPI-2 take an argument  
 info.  info is an opaque object with a handle of type  
 MPI_Info in C,  MPI::Info in C++, and <tt> INTEGER</tt> in Fortran. It consists of  
( key, value) pairs (both  key and  
 value are strings). A key may have only one  
value.  MPI reserves several keys and requires that if an  
implementation uses a reserved key, it must provide the specified  
functionality.  An implementation is not required to support these  
keys and may support any others not reserved by  MPI.  
<P> 
If a function does not recognize a key, it will ignore it, unless  
otherwise specified. If an implementation recognizes a key but does  
not recognize the format of the corresponding value, the result is  
undefined.  
<P> 
Keys have an implementation-defined maximum length of  
  
 MPI_MAX_INFO_KEY, which is at least 32 and at most 255.   
  
Values have an implementation-defined maximum length of  
  
 MPI_MAX_INFO_VAL.    
  
  
In Fortran, leading and trailing spaces are stripped from  
both.  Returned values will never be larger than these maximum  
lengths.  
  
Both  key and  value are case sensitive.  
  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
Keys have a maximum length because the set of known keys will always  
be finite and known to the implementation and because there is no  
reason for keys to be complex.  The small maximum size allows  
  
applications to declare keys of size  MPI_MAX_INFO_KEY.  
  
The limitation on value sizes is so that an implementation is not  
forced to deal with arbitrarily long  
strings.  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
  
 MPI_MAX_INFO_VAL might be very large, so it  
  
might not be wise to declare a string of that size.  
 (<em> End of advice to users.</em>) <BR> 
When it is an argument to a non-blocking routine,  info  
is parsed before that routine returns, so that it may  
be modified or freed immediately after return.  
<P> 
  
<P> 
When the descriptions refer to a key or value as being a boolean, an  
integer, or a list, they mean the string representation of these  
types.  An implementation may define its own rules for how info value  
strings are converted to other types, but to ensure portability, every  
implementation must support the following representations.  Legal  
values for a boolean must include the strings ``true'' and ``false''  
(all lowercase).  For integers, legal values must include string  
representations of decimal values of integers that are within the  
range of a standard integer type in the program.  (However it is  
possible that not every legal integer is a legal value for a given  
key.)  On positive numbers, <I>+</I> signs are optional.  No space may  
appear between a <I>+</I> or <I>-</I> sign and the leading digit of a number.  For  
comma separated lists, the string must contain legal elements  
separated by commas.  Leading and trailing spaces are stripped  
automatically from the types of info values described above and for  
each element of a comma separated list.  These rules apply to all info  
values of these types.  Implementations are free to specify a  
different interpretation for values of other info keys.  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INFO_CREATE(info)</TD></TR>  
<TR><TD> OUT info</TD><TD>info object created (handle)</TD></TR>  
</TABLE>  
 <tt> int MPI_Info_create(MPI_Info *info) <BR></tt>  
 <tt> MPI_INFO_CREATE(INFO, IERROR)<BR> INTEGER INFO, IERROR <BR></tt>  
  
 <tt> static MPI::Info MPI::Info::Create() <BR></tt>  
  
<P> 
 MPI_INFO_CREATE creates a new info object. The newly created object contains  
no key/value pairs.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INFO_SET(info, key, value)</TD></TR>  
<TR><TD> INOUT info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> IN key</TD><TD>key (string)</TD></TR>  
<TR><TD> IN value</TD><TD>value (string)</TD></TR>  
</TABLE>  
  
 <tt> int MPI_Info_set(MPI_Info info, char *key, char *value) <BR></tt>  
  
 <tt> MPI_INFO_SET(INFO, KEY, VALUE, IERROR)<BR> INTEGER INFO, IERROR <BR>CHARACTER*(*) KEY, VALUE <BR></tt>  
  
 <tt> void MPI::Info::Set(const char* key, const char* value) <BR></tt>  
  
<P> 
 MPI_INFO_SET adds the (key,value) pair to  info, and  overrides the value if a value for the same key was previously set.   
 key and  value are null-terminated strings in C.   
In Fortran, leading and trailing spaces in  key and  value are stripped.   
If either  key or  value are larger than   
  
the allowed maximums, the errors  MPI_ERR_INFO_KEY or  
  
 MPI_ERR_INFO_VALUE are raised, respectively.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INFO_DELETE(info, key)</TD></TR>  
<TR><TD> INOUT info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> IN key</TD><TD>key (string)</TD></TR>  
</TABLE>  
  
 <tt> int MPI_Info_delete(MPI_Info info, char *key) <BR></tt>  
   
 <tt> MPI_INFO_DELETE(INFO, KEY, IERROR)<BR> INTEGER INFO, IERROR <BR>CHARACTER*(*) KEY <BR></tt>  
  
 <tt> void MPI::Info::Delete(const char* key) <BR></tt>  
  
<P> 
 MPI_INFO_DELETE deletes a (key,value) pair from  info.  
If  key is not defined in  info, the call  
raises an error of class  MPI_ERR_INFO_NOKEY.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INFO_GET(info, key, valuelen, value, flag)</TD></TR>  
<TR><TD> IN info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> IN key</TD><TD>key (string)</TD></TR>  
<TR><TD> IN valuelen</TD><TD>length of value arg (integer)</TD></TR>  
<TR><TD> OUT value</TD><TD>value (string)</TD></TR>  
<TR><TD> OUT flag</TD><TD>  true if key defined,  false if not (boolean)</TD></TR>  
</TABLE>  
  
 <tt> int MPI_Info_get(MPI_Info info, char *key, int valuelen, char *value, int *flag) <BR></tt>  
  
 <tt> MPI_INFO_GET(INFO, KEY, VALUELEN, VALUE, FLAG, IERROR)<BR> INTEGER INFO, VALUELEN, IERROR <BR>CHARACTER*(*) KEY, VALUE <BR>LOGICAL FLAG <BR></tt>  
  
 <tt> bool MPI::Info::Get(const char* key, int valuelen, char* value) const <BR></tt>  
  
<P> 
This function retrieves the value associated with key in a previous call to   
 MPI_INFO_SET. If such a key exists, it sets  flag to  true   
and returns the value in  value,  
otherwise it sets  flag to  false and leaves  
 value unchanged.   
 valuelen is the number of characters available in   
value. If it is less than the actual size of the value, the value is  
truncated. In C,  valuelen should  
be one less than the amount of allocated space to allow  
for the null terminator.   
<P> 
  
If  key is larger than  MPI_MAX_INFO_KEY,   
  
the call is erroneous.   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INFO_GET_VALUELEN(info, key, valuelen, flag)</TD></TR>  
<TR><TD> IN info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> IN key</TD><TD>key (string)</TD></TR>  
<TR><TD> OUT valuelen</TD><TD>length of value arg (integer)</TD></TR>  
<TR><TD> OUT flag</TD><TD>  true if key defined,  false if not (boolean)</TD></TR>  
</TABLE>  
  
 <tt> int MPI_Info_get_valuelen(MPI_Info info, char *key, int *valuelen, int *flag) <BR></tt>  
  
 <tt> MPI_INFO_GET_VALUELEN(INFO, KEY, VALUELEN, FLAG, IERROR)<BR> INTEGER INFO, VALUELEN, IERROR <BR>LOGICAL FLAG <BR>CHARACTER*(*) KEY <BR></tt>  
  
 <tt> bool MPI::Info::Get_valuelen(const char* key, int&amp; valuelen) const <BR></tt>  
  
<P> 
Retrieves the length of the  value associated with  
 key. If  key is defined,  valuelen is set  
to the length of its associated value and  flag is set to  
 true.  If  key is not defined,  valuelen is not  
touched and  flag is set to  false. The length returned in   
C or C++ does not include the end-of-string character.  
<P> 
  
If  key is larger than  MPI_MAX_INFO_KEY,   
  
the call is erroneous.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INFO_GET_NKEYS(info, nkeys)</TD></TR>  
<TR><TD> IN info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> OUT nkeys</TD><TD>number of defined keys (integer)</TD></TR>  
</TABLE>  
 <tt> int MPI_Info_get_nkeys(MPI_Info info, int *nkeys) <BR></tt>  
 <tt> MPI_INFO_GET_NKEYS(INFO, NKEYS, IERROR)<BR> INTEGER INFO, NKEYS, IERROR <BR></tt>  
  
 <tt> int MPI::Info::Get_nkeys() const <BR></tt>  
  
<P> 
 MPI_INFO_GET_NKEYS returns the number of currently defined keys in  info.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INFO_GET_NTHKEY(info, n, key)</TD></TR>  
<TR><TD> IN info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> IN n</TD><TD>key number (integer)</TD></TR>  
<TR><TD> OUT key</TD><TD>key (string)</TD></TR>  
</TABLE>  
  
 <tt> int MPI_Info_get_nthkey(MPI_Info info, int n, char *key) <BR></tt>  
  
 <tt> MPI_INFO_GET_NTHKEY(INFO, N, KEY, IERROR)<BR> INTEGER INFO, N, IERROR <BR>CHARACTER*(*) KEY <BR></tt>  
  
 <tt> void MPI::Info::Get_nthkey(int n, char* key) const <BR></tt>  
  
<P> 
This function returns the  nth defined key in  info.  
Keys are numbered <I>0 ... N-1</I> where <I>N</I> is the  
value returned by  MPI_INFO_GET_NKEYS.   
All keys between <I>0</I> and <I>N-1</I> are guaranteed to   
be defined. The number of a given key does not change  
as long as  info is not modified with   
 MPI_INFO_SET or  MPI_INFO_DELETE.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INFO_DUP(info, newinfo)</TD></TR>  
<TR><TD> IN info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> OUT newinfo</TD><TD>info object (handle)</TD></TR>  
</TABLE>  
 <tt> int MPI_Info_dup(MPI_Info info, MPI_Info *newinfo) <BR></tt>  
 <tt> MPI_INFO_DUP(INFO, NEWINFO, IERROR)<BR> INTEGER INFO, NEWINFO, IERROR <BR></tt>  
  
 <tt> MPI::Info MPI::Info::Dup() const <BR></tt>  
  
<P> 
 MPI_INFO_DUP duplicates an existing info object, creating a new  
object, with the same (key,value) pairs and the same ordering of keys.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_INFO_FREE(info)</TD></TR>  
<TR><TD> INOUT info</TD><TD>info object (handle)</TD></TR>  
</TABLE>  
 <tt> int MPI_Info_free(MPI_Info *info) <BR></tt>  
 <tt> MPI_INFO_FREE(INFO, IERROR) <BR> INTEGER INFO, IERROR <BR></tt>  
  
 <tt> void MPI::Info::Free() <BR></tt>  
  
<P> 
  
This function frees  info and sets it to  MPI_INFO_NULL.  
The value of an info argument is interpreted each time the info is passed   
to a routine.  Changes to an info after return from a routine do not affect  
that interpretation.  
  
<P> 

<P>
<HR>
<A HREF="node52.htm#Node52"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node41.htm#Node41"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node54.htm#Node54"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node41.htm#Node41"> Miscellany</a>
<b>Next: </b><A HREF="node54.htm#Node54"> Memory Allocation</a>
<b>Previous: </b><A HREF="node52.htm#Node52"> Determining Whether  MPI Has Finished</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
