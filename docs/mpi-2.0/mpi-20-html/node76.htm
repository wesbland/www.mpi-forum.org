<HTML>
<!-- This file was generated by tohtml from misc-2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>Type Constructors with Explicit Addresses</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node76">4.14.1. Type Constructors with Explicit Addresses</a></H2>
<A HREF="node75.htm#Node75"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node75.htm#Node75"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node77.htm#Node77"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node75.htm#Node75"> New Datatype Manipulation Functions</a>
<b>Next: </b><A HREF="node77.htm#Node77"> Extent and Bounds of Datatypes</a>
<b>Previous: </b><A HREF="node75.htm#Node75"> New Datatype Manipulation Functions</a>
<P>
The four functions below supplement the four corresponding type  
constructor functions from  MPI-1.  The new functions are synonymous  
with the old functions in C/C++, or on Fortran systems where default  
 INTEGERs are  
address sized.  
  
(The old names are not available in C++.)  
  
In Fortran, these functions accept arguments of type  
<tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt>, wherever arguments  
of type  MPI_Aint are used in C.  On Fortran 77  
systems that do not support the Fortran 90  
 KIND notation, and where addresses are 64 bits whereas  
default  INTEGERs are 32 bits, these arguments will be of  
type  INTEGER*8.  The old functions will continue to be  
provided for backward compatibility.  However, users are  
encouraged to switch to the new functions, in  
both Fortran and C.  
<P> 
The new functions are listed below.    
  
The use of the old functions is deprecated.  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HVECTOR( count, blocklength, stride,  
oldtype, newtype)</TD></TR> <TR><TD> IN count</TD><TD>number of blocks (nonnegative  
integer)</TD></TR> <TR><TD> IN blocklength</TD><TD>number of elements in each block  
(nonnegative integer)</TD></TR> <TR><TD> IN stride</TD><TD>number of bytes between start  
of each block (integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_hvector(int count, int blocklength, MPI_Aint stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_HVECTOR(COUNT, BLOCKLENGTH, STIDE, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, BLOCKLENGTH, OLDTYPE, NEWTYPE, IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) STRIDE <BR></tt>  
<P> 
 <tt> MPI::Datatype MPI::Datatype::Create_hvector(int count, int blocklength, MPI::Aint stride) const <BR></tt>  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HINDEXED( count,  
array_of_blocklengths, array_of_displacements, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks --- also number of entries in  
<BR> array_of_displacements and  
 array_of_blocklengths (integer)</TD></TR>  
<TR><TD> IN array_of_blocklengths</TD><TD>number of elements in each block  
(array of nonnegative integers)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>byte displacement of each block  
(array of integer)</TD></TR> <TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_hindexed(int count, int array_of_blocklengths[], MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_HINDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), OLDTYPE, NEWTYPE, IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*) <BR></tt>  
<P> 
 <tt> MPI::Datatype MPI::Datatype::Create_hindexed(int count, const int array_of_blocklengths[], const MPI::Aint array_of_displacements[]) const <BR></tt>  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_STRUCT(count, array_of_blocklengths,  
array_of_displacements,  array_of_types, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks (integer) --- also number of entries  
in arrays  array_of_types,  array_of_displacements and  
 array_of_blocklengths</TD></TR>  
<TR><TD> IN array_of_blocklength</TD><TD>number of elements in each block  
(array of integer)</TD></TR> <TR><TD> IN array_of_displacements</TD><TD>byte  
displacement of each block (array of integer)</TD></TR>  
<TR><TD> IN array_of_types</TD><TD>type of elements in each block (array of  
handles to datatype objects)</TD></TR> <TR><TD> OUT newtype</TD><TD>new datatype  
(handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_struct(int count, int array_of_blocklengths[], MPI_Aint array_of_displacements[], MPI_Datatype array_of_types[], MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_STRUCT(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, ARRAY_OF_TYPES, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_TYPES(*), NEWTYPE, IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*) <BR></tt>  
<P> 
  
 <tt> static MPI::Datatype MPI::Datatype::Create_struct(int count, const int array_of_blocklengths[], const MPI::Aint array_of_displacements[], const MPI::Datatype array_of_types[]) <BR></tt>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GET_ADDRESS(location, address)</TD></TR>  
<TR><TD> IN location</TD><TD>location in caller memory (choice)</TD></TR>  
<TR><TD> OUT address</TD><TD>address of location (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Get_address(void *location, MPI_Aint *address) <BR></tt>  
<P> 
 <tt> MPI_GET_ADDRESS(LOCATION, ADDRESS, IERROR)<BR> &lt;type&gt; LOCATION(*) <BR>INTEGER IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) ADDRESS <BR></tt>  
<P> 
 <tt> MPI::Aint MPI::Get_address(void* location) <BR></tt>  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Current Fortran  MPI codes will run unmodified, and will port to any  
system. However, they may fail if addresses larger than <I>2<SUP>32</SUP> -1</I>  
are used in the program.  New codes should be written so that they use  
the new functions. This provides compatibility  
with C/C++ and avoids errors on 64 bit architectures.  However, such  
newly written codes may need to be (slightly) rewritten to port to old  
Fortran 77 environments that do not support  KIND  
declarations.  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 

<P>
<HR>
<A HREF="node75.htm#Node75"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node75.htm#Node75"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node77.htm#Node77"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node75.htm#Node75"> New Datatype Manipulation Functions</a>
<b>Next: </b><A HREF="node77.htm#Node77"> Extent and Bounds of Datatypes</a>
<b>Previous: </b><A HREF="node75.htm#Node75"> New Datatype Manipulation Functions</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
