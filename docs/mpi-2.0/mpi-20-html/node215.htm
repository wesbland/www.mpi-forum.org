<HTML>
<!-- This file was generated by tohtml from io-2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>Examples</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node215">9.6.10. Examples</a></H2>
<A HREF="node214.htm#Node214"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node205.htm#Node205"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node215.htm#Node216"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node205.htm#Node205"> Consistency and Semantics</a>
<b>Next: </b><A HREF="node215.htm#Node216"> Asynchronous I/O</a>
<b>Previous: </b><A HREF="node214.htm#Node214"> File Size</a>
<P>
  
<P> 
The examples in this section illustrate  
the application of the  MPI consistency and semantics guarantees.  
These address  
<ul> 
 
<li>conflicting accesses on file handles obtained from a   
single collective open, and  
 
<li>all accesses on file handles obtained from two separate  
collective opens.  
</ul> 
<BR> 
The simplest way to achieve consistency for conflicting accesses is  
to obtain sequential consistency by setting atomic mode.  
For the code below,  
process 1 will read either 0 or 10 integers.  
If the latter, every element of <tt> b</tt> will be  5.  
If nonatomic mode is set, the results of the read are undefined.  
  
<BR> 
<pre><tt>/* Process 0 */ 
int  i, a[10] ; 
int  TRUE = 1; 
 
for ( i=0;i&lt;10;i++) 
   a[i] = 5 ; 
 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh0 ) ; 
MPI_File_set_view( fh0, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
MPI_File_set_atomicity( fh0, TRUE ) ; 
MPI_File_write_at(fh0, 0, a, 10, MPI_INT, &amp;status) ; 
/* MPI_Barrier( MPI_COMM_WORLD ) ; */ 
</tt></pre> 
<BR> 
<pre><tt>/* Process 1 */ 
int  b[10] ; 
int  TRUE = 1; 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh1 ) ; 
MPI_File_set_view( fh1, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
MPI_File_set_atomicity( fh1, TRUE ) ; 
/* MPI_Barrier( MPI_COMM_WORLD ) ; */ 
MPI_File_read_at(fh1, 0, b, 10, MPI_INT, &amp;status) ; 
</tt></pre> 
A user may guarantee that the write on process  0  
precedes the read on process  1 by imposing temporal order  
with, for example, calls to  MPI_BARRIER.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Routines other than  MPI_BARRIER may be used to impose   
temporal order.  In the example above, process 0 could use  MPI_SEND  
to send a 0 byte message, received by process 1 using  MPI_RECV.  
 (<em> End of advice to users.</em>) <BR> 
Alternatively, a user can impose consistency with nonatomic mode set:  
  
<BR> 
<pre><tt>/* Process 0 */ 
int  i, a[10] ; 
for ( i=0;i&lt;10;i++) 
   a[i] = 5 ; 
 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh0 ) ; 
MPI_File_set_view( fh0, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
MPI_File_write_at(fh0, 0, a, 10, MPI_INT, &amp;status ) ; 
MPI_File_sync( fh0 ) ; 
MPI_Barrier( MPI_COMM_WORLD ) ; 
MPI_File_sync( fh0 ) ; 
</tt></pre> 
<BR> 
<pre><tt>/* Process 1 */ 
int  b[10] ; 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh1 ) ; 
MPI_File_set_view( fh1, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
MPI_File_sync( fh1 ) ; 
MPI_Barrier( MPI_COMM_WORLD ) ; 
MPI_File_sync( fh1 ) ; 
MPI_File_read_at(fh1, 0, b, 10, MPI_INT, &amp;status ) ; 
</tt></pre> 
The ``sync-barrier-sync'' construct is required because:  
<ul> 
 
<li>The barrier ensures that the write on process 0 occurs  
before the read on process 1.  
 
<li>The first sync guarantees that the data written by all  
processes is transferred to the storage device.    
  
 
<li>The second sync guarantees that all data which has been  
transferred to the storage device is visible to all processes.  
  
(This does not affect process 0 in this example.)  
</ul> 
<BR> 
The following program represents an erroneous attempt to achieve consistency  
by eliminating the apparently superfluous second ``sync'' call for  
each process.  
<BR> 
<pre><tt>/* ----------------  THIS EXAMPLE IS ERRONEOUS --------------- */ 
/* Process 0 */ 
int  i, a[10] ; 
for ( i=0;i&lt;10;i++) 
   a[i] = 5 ; 
 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh0 ) ; 
MPI_File_set_view( fh0, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
MPI_File_write_at(fh0, 0, a, 10, MPI_INT, &amp;status ) ; 
MPI_File_sync( fh0 ) ; 
MPI_Barrier( MPI_COMM_WORLD ) ; 
</tt></pre> 
<BR> 
<pre><tt>/* Process 1 */ 
int  b[10] ; 
MPI_File_open( MPI_COMM_WORLD, "workfile",  
               MPI_MODE_RDWR | MPI_MODE_CREATE, MPI_INFO_NULL, &amp;fh1 ) ; 
MPI_File_set_view( fh1, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
MPI_Barrier( MPI_COMM_WORLD ) ; 
MPI_File_sync( fh1 ) ; 
MPI_File_read_at(fh1, 0, b, 10, MPI_INT, &amp;status ) ; 
 
/* ----------------  THIS EXAMPLE IS ERRONEOUS --------------- */ 
</tt></pre> 
The above program also violates the  MPI rule  
against out-of-order collective operations  
and  
will deadlock for implementations in which  MPI_FILE_SYNC blocks.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Some implementations may choose to implement  MPI_FILE_SYNC  
as a temporally synchronizing function.  When using such an  
implementation, the ``sync-barrier-sync'' construct above can  
be replaced by a single ``sync.''  The results of using such  
code with an implementation for which  MPI_FILE_SYNC is not  
temporally synchronizing is undefined.  
 (<em> End of advice to users.</em>) <BR> 
<menu> 
</menu> 

<P>
<HR>
<A HREF="node214.htm#Node214"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node205.htm#Node205"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node215.htm#Node216"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node205.htm#Node205"> Consistency and Semantics</a>
<b>Next: </b><A HREF="node215.htm#Node216"> Asynchronous I/O</a>
<b>Previous: </b><A HREF="node214.htm#Node214"> File Size</a>
<P>
<HR><H3><A NAME="Node216">9.6.10.1. Asynchronous I/O</a></H3>
<A HREF="node215.htm#Node215"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node215.htm#Node215"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node217.htm#Node217"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node215.htm#Node215"> Examples</a>
<b>Next: </b><A HREF="node217.htm#Node217"> I/O Error Handling</a>
<b>Previous: </b><A HREF="node215.htm#Node215"> Examples</a>
<P>
The behavior of asynchronous I/O operations is determined by  
applying the rules specified above for synchronous I/O operations.  
<P> 
The following examples all access a preexisting file ``myfile.''  
Word  10 in myfile initially contains the integer  2.  
Each example writes and reads word  10.  
<P> 
First consider the following code fragment:  
<BR> 
<pre><tt>int a = 4, b, TRUE=1; 
MPI_File_open( MPI_COMM_WORLD, "myfile",  
               MPI_MODE_RDWR, MPI_INFO_NULL, &amp;fh ) ; 
MPI_File_set_view( fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
/* MPI_File_set_atomicity( fh, TRUE ) ;   Use this to set atomic mode. */ 
MPI_File_iwrite_at(fh, 10, &amp;a, 1, MPI_INT, &amp;reqs[0]) ; 
MPI_File_iread_at(fh,  10, &amp;b, 1, MPI_INT, &amp;reqs[1]) ; 
MPI_Waitall(2, reqs, statuses) ;  
</tt></pre> 
For asynchronous data access operations,  MPI specifies   
that the access occurs at any time between the call to the asynchronous   
data access routine and the return from the corresponding   
request complete routine.  
Thus, executing either the read before the write,  
or the write before the read is consistent with program order.  
If atomic mode is set, then  MPI guarantees sequential   
consistency, and the program will read either  2 or   
 4 into <tt> b</tt>.    
If atomic mode is not set, then sequential consistency is not   
guaranteed and the program may read something other than  2   
or  4 due to the conflicting data access.  
<P> 
Similarly, the following code fragment does not order file accesses:  
  
<BR> 
<pre><tt>int a = 4, b; 
MPI_File_open( MPI_COMM_WORLD, "myfile",  
               MPI_MODE_RDWR, MPI_INFO_NULL, &amp;fh ) ; 
MPI_File_set_view( fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
/* MPI_File_set_atomicity( fh, TRUE ) ;   Use this to set atomic mode. */ 
MPI_File_iwrite_at(fh, 10, &amp;a, 1, MPI_INT, &amp;reqs[0]) ; 
MPI_File_iread_at(fh,  10, &amp;b, 1, MPI_INT, &amp;reqs[1]) ; 
MPI_Wait(&amp;reqs[0], &amp;status) ; 
MPI_Wait(&amp;reqs[1], &amp;status) ; 
</tt></pre> 
If atomic mode is set, either  2 or  4 will be read   
into <tt> b</tt>.  Again,  MPI does not guarantee sequential consistency  
in nonatomic mode.  
<P> 
On the other hand, the following code fragment:  
<BR> 
<pre><tt>int a = 4, b; 
MPI_File_open( MPI_COMM_WORLD, "myfile",  
               MPI_MODE_RDWR, MPI_INFO_NULL, &amp;fh ) ; 
MPI_File_set_view( fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
MPI_File_iwrite_at(fh, 10, &amp;a, 1, MPI_INT, &amp;reqs[0]) ; 
MPI_Wait(&amp;reqs[0], &amp;status) ; 
MPI_File_iread_at(fh,  10, &amp;b, 1, MPI_INT, &amp;reqs[1]) ; 
MPI_Wait(&amp;reqs[1], &amp;status) ; 
</tt></pre> 
defines the same ordering as:  
<BR> 
<pre><tt>int a = 4, b; 
MPI_File_open( MPI_COMM_WORLD, "myfile",  
               MPI_MODE_RDWR, MPI_INFO_NULL, &amp;fh ) ; 
MPI_File_set_view( fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL ) ; 
MPI_File_write_at(fh, 10, &amp;a, 1, MPI_INT, &amp;status ) ; 
MPI_File_read_at(fh,  10, &amp;b, 1, MPI_INT, &amp;status ) ; 
</tt></pre> 
Since  
<ul> 
 
<li>nonconcurrent operations on a single file handle are sequentially consistent, and  
 
<li>the program fragments specify an order for the operations,  
</ul> 
<BR> 
 MPI guarantees that both program fragments will read the value   
 4 into  
<tt> b</tt>.  There is no need to set atomic mode for this example.  
<P> 
Similar considerations apply to conflicting accesses of the form:  
<BR> 
<pre><tt>MPI_File_write_all_begin(fh,...) ; 
MPI_File_iread(fh,...) ; 
MPI_Wait(fh,...) ; 
MPI_File_write_all_end(fh,...) ; 
</tt></pre> 
Recall that constraints governing consistency and semantics are not  
relevant to the following:  
<BR> 
<pre><tt>MPI_File_write_all_begin(fh,...) ; 
MPI_File_read_all_begin(fh,...) ; 
MPI_File_read_all_end(fh,...) ; 
MPI_File_write_all_end(fh,...) ; 
</tt></pre> 
since split collective operations on the same file handle may not overlap  
(see Section <a href="node197.htm#Node197">Split Collective Data Access Routines 
</a>).  
<P> 
  
<P> 
  
<P> 
  
<P> 
<P> 

<P>
<HR>
<A HREF="node215.htm#Node215"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node215.htm#Node215"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node217.htm#Node217"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node215.htm#Node215"> Examples</a>
<b>Next: </b><A HREF="node217.htm#Node217"> I/O Error Handling</a>
<b>Previous: </b><A HREF="node215.htm#Node215"> Examples</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
