<HTML>
<!-- This file was generated by tohtml from terms-2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>C++ Binding Issues</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node21">2.6.4. C++ Binding Issues</a></H2>
<A HREF="node20.htm#Node20"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node17.htm#Node17"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node22.htm#Node22"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node17.htm#Node17"> Language Binding</a>
<b>Next: </b><A HREF="node22.htm#Node22"> Processes</a>
<b>Previous: </b><A HREF="node20.htm#Node20"> C Binding Issues</a>
<P>
  
<P> 
  
There are places in the standard that give rules for C and not  
for C++.  In these cases, the C rule should be applied to the C++  
case, as appropriate.  In particular, the values of constants given in  
the text are the ones for C and Fortran.  A cross index of these with  
the C++ names is given in Annex <a href="node251.htm#Node251">Language Binding 
</a>.  
  
<P> 
We use the ANSI C++ declaration format.  All  MPI names are declared  
within the scope of a namespace called <tt> MPI</tt> and therefore are  
referenced with an <tt> MPI::</tt> prefix.  Defined constants are in all  
capital letters, and class names, defined types, and functions have  
only their first letter capitalized.  Programs must not declare  
variables or functions in the <tt> MPI</tt> namespace.  This is mandated  
to avoid possible name collisions.  
<P> 
The definition of named constants, function prototypes, and type  
definitions must be supplied in an include file  mpi.h.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
  
The file  mpi.h may contain both the C and C++ definitions.  
  
Usually one can simply use the defined value (generally <tt> __cplusplus</tt>,  
but not required) to see if one is using  
C++ to protect the C++ definitions.  It is possible that a C compiler  
will require that the source protected this way be legal C code.  In  
this case, all the C++ definitions can be placed in a different  
include file and the ``<tt>#include</tt>'' directive can be used to include the  
necessary C++ definitions in the  mpi.h file.  
 (<em> End of advice to implementors.</em>) <BR> 
C++ functions that create objects or return information usually place  
the object or information in the return value.  Since the language  
neutral prototypes of  MPI functions include the C++ return value as  
an  OUT parameter, semantic descriptions of  MPI functions refer to  
the C++ return value by that parameter name (see  
Section <a href="node305.htm#Node305">Function Name Cross Reference 
</a>).  
The remaining C++ functions return <tt> void</tt>.  
<P> 
  
In some circumstances,  MPI permits users to indicate that they do  
not want a return value.  For example, the user may indicate that the  
status is not filled in.  Unlike C and Fortran where this is achieved  
through a special input value, in C++ this is done by having two  
bindings where one has the optional argument and one does not.  
  
<P> 
C++ functions do not return error codes.  If the default error handler  
has been set to  MPI::ERRORS_THROW_EXCEPTIONS, the C++  
exception mechanism is used to signal an error by  
throwing an   
  
<tt> MPI::Exception</tt>   
  
object.  
<P> 
It should be noted that the default error handler  
(i.e.,  MPI::ERRORS_ARE_FATAL) on a given type has not  
changed.  User error handlers are also permitted.  
 MPI::ERRORS_RETURN simply returns control to the calling  
function; there is no provision for the user to retrieve the error  
code.  
<P> 
User callback functions that return integer error codes should not  
throw exceptions; the returned error will be handled by the  MPI  
implementation by invoking the appropriate error handler.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
C++ programmers that want to handle  MPI errors on their own should  
use the  MPI::ERRORS_THROW_EXCEPTIONS error handler, rather  
than  MPI::ERRORS_RETURN, that is used for that purpose in  
C.  Care should be taken using exceptions in mixed language  
situations.  
 (<em> End of advice to users.</em>) <BR> 
Opaque object handles must be objects in themselves, and have the  
assignment and equality operators overridden to perform semantically  
like their C and Fortran counterparts.  
<P> 
Array arguments are indexed from zero.  
<P> 
Logical flags are of type <tt> bool</tt>.  
<P> 
Choice arguments are pointers of type <tt> void *</tt>.  
<P> 
Address arguments are of  MPI-defined integer type  MPI::Aint,  
defined to be an integer of the size needed to hold any valid address  
on the target architecture.  
  
Analogously,  MPI::Offset is an integer to hold file offsets.  
  
<P> 
Most  MPI functions are methods of  MPI C++ classes.   MPI class  
names are generated from the language neutral  MPI types by dropping  
the <tt> MPI_</tt> prefix and scoping the type within the  
<tt> MPI</tt> namespace.  For example,  MPI_DATATYPE becomes   
<tt> MPI::Datatype</tt>.  
<P> 
  
The names of  MPI-2 functions generally follow the naming rules  
given.  In some circumstances, the new  MPI-2 function is related to  
an  MPI-1 function with a name that does not follow the naming  
conventions.  In this circumstance, the language neutral name is in  
analogy to the  MPI-1 name even though this gives an  MPI-2 name that  
violates the naming conventions.  The C and Fortran names are the same  
as the language neutral name in this case.  However, the C++ names  
for  MPI-1 do reflect the naming rules and can differ from the C and  
Fortran names.  Thus, the analogous name in C++ to the  MPI-1 name is  
different than the language neutral name.  This results in the C++  
name differing from the language neutral name.  An example of this is  
the language neutral name of  MPI_FINALIZED and a C++ name  
of  MPI::Is_finalized.  
  
<P> 
  
In C++, function <tt> typedef</tt>s are made publicly within appropriate  
classes.  However, these declarations then become somewhat cumbersome,  
as with the following:  
<P> 
 <tt> typedef MPI::Grequest::Query_function(); <BR></tt>  
<P> 
  
would look like the following:  
<P> 
<BR> 
<pre><tt>namespace MPI { 
  class Request { 
    // ... 
  }; 
 
  class Grequest : public MPI::Request { 
    // ... 
    typedef Query_function(void* extra_state, MPI::Status&amp; status); 
  }; 
}; 
</tt></pre> 
Rather than including this scaffolding when declaring   
C++ <tt> typedef</tt>s, we use an abbreviated form.  In  
particular, we explicitly indicate the class and namespace scope for  
the <tt> typedef</tt> of the function.  Thus, the example above is  
shown in the text as follows:  
<BR> 
<pre><tt>typedef int MPI::Grequest::Query_function(void* extra_state, 
                                          MPI::Status&amp; status) 
</tt></pre> 
  
<P> 
The C++ bindings presented in Annex <a href="node287.htm#Node287"> MPI-1 C++ Language Binding 
</a>  
and throughout this document were generated by applying a simple set  
of name generation rules to the  MPI function specifications.  While  
these guidelines may be sufficient in most cases, they may not be  
suitable for all situations.  In cases of ambiguity or where a  
specific semantic statement is desired, these guidelines may be  
superseded as the situation dictates.  
<P> 
<ol> 
 
1. All functions, types, and constants are declared within the  
  scope of a <tt> namespace</tt> called <tt> MPI</tt>.  
  <P> 
 
<BR> 
2. Arrays of  MPI handles are always left in the argument list  
  (whether they are  IN or  OUT arguments).  
<P> 
 
<BR> 
3. If the argument list of an  MPI function contains a scalar  IN   
  handle, and it makes sense to define the function as a method of the  
  object corresponding to that handle, the function is made a member  
  function of the corresponding  MPI class.  
  The member functions are named according to the corresponding  MPI  
  function name, but without the ``<tt> MPI_</tt>'' prefix and without  
  the object name prefix (if applicable).  In addition:  
<P> 
<ol> 
   
1. The scalar  IN handle is dropped from the argument list, and  
    <tt> this</tt> corresponds to the dropped argument.  
<P> 
 
<BR> 
2. The function is declared <tt> const</tt>.  
  </ol> 
 
<BR> 
4.  MPI functions are made into class functions (static) when they  
belong on a class but do not have a unique scalar  IN or  INOUT parameter of that class.  
<P> 
 
<BR> 
5. If the argument list contains a single  OUT argument that is  
  not of type  MPI_STATUS (or an array), that argument is  
  dropped from the list and the function returns that value.  
<P> 
<BR><b> Example</b>  
    The C++ binding for  MPI_COMM_SIZE is  
     int MPI::Comm::Get_size(void) const.  
    
<P> 
 
<BR> 
6. If there are multiple  OUT arguments in the argument list, one  
  is chosen as the return value and is removed from the list.  
<P> 
 
<BR> 
7. If the argument list does not contain any  OUT arguments,  
  the function returns <tt> void</tt>.  
<P> 
<BR><b> Example</b>  
    The C++ binding for  MPI_REQUEST_FREE is  void  
      MPI::Request::Free(void)  
    
<P> 
 
<BR> 
8.  MPI functions to which the above rules do not apply are not  
  members of any class, but are defined in the <tt> MPI</tt> namespace.  
<P> 
<BR><b> Example</b>  
    The C++ binding for  MPI_BUFFER_ATTACH is  
     void MPI::Attach_buffer(void* buffer, int size).  
    
<P> 
 
<BR> 
9. All class names, defined types, and function names have only  
  their first letter capitalized.  Defined constants are in all  
  capital letters.  
<P> 
 
<BR> 
10. Any  IN pointer, reference, or array argument must be declared  
  <tt> const</tt>.  
  <P> 
 
<BR> 
11. Handles are passed by reference.  
  <P> 
 
<BR> 
12. Array arguments are denoted with square brackets (<tt> []</tt>), not  
  pointers, as this is more semantically precise.  
</ol> 

<P>
<HR>
<A HREF="node20.htm#Node20"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node17.htm#Node17"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node22.htm#Node22"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node17.htm#Node17"> Language Binding</a>
<b>Next: </b><A HREF="node22.htm#Node22"> Processes</a>
<b>Previous: </b><A HREF="node20.htm#Node20"> C Binding Issues</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
