<HTML>
<!-- This file was generated by tohtml from binding-2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>Profiling</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node233">10.1.10. Profiling</a></H2>
<A HREF="node232.htm#Node232"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node223.htm#Node223"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node234.htm#Node234"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node223.htm#Node223"> C++</a>
<b>Next: </b><A HREF="node234.htm#Node234"> Fortran Support</a>
<b>Previous: </b><A HREF="node232.htm#Node232"> Mixed-Language Operability</a>
<P>
  
<P> 
  
<P> 
This section specifies the requirements of a C++ profiling interface  
to  MPI.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Since the main goal of profiling is to intercept function calls from  
  user code, it is the implementor's decision how to layer the  
  underlying implementation to allow function calls to be intercepted  
  and profiled.  If an implementation of the  MPI C++ bindings is  
  layered on top of  MPI bindings in another language (such as C), or  
  if the C++ bindings are layered on top of a profiling interface in  
  another language, no extra profiling interface is necessary because  
  the underlying  MPI implementation already meets the  MPI  
  profiling interface requirements.  
<P> 
Native C++  MPI implementations that do not have access to other  
  profiling interfaces must implement an interface that meets the  
  requirements outlined in this section.    
<P> 
High quality implementations can implement the interface outlined in  
  this section in order to promote portable C++ profiling libraries.  
  Implementors may wish to provide an option whether to build the C++  
  profiling interface or not; C++ implementations that are already  
  layered on top of bindings in another language or another profiling  
  interface will have to insert a third layer to implement the C++  
  profiling interface.  
 (<em> End of advice to implementors.</em>) <BR> 
To meet the requirements of the C++  MPI profiling interface, an  
implementation of the  MPI functions <em> must</em>:  
<P> 
<ol> 
 
1. Provide a mechanism through which all of the  MPI defined  
  functions may be accessed with a name shift. Thus all of the  MPI  
  functions (which normally start with the prefix ``<tt> MPI::</tt>'')  
  should also be accessible with the prefix ``<tt> PMPI::</tt>.''  
<P> 
 
<BR> 
2. Ensure that those  MPI functions which are not replaced may  
  still be linked into an executable image without causing name  
  clashes.  
<P> 
 
<BR> 
3. Document the implementation of different language bindings of  
  the  MPI interface if they are layered on top of each other, so  
  that profiler developer knows whether they must implement the  
  profile interface for each binding, or can economize by implementing  
  it only for the lowest level routines.  
<P> 
 
<BR> 
4. Where the implementation of different language bindings is is  
  done through a layered approach (e.g., the C++ binding is a set of  
  ``wrapper'' functions which call the C implementation), ensure that  
  these wrapper functions are separable from the rest of the library.  
<P> 
This is necessary to allow a separate profiling library to be  
  correctly implemented, since (at least with Unix linker semantics)  
  the profiling library must contain these wrapper functions if it is  
  to perform as expected.  This requirement allows the author of the  
  profiling library to extract these functions from the original  MPI  
  library and add them into the profiling library without bringing  
  along any other unnecessary code.  
  <P> 
 
<BR> 
5. Provide a no-op routine  MPI::Pcontrol in the  MPI  
  library.  
</ol> 
  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
There are (at least) two apparent options for implementing the C++  
profiling interface: inheritance or caching.  An inheritance-based  
approach may not be attractive because it may require a virtual  
inheritance implementation of the communicator classes.  Thus, it is  
most likely that implementors still cache <tt> PMPI</tt> objects on their  
corresponding <tt> MPI</tt> objects.  The caching scheme is outlined  
below.  
<P> 
  
<P> 
The ``real'' entry points to each routine can be provided within a  
<tt> namespace PMPI</tt>.  The non-profiling version can then be  
provided within a <tt> namespace MPI</tt>.  
<P> 
  <P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
  
<P> 
Caching instances of <tt> PMPI</tt> objects in the <tt> MPI</tt> handles  
provides the ``has a'' relationship that is necessary to implement  
the profiling scheme.  
<P> 
Each instance of an <tt> MPI</tt> object simply ``wraps up'' an  
instance of a <tt> PMPI</tt> object.  <tt> MPI</tt> objects can then  
perform profiling actions before invoking the corresponding function  
in their internal <tt> PMPI</tt> object.  
<P> 
  
<P> 
The key to making the profiling work by simply re-linking programs is  
by having a header file that <em> declares</em> all the  MPI functions.  
The functions must be <em> defined</em> elsewhere, and compiled into a  
library.   MPI constants should be declared <tt> extern</tt> in  
the <tt> MPI</tt> namespace.  For example, the following is an excerpt  
from a sample <tt> mpi.h</tt> file:  
<P> 
  
<P> 
<BR><b> Example</b>   
Sample <tt> mpi.h</tt> file.  
<BR> 
<pre><tt>namespace PMPI { 
  class Comm { 
  public: 
    int Get_size() const; 
  }; 
  // etc. 
}; 
 
namespace MPI { 
public: 
  class Comm { 
  public: 
    int Get_size() const; 
 
  private: 
    PMPI::Comm pmpi_comm; 
  }; 
}; 
</tt></pre> 
  
  
<P> 
Note that all constructors, the assignment operator, and the  
destructor in the <tt> MPI</tt> class will need to initialize/destroy  
the internal <tt> PMPI</tt> object as appropriate.  
<P> 
  
<P> 
The definitions of the functions must be in separate object files; the  
<tt> PMPI</tt> class member functions and the non-profiling versions of  
the <tt> MPI</tt> class member functions can be compiled into <tt>  
  libmpi.a</tt>, while the profiling versions can be compiled into <tt>  
  libpmpi.a</tt>.  Note that the <tt> PMPI</tt> class member functions and  
the <tt> MPI</tt> constants must be in different object files than the  
non-profiling <tt> MPI</tt> class member functions in the <tt> libmpi.a</tt>  
library to prevent multiple definitions of <tt> MPI</tt> class member  
function names when linking both <tt> libmpi.a</tt> and <tt> libpmpi.a</tt>.  
For example:  
<P> 
<BR><b> Example</b>   
<tt> pmpi.cc</tt>, to be compiled into <tt> libmpi.a</tt>.  
<BR> 
<pre><tt>int PMPI::Comm::Get_size() const 
{ 
  // Implementation of MPI_COMM_SIZE 
} 
</tt></pre> 
  
  
<P> 
<BR><b> Example</b>   
<tt> constants.cc</tt>, to be compiled into <tt>  
    libmpi.a</tt>.  
<BR> 
<pre><tt>const MPI::Intracomm MPI::COMM_WORLD; 
</tt></pre> 
  
  
<P> 
  
<P> 
<BR><b> Example</b>  
 <tt> mpi_no_profile.cc</tt>, to be compiled into <tt>  
  libmpi.a</tt>.   
<BR> 
<pre><tt>int MPI::Comm::Get_size() const 
{ 
  return pmpi_comm.Get_size(); 
} 
</tt></pre> 
  
  
<P> 
<BR><b> Example</b>  
 <tt> mpi_profile.cc</tt>, to be compiled into <tt> libpmpi.a</tt>.  
<BR> 
<pre><tt>int MPI::Comm::Get_size() const 
{ 
  // Do profiling stuff 
  int ret = pmpi_comm.Get_size(); 
  // More profiling stuff 
  return ret; 
} 
</tt></pre> 
  
  
<P> 
  
<P> 
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node232.htm#Node232"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node223.htm#Node223"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node234.htm#Node234"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node223.htm#Node223"> C++</a>
<b>Next: </b><A HREF="node234.htm#Node234"> Fortran Support</a>
<b>Previous: </b><A HREF="node232.htm#Node232"> Mixed-Language Operability</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
