<HTML>
<!-- This file was generated by tohtml from binding-2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>Communicators</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node230">10.1.7. Communicators</a></H2>
<A HREF="node229.htm#Node229"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node223.htm#Node223"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node231.htm#Node231"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node223.htm#Node223"> C++</a>
<b>Next: </b><A HREF="node231.htm#Node231"> Exceptions</a>
<b>Previous: </b><A HREF="node229.htm#Node229"> C++ Datatypes</a>
<P>
  
<P> 
The <tt> MPI::Comm</tt> class hierarchy makes explicit the different  
kinds of communicators implicitly defined by  MPI and allows them to  
be strongly typed.  Since the original design of  MPI defined only  
one type of handle for all types of communicators, the following  
clarifications are provided for the C++ design.  
<P> 
<P> 
Types of communicators There are five different types of communicators:  
 <tt> MPI::Comm</tt>,  
 <tt> MPI::Intercomm</tt>,  
 <tt> MPI::Intracomm</tt>, <tt> MPI::Cartcomm</tt>, and  
 <tt> MPI::Graphcomm</tt>.  
 <tt> MPI::Comm</tt> is the abstract base communicator class,  
 encapsulating the functionality common to all  MPI  
 communicators.   
 <tt> MPI::Intercomm</tt> and  
 <tt> MPI::Intracomm</tt> are derived from <tt> MPI::Comm</tt>.  
 <tt> MPI::Cartcomm</tt> and  
 <tt> MPI::Graphcomm</tt> are derived from <tt> MPI::Intracomm</tt>.  
 <P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Initializing a derived class with an instance of a base class is  
not legal in C++. For instance, it is not legal to initialize  
a Cartcomm from an Intracomm. Moreover, because  MPI::Comm  
is an abstract base class, it is non-instantiable, so that it is  
not possible to have an object of class MPI::Comm. However, it  
is possible to have a reference or a pointer to an  MPI::Comm.  
<P> 
<BR><b> Example</b>  
      The following code is erroneous.  
<BR> 
<pre><tt>  Intracomm intra = MPI::COMM_WORLD.Dup(); 
  Cartcomm cart(intra);         // This is erroneous 
</tt></pre> 
  
      
 (<em> End of advice to users.</em>) <BR> 
<P> 
 MPI::COMM_NULL The specific type of  MPI::COMM_NULL is implementation  
  dependent.   MPI::COMM_NULL must be able to be used in  
  comparisons and initializations with all types of communicators.  
   MPI::COMM_NULL must also be able to be passed to a  
  function that expects a communicator argument in the parameter list  
  (provided that  MPI::COMM_NULL is an allowed value for the  
  communicator argument).  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
There are several possibilities for implementation of  
   MPI::COMM_NULL.  Specifying its required behavior, rather  
  than its realization, provides maximum flexibility to implementors.  
 (<em> End of rationale.</em>) <BR> 
<BR><b> Example</b>  
    The following example demonstrates the behavior of assignment and  
    comparison using  MPI::COMM_NULL.  
<BR> 
<pre><tt>MPI::Intercomm comm; 
comm = MPI::COMM_NULL;            // assign with COMM_NULL 
if (comm == MPI::COMM_NULL)       // true 
  cout &lt;&lt; "comm is NULL" &lt;&lt; endl; 
if (MPI::COMM_NULL == comm)       // note -- a different function! 
  cout &lt;&lt; "comm is still NULL" &lt;&lt; endl; 
</tt></pre> 
  
<P> 
  
<tt> Dup()</tt> is not defined as a member function  
of <tt> MPI::Comm</tt>, but it is defined for the derived  
classes of <tt> MPI::Comm</tt>.  <tt> Dup()</tt> is not virtual and  
it returns its  OUT/ parameter by value.  
<P> 
<P> 
<tt> MPI::Comm::Clone()</tt> The C++ language interface for  MPI includes a new function  
<tt> Clone()</tt>.  <tt> MPI::Comm::Clone()</tt> is a pure virtual  
function.  For the derived communicator classes, <tt> Clone()</tt>  
behaves like <tt> Dup()</tt> except that it returns a new object by  
reference.  The <tt> Clone()</tt> functions are prototyped as follows:  
<P> 
  
  
 <tt>  Comm&amp; Comm::Clone() const = 0 <BR></tt>   
 <tt>  Intracomm&amp; Intracomm::Clone() const <BR></tt>   
 <tt>  Intercomm&amp; Intercomm::Clone() const <BR></tt>   
 <tt>  Cartcomm&amp; Cartcomm::Clone() const <BR></tt>   
 <tt>  Graphcomm&amp; Graphcomm::Clone() const <BR></tt>   
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
<tt> Clone()</tt> provides the ``virtual dup'' functionality that is  
  expected by C++ programmers and library writers.  Since  
  <tt> Clone()</tt> returns a new object by reference, users are  
  responsible for eventually deleting the object.  A new name is  
  introduced rather than changing the functionality of <tt> Dup()</tt>.  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Within their class declarations, prototypes for <tt> Clone()</tt> and  
  <tt> Dup()</tt> would look like the following:  
<BR> 
<pre><tt>namespace MPI { 
  class Comm { 
     virtual Comm&amp; Clone() const = 0; 
  }; 
  class Intracomm : public Comm { 
     Intracomm Dup() const { ... }; 
     virtual Intracomm&amp; Clone() const { ... }; 
  }; 
  class Intercomm : public Comm { 
     Intercomm Dup() const { ... }; 
     virtual Intercomm&amp; Clone() const { ... }; 
  }; 
  // Cartcomm and Graphcomm are similarly defined 
}; 
</tt></pre> 
Compilers that do not support the variable return type feature of  
  virtual functions may return a reference to <tt> Comm</tt>.  Users can  
  cast to the appropriate type as necessary.  
 (<em> End of advice to implementors.</em>) <BR> 
  
  
  
<P> 

<P>
<HR>
<A HREF="node229.htm#Node229"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node223.htm#Node223"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node231.htm#Node231"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node223.htm#Node223"> C++</a>
<b>Next: </b><A HREF="node231.htm#Node231"> Exceptions</a>
<b>Previous: </b><A HREF="node229.htm#Node229"> C++ Datatypes</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
