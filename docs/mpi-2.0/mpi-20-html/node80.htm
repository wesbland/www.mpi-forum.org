<HTML>
<!-- This file was generated by tohtml from misc-2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>Distributed Array Datatype Constructor</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node80">4.14.5. Distributed Array Datatype Constructor</a></H2>
<A HREF="node79.htm#Node79"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node75.htm#Node75"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node81.htm#Node81"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node75.htm#Node75"> New Datatype Manipulation Functions</a>
<b>Next: </b><A HREF="node81.htm#Node81"> New Predefined Datatypes</a>
<b>Previous: </b><A HREF="node79.htm#Node79"> Subarray Datatype Constructor</a>
<P>
  
  
<P> 
The distributed array type constructor supports  
HPF-like [<a href="node250.htm#-Bib12">12</a>] data distributions.  
However, unlike in HPF, the storage order may be specified for C arrays  
as well as for Fortran arrays.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
One can create an HPF-like file view using this type constructor  
as follows.  
Complementary filetypes are created by having every process of a group  
call this constructor with identical arguments  
(with the exception of  rank which should be set appropriately).  
These filetypes (along with identical  disp and  etype)  
are then used to define the view (via  MPI_FILE_SET_VIEW).  
Using this view,  
a collective data access operation (with identical offsets)  
will yield an HPF-like distribution pattern.  
 (<em> End of advice to users.</em>) <BR> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_DARRAY(size, rank, ndims, array_of_gsizes,   
     array_of_distribs,  array_of_dargs,  
     array_of_psizes, order, oldtype, newtype)</TD></TR>  
<TR><TD> IN size</TD><TD>size of process group (positive integer)</TD></TR>  
<TR><TD> IN rank</TD><TD>rank in process group (nonnegative integer)</TD></TR>  
<TR><TD> IN ndims</TD><TD>number of array dimensions  
                        as well as process grid dimensions  
                        (positive integer)</TD></TR>  
<TR><TD> IN array_of_gsizes</TD><TD>number of elements of type  oldtype  
                         in each dimension of global array  
                        (array of positive integers)</TD></TR>  
<TR><TD> IN array_of_distribs</TD><TD>distribution of array in each dimension  
                        (array of state)</TD></TR>  
<TR><TD> IN array_of_dargs</TD><TD>distribution argument in each dimension  
                        (array of positive integers)</TD></TR>  
<TR><TD> IN array_of_psizes</TD><TD>size of process grid in each dimension  
                        (array of positive integers)</TD></TR>  
<TR><TD> IN order</TD><TD>array storage order flag (state)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
  
 <tt> int MPI_Type_create_darray(int size, int rank, int ndims, int array_of_gsizes[], int array_of_distribs[], int array_of_dargs[], int array_of_psizes[], int order, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
  
 <tt> MPI_TYPE_CREATE_DARRAY(SIZE, RANK, NDIMS, ARRAY_OF_GSIZES, ARRAY_OF_DISTRIBS, ARRAY_OF_DARGS, ARRAY_OF_PSIZES, ORDER, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER SIZE, RANK, NDIMS, ARRAY_OF_GSIZES(*), ARRAY_OF_DISTRIBS(*), ARRAY_OF_DARGS(*), ARRAY_OF_PSIZES(*), ORDER, OLDTYPE, NEWTYPE, IERROR <BR></tt>  
 <tt> MPI::Datatype MPI::Datatype::Create_darray(int size, int rank, int ndims, const int array_of_gsizes[], const int array_of_distribs[], const int array_of_dargs[], const int array_of_psizes[], int order) const <BR></tt>  
  
<P> 
 MPI_TYPE_CREATE_DARRAY can be used to generate  
the datatypes corresponding to the distribution  
of an  ndims-dimensional array of  oldtype elements  
  
onto  
  
an  ndims-dimensional grid of logical processes.  
  
Unused dimensions of  array_of_psizes should be set to 1.  
  
  
(See Example <a href="node80.htm#Node80">Distributed Array Datatype Constructor 
</a>.)  
  
For a call to  MPI_TYPE_CREATE_DARRAY to be correct,  
the equation <I>prod<SUB>i=0</SUB><SUP>ndims-1</SUP> array_of_psizes[i] = size </I>  
must be satisfied.  
The ordering of processes in the process grid is assumed to be  
row-major, as in the case of virtual Cartesian process topologies  
in  MPI-1.  
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
For both Fortran and C arrays, the ordering of processes in the  
process grid is assumed to be row-major. This is consistent with the  
ordering used in virtual Cartesian process topologies in  MPI-1.  
To create such virtual process topologies, or to find the coordinates  
of a process in the process grid, etc., users may use the  
corresponding functions provided in  MPI-1.  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
Each dimension of the array   
  
can be  
  
distributed in one of three ways:  
<ul> 
 
<li> MPI_DISTRIBUTE_BLOCK     - Block distribution  
 
<li> MPI_DISTRIBUTE_CYCLIC - Cyclic distribution  
 
<li> MPI_DISTRIBUTE_NONE - Dimension not distributed.  
</ul> 
<BR> 
The constant  MPI_DISTRIBUTE_DFLT_DARG specifies  
a default distribution argument.  
  
The distribution argument for a dimension that is not distributed  
is ignored.  
For any dimension <I>i</I> in which the distribution  
is  MPI_DISTRIBUTE_BLOCK,  
it erroneous to specify  
 array_of_dargs[i] <I>*</I>  array_of_psizes[i]  
<I>&lt;</I>  array_of_gsizes[i].  
  
<P> 
For example, the HPF layout <tt> ARRAY(CYCLIC(15))</tt>  
corresponds to  MPI_DISTRIBUTE_CYCLIC  
with a distribution argument of 15, and the HPF layout ARRAY(BLOCK)  
  
corresponds to  
 MPI_DISTRIBUTE_BLOCK with a distribution argument of  
 MPI_DISTRIBUTE_DFLT_DARG.  
<P> 
The  order argument is used as in  MPI_TYPE_CREATE_SUBARRAY to  
specify the storage order.  
  
  
Therefore, arrays described by this type constructor may be  
stored in Fortran (column-major) or C (row-major) order.  
Valid values for  order are  
 MPI_ORDER_FORTRAN and  MPI_ORDER_C.  
<P> 
This routine creates a new  MPI datatype with a typemap defined in  
terms of a function called ``cyclic()'' (see below).  
<P> 
Without loss of generality, it suffices to define the typemap  
for the  MPI_DISTRIBUTE_CYCLIC case where  
 MPI_DISTRIBUTE_DFLT_DARG is not used.  
<P> 
 MPI_DISTRIBUTE_BLOCK and  MPI_DISTRIBUTE_NONE  
can be reduced to the  MPI_DISTRIBUTE_CYCLIC case  
for dimension <I>i</I> as follows.  
<P> 
 MPI_DISTRIBUTE_BLOCK with  
 array_of_dargs[i] equal to  MPI_DISTRIBUTE_DFLT_DARG  
is equivalent to  
 MPI_DISTRIBUTE_CYCLIC  
with  array_of_dargs[i] set to  
<p><I> 
(mpiargarray_of_gsizes[i] + mpiargarray_of_psizes[i] - 1) 
        / mpiargarray_of_psizes[i]. 
</I><p>  
If  array_of_dargs[i] is not  MPI_DISTRIBUTE_DFLT_DARG,  
then  MPI_DISTRIBUTE_BLOCK and  MPI_DISTRIBUTE_CYCLIC  
are equivalent.  
<P> 
 MPI_DISTRIBUTE_NONE is equivalent to   
 MPI_DISTRIBUTE_CYCLIC  
with  array_of_dargs[i] set to  array_of_gsizes[i].  
<P> 
Finally,   
 MPI_DISTRIBUTE_CYCLIC with  
 array_of_dargs[i] equal to  MPI_DISTRIBUTE_DFLT_DARG  
is equivalent to  
 MPI_DISTRIBUTE_CYCLIC with  
 array_of_dargs[i] set to 1.  
<P> 
For  MPI_ORDER_FORTRAN,  
an  ndims-dimensional distributed array ( newtype)  
is defined by the following code fragment:  
<P> 
<BR> 
<pre><tt>    oldtype[0] = oldtype; 
    for ( i = 0; i &lt; ndims; i++ ) { 
       oldtype[i+1] = cyclic(array_of_dargs[i], 
                             array_of_gsizes[i], 
                             r[i],  
                             array_of_psizes[i], 
                             oldtype[i]); 
    } 
    newtype = oldtype[ndims]; 
</tt></pre> 
For  MPI_ORDER_C, the code is:  
<P> 
<BR> 
<pre><tt>    oldtype[0] = oldtype; 
    for ( i = 0; i &lt; ndims; i++ ) { 
       oldtype[i + 1] = cyclic(array_of_dargs[ndims - i - 1],  
                               array_of_gsizes[ndims - i - 1], 
                               r[ndims - i - 1],  
                               array_of_psizes[ndims - i - 1], 
                               oldtype[i]); 
    } 
    newtype = oldtype[ndims]; 
 
</tt></pre> 
where <I>r[i]</I> is the position of the process (with rank  rank)  
in the process grid at dimension <I>i</I>.  
The values of <I>r[i]</I> are given by the following code fragment:  
<P> 
<BR> 
<pre><tt>        t_rank = rank; 
        t_size = 1; 
        for (i = 0; i &lt; ndims; i++) 
                t_size *= array_of_psizes[i]; 
        for (i = 0; i &lt; ndims; i++) { 
            t_size = t_size / array_of_psizes[i]; 
            r[i] = t_rank / t_size; 
            t_rank = t_rank % t_size; 
        } 
</tt></pre> 
Let the typemap of  oldtype have the form:  
<I> 
{(type<SUB>0</SUB>,disp<SUB>0</SUB>),(type<SUB>1</SUB>,disp<SUB>1</SUB>),...,(type<SUB>n-1</SUB>,disp<SUB>n-1</SUB>)} 
</I>  
where <I>type<SUB>i</SUB></I> is a predefined  MPI datatype, and let <I>ex</I> be the  
extent of  oldtype.    
<P> 
Given the above, the function cyclic() is defined as follows:  
<P><IMG WIDTH=398 HEIGHT=480 SRC="img6.gif"><P>
where <I>count</I> is defined by this code fragment:  
<BR> 
<pre><tt>        nblocks = (gsize + (darg - 1)) / darg; 
        count = nblocks / psize; 
        left_over = nblocks - count * psize; 
        if (r &lt; left_over) 
            count = count + 1; 
</tt></pre> 
Here, <I>nblocks</I> is the number of blocks that must be   
distributed among the processors.  
Finally, <I>darg<SUB>last</SUB></I> is defined by this code fragment:  
<BR> 
<pre><tt>        if ((num_in_last_cyclic = gsize % (psize * darg)) == 0) 
             darg_last = darg; 
        else 
             darg_last = num_in_last_cyclic - darg * r; 
             if (darg_last &gt; darg) 
                    darg_last = darg; 
             if (darg_last &lt;= 0) 
                    darg_last = darg; 
</tt></pre> 
  
<P> 
<BR><b> Example</b>  
Consider generating the filetypes corresponding to the HPF distribution:  
  
<BR> 
<pre><tt>      &lt;oldtype&gt; FILEARRAY(100, 200, 300) 
!HPF$ PROCESSORS PROCESSES(2, 3) 
!HPF$ DISTRIBUTE FILEARRAY(CYCLIC(10), *, BLOCK) ONTO PROCESSES 
</tt></pre> 
This can be achieved by the following Fortran code,  
assuming there will be six processes attached to the run:  
<BR> 
<pre><tt>    ndims = 3 
    array_of_gsizes(1) = 100 
    array_of_distribs(1) = MPI_DISTRIBUTE_CYCLIC 
    array_of_dargs(1) = 10 
    array_of_gsizes(2) = 200 
    array_of_distribs(2) = MPI_DISTRIBUTE_NONE 
    array_of_dargs(2) = 0 
    array_of_gsizes(3) = 300 
    array_of_distribs(3) = MPI_DISTRIBUTE_BLOCK 
    array_of_dargs(3) = MPI_DISTRIBUTE_DFLT_ARG 
    array_of_psizes(1) = 2 
    array_of_psizes(2) = 1 
    array_of_psizes(3) = 3 
    call MPI_COMM_SIZE(MPI_COMM_WORLD, size, ierr) 
    call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr) 
    call MPI_TYPE_CREATE_DARRAY(size, rank, ndims, array_of_gsizes, &amp; 
         array_of_distribs, array_of_dargs, array_of_psizes,        &amp; 
         MPI_ORDER_FORTRAN, oldtype, newtype, ierr) 
</tt></pre> 
  
<P> 
  
<P> 

<P>
<HR>
<A HREF="node79.htm#Node79"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node75.htm#Node75"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node81.htm#Node81"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node75.htm#Node75"> New Datatype Manipulation Functions</a>
<b>Next: </b><A HREF="node81.htm#Node81"> New Predefined Datatypes</a>
<b>Previous: </b><A HREF="node79.htm#Node79"> Subarray Datatype Constructor</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
