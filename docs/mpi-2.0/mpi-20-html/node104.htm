<HTML>
<!-- This file was generated by tohtml from dynamic-2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>Name Publishing</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node104">5.4.4. Name Publishing</a></H2>
<A HREF="node103.htm#Node103"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node100.htm#Node100"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node105.htm#Node105"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node100.htm#Node100"> Establishing Communication</a>
<b>Next: </b><A HREF="node105.htm#Node105"> Reserved Key Values</a>
<b>Previous: </b><A HREF="node103.htm#Node103"> Client Routines</a>
<P>
The routines in this section provide a mechanism for  
publishing names. A ( service_name,  port_name)  
pair is published by the server, and may be retrieved  
by a client using the  service_name only.   
An  MPI implementation defines the <em> scope</em> of the  service_name,  
that is, the domain over which the  service_name   
can be retrieved. If the domain is the empty set, that is,   
if no client can retrieve the information, then  
we say that name publishing is not supported.   
Implementations should document how the scope  
is determined. High quality implementations will  
give some control to users through the  info  
arguments to name publishing functions.   
  
Examples are given in the descriptions of individual functions.   
  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_PUBLISH_NAME(service_name, info, port_name)</TD></TR>  
<TR><TD> IN service_name</TD><TD>a service name to associate with the port (string)</TD></TR>  
<TR><TD> IN info</TD><TD>implementation-specific information (handle)</TD></TR>  
<TR><TD> IN port_name</TD><TD>a port name (string)</TD></TR>  
</TABLE>  
  
 <tt> int MPI_Publish_name(char *service_name, MPI_Info info, char *port_name) <BR></tt>  
  
 <tt> MPI_PUBLISH_NAME(SERVICE_NAME, INFO, PORT_NAME, IERROR)<BR> INTEGER INFO, IERROR <BR>CHARACTER*(*) SERVICE_NAME, PORT_NAME <BR></tt>  
  
 <tt> void MPI::Publish_name(const char* service_name, const MPI::Info&amp; info, const char* port_name) <BR></tt>  
  
<P> 
This routine publishes the pair ( port_name,  
 service_name) so that an application may retrieve a  
system-supplied  port_name using a well-known  
 service_name.  
<P> 
The implementation must define the <em>  
scope</em> of a published service name, that is, the domain over which the  
service name is unique, and conversely, the domain over which the  
(port name, service name) pair may be retrieved.  For instance, a  
service name may be unique to a job  (where job is defined by a  
distributed operating system or batch scheduler), unique to a machine,  
or unique to a Kerberos realm.    
The scope may depend on the  info argument to  MPI_PUBLISH_NAME.  
<P> 
 MPI permits publishing  more than one  service_name  
for a single  port_name.  On the other hand,   
  
if  service_name has already been published  
within the scope determined by  info, the behavior of  MPI_PUBLISH_NAME  
  
is undefined. An  MPI implementation may, through a mechanism in  
the  info argument  
to  MPI_PUBLISH_NAME,  provide a way to allow  
multiple servers with the same service in the same  
scope. In this case, an implementation-defined policy will  
determine which of several port names is returned by  MPI_LOOKUP_NAME.  
<P> 
Note that while  service_name has a limited  
scope, determined by the implementation,  port_name  
always has global scope within the communication universe used  
by the implementation (i.e., it is globally unique).   
<P> 
 port_name should be the name of a port established  
by  MPI_OPEN_PORT and not yet deleted by   
 MPI_CLOSE_PORT. If it is not, the result is undefined.   
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
In some cases, an  MPI implementation may use a name service  
that a user can also access directly. In this case, a name  
published by  MPI could easily conflict with a name  
published by a user. In order to avoid such  
conflicts,  MPI implementations should mangle service names  
so that they are unlikely to conflict with user code that  
makes use of the same service. Such name mangling will  
of course be completely transparent to the user.   
<P> 
The following situation is problematic but unavoidable, if  
we want to allow implementations to use nameservers.   
Suppose there are multiple instances of ``ocean'' running  
on a machine. If the scope of a service name is confined to   
a job, then multiple oceans can coexist. If an implementation  
provides site-wide scope, however, multiple instances are  
not possible as all calls to  MPI_PUBLISH_NAME after  
the first may fail. There is no universal solution to this.  
<P> 
To handle these situations,   
a high quality implementation should make it possible to   
limit the domain over which names are published.   
 (<em> End of advice to implementors.</em>) <BR> 
  
<TABLE><TR><TD COLSPAN=2>MPI_UNPUBLISH_NAME(service_name, info, port_name)</TD></TR>  
<TR><TD> IN service_name</TD><TD>a service name (string)</TD></TR>  
<TR><TD> IN info</TD><TD>implementation-specific information (handle)</TD></TR>  
<TR><TD> IN port_name</TD><TD>a port name (string)</TD></TR>  
</TABLE>  
  
 <tt> int MPI_Unpublish_name(char *service_name, MPI_Info info, char *port_name) <BR></tt>  
  
 <tt> MPI_UNPUBLISH_NAME(SERVICE_NAME, INFO, PORT_NAME, IERROR)<BR> INTEGER INFO, IERROR <BR>CHARACTER*(*) SERVICE_NAME, PORT_NAME <BR></tt>  
  
 <tt> void MPI::Unpublish_name(const char* service_name, const MPI::Info&amp; info, const char* port_name) <BR></tt>  
  
  
<P> 
This routine unpublishes a service name that has been previously  
  
published.  Attempting to unpublish a name that has not been published  
or has already been unpublished is erroneous and is indicated by the error class  
  
 MPI_ERR_SERVICE.  
<P> 
  
All published names must be unpublished before the corresponding  
port is closed and before the publishing process exits.  
  
The behavior of  MPI_UNPUBLISH_NAME is implementation dependent   
when a process tries to unpublish a name that it did not publish.  
<P> 
  
If the  info argument was used with  
 MPI_PUBLISH_NAME to tell the implementation  
how to publish names, the implementation may require that  
 info passed to  MPI_UNPUBLISH_NAME contain information   
to tell the implementation how to unpublish a name.  
  
<P> 
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_LOOKUP_NAME(service_name, info, port_name)</TD></TR>  
<TR><TD> IN service_name</TD><TD>a service name (string)</TD></TR>  
<TR><TD> IN info</TD><TD>implementation-specific information (handle)</TD></TR>  
<TR><TD> OUT port_name</TD><TD>a port name (string)</TD></TR>  
</TABLE>  
  
 <tt> int MPI_Lookup_name(char *service_name, MPI_Info info, char *port_name) <BR></tt>  
  
 <tt> MPI_LOOKUP_NAME(SERVICE_NAME, INFO, PORT_NAME, IERROR)<BR> CHARACTER*(*) SERVICE_NAME, PORT_NAME <BR>INTEGER INFO, IERROR <BR></tt>  
  
 <tt> void MPI::Lookup_name(const char* service_name, const MPI::Info&amp; info, char* port_name) <BR></tt>  
  
<P> 
This function retrieves a  port_name published  
by  MPI_PUBLISH_NAME with  service_name.   
If  service_name has not been published, it raises  
an error in the error class  MPI_ERR_NAME. The application  
must supply a  port_name buffer large enough   
to hold the largest possible port name (see discussion above under  
 MPI_OPEN_PORT).  
<P> 
If an implementation allows multiple entries with  
the same  service_name within the same scope,   
a particular  port_name is chosen in a way  
determined by the implementation.   
<P> 
If the  info argument was used with  
 MPI_PUBLISH_NAME to tell the implementation  
how to publish names, a similar  info argument  
may be required for  MPI_LOOKUP_NAME.  
<P> 

<P>
<HR>
<A HREF="node103.htm#Node103"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node100.htm#Node100"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node105.htm#Node105"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node100.htm#Node100"> Establishing Communication</a>
<b>Next: </b><A HREF="node105.htm#Node105"> Reserved Key Values</a>
<b>Previous: </b><A HREF="node103.htm#Node103"> Client Routines</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
