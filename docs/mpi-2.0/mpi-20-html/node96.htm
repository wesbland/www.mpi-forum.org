<HTML>
<!-- This file was generated by tohtml from dynamic-2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>Starting Multiple Executables and Establishing Communication</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node96">5.3.3. Starting Multiple Executables and Establishing Communication</a></H2>
<A HREF="node95.htm#Node95"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node93.htm#Node93"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node97.htm#Node97"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node93.htm#Node93"> Process Manager Interface</a>
<b>Next: </b><A HREF="node97.htm#Node97"> Reserved Keys</a>
<b>Previous: </b><A HREF="node95.htm#Node95"> Starting Processes and Establishing Communication</a>
<P>
  
<P> 
While  MPI_COMM_SPAWN is sufficient for most cases, it does  
not allow the spawning of multiple binaries, or of the same  
binary with multiple sets of arguments.   
The following routine spawns multiple binaries or the same binary  
with multiple sets of arguments, establishing communication with them   
and placing them in the same   MPI_COMM_WORLD.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_SPAWN_MULTIPLE(count,  
array_of_commands, array_of_argv, array_of_maxprocs,   
array_of_info, root, comm, intercomm, array_of_errcodes)</TD></TR>  
  
<TR><TD> IN count</TD><TD>number of commands   
(positive integer, significant to  MPI only at root --- see advice to users)</TD></TR>  
  
<TR><TD> IN array_of_commands</TD><TD>programs to be executed  
(array of strings, significant only at root)</TD></TR>  
<TR><TD> IN array_of_argv</TD><TD>arguments for  commands (array  
of array of strings, significant only at root)</TD></TR>  
<TR><TD> IN array_of_maxprocs</TD><TD>maximum number of processes to start for   
each command (array of integer, significant only at root)</TD></TR>  
<TR><TD> IN array_of_info</TD><TD>info objects telling the runtime system where  
and how to start processes (array of handles, significant only at root)</TD></TR>  
<TR><TD> IN root</TD><TD>rank of process in which previous arguments are   
examined (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>intracommunicator containing group of spawning processes (handle)</TD></TR>  
<TR><TD> OUT intercomm</TD><TD>intercommunicator between original group and  
newly spawned group (handle)</TD></TR>  
<TR><TD> OUT array_of_errcodes</TD><TD>one error code per process  
(array of integer)</TD></TR>  
</TABLE>  
 <tt> int MPI_Comm_spawn_multiple(int count, char *array_of_commands[], char **array_of_argv[], int array_of_maxprocs[], MPI_Info array_of_info[], int root, MPI_Comm comm, MPI_Comm *intercomm, int array_of_errcodes[]) <BR></tt>   
 <tt> MPI_COMM_SPAWN_MULTIPLE(COUNT, ARRAY_OF_COMMANDS, ARRAY_OF_ARGV, ARRAY_OF_MAXPROCS, ARRAY_OF_INFO, ROOT, COMM, INTERCOMM, ARRAY_OF_ERRCODES, IERROR)<BR> INTEGER COUNT, ARRAY_OF_INFO(*), ARRAY_OF_MAXPROCS(*), ROOT, COMM, INTERCOMM, ARRAY_OF_ERRCODES(*), IERROR <BR>CHARACTER*(*) ARRAY_OF_COMMANDS(*), ARRAY_OF_ARGV(COUNT, *) <BR></tt>  
 <tt> MPI::Intercomm MPI::Intracomm::Spawn_multiple(int count, const char* array_of_commands[], const char** array_of_argv[], const int array_of_maxprocs[], const MPI::Info array_of_info[], int root, int array_of_errcodes[]) <BR></tt>  
  
 <tt> MPI::Intercomm MPI::Intracomm::Spawn_multiple(int count, const char* array_of_commands[], const char** array_of_argv[], const int array_of_maxprocs[], const MPI::Info array_of_info[], int root) <BR></tt>  
  
<P> 
 MPI_COMM_SPAWN_MULTIPLE is identical to  MPI_COMM_SPAWN except  
that there are multiple executable specifications. The first argument,   
 count, gives the number of specifications. Each of the  
next four arguments are simply arrays of the corresponding arguments  
in  MPI_COMM_SPAWN.   
For the Fortran version of  array_of_argv, the element  
 array_of_argv(i,j) is the  jth argument  
to command number  i.   
  
 
<BR> 
<em> Rationale.</em>  
<P> 
This may seem backwards to   
Fortran programmers who are familiar with Fortran's   
column-major ordering. However, it is necessary to do   
it this way to allow  MPI_COMM_SPAWN to sort out  
arguments. Note that the leading dimension of   
 array_of_argv <em> must</em> be the same as  
 count.   
 (<em> End of rationale.</em>) <BR> 
  
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
The argument  count is interpreted by  MPI only at the root,   
as is  array_of_argv. Since the leading dimension  
of  array_of_argv is  count, a non-positive  
value of  count at a non-root node could theoretically  
cause a runtime bounds check error, even though   
 array_of_argv should be ignored by the   
subroutine. If this happens, you should explicitly   
supply a reasonable value of  count on the non-root  
nodes.   
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
In any language, an application may use the constant  
 MPI_ARGVS_NULL (which is likely to be <tt> (char ***)0</tt> in C)  
to specify that no arguments should be passed to any  
commands. The effect of setting individual elements of  array_of_argv  
to  MPI_ARGV_NULL is not defined. To specify arguments  
for some commands but not others, the commands without  
arguments should have a corresponding  argv whose  
first element is null (<tt> (char *)0</tt> in C and empty string in Fortran).   
<P> 
All of the spawned processes have the same  
 MPI_COMM_WORLD. Their ranks in  MPI_COMM_WORLD  
correspond directly to the order in which the commands are  
specified in  MPI_COMM_SPAWN_MULTIPLE. Assume  
that <I>m<SUB>1</SUB></I> processes are generated by the first command, <I>m<SUB>2</SUB></I> by   
the second, etc.   
The processes  
corresponding to the first command have ranks <I>0, 1, ..., 
m<SUB>1</SUB>-1</I>. The processes in the second command have ranks  
<I>m<SUB>1</SUB>, m<SUB>1</SUB>+1, ..., m<SUB>1</SUB>+m<SUB>2</SUB>-1</I>. The processes in the third  
have ranks <I>m<SUB>1</SUB>+m<SUB>2</SUB>, m<SUB>1</SUB>+m<SUB>2</SUB>+1, ..., m<SUB>1</SUB>+m<SUB>2</SUB>+m<SUB>3</SUB>-1</I>, etc.   
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Calling  MPI_COMM_SPAWN multiple times  
would create many sets of children with different  MPI_COMM_WORLDs  
whereas  MPI_COMM_SPAWN_MULTIPLE creates children with  
a single  MPI_COMM_WORLD, so the two methods  
are not completely equivalent.   
There are also two performance-related reasons why,   
if you need to spawn multiple executables, you may want to  use  
 MPI_COMM_SPAWN_MULTIPLE instead of calling  MPI_COMM_SPAWN  
several times. First, spawning several  
things at once may be faster than spawning them sequentially. Second,   
in some implementations,   
communication between processes spawned at the same time may be  
faster than communication between processes spawned separately.   
 (<em> End of advice to users.</em>) <BR> 
The  array_of_errcodes argument is 1-dimensional  
array of size <IMG WIDTH=43 HEIGHT=13 SRC="img9.gif">
,   
where <I>n<SUB>i</SUB></I> is the <I>i</I>th element of  array_of_maxprocs.   
Command number <I>i</I> corresponds to the <I>n<SUB>i</SUB></I> contiguous  
slots in this array from element <IMG WIDTH=37 HEIGHT=16 SRC="img10.gif">
  
to <IMG WIDTH=63 HEIGHT=19 SRC="img11.gif">
.  
Error codes are treated  
as for  MPI_COMM_SPAWN.  
<P> 
<BR><b> Example</b> Examples of  array_of_argv in C and Fortran  
<P> 
 To run the program ``ocean'' with arguments ``-gridfile'' and  
``ocean1.grd'' and the program ``atmos'' with argument ``atmos.grd''  
in C:  
<BR> 
<pre><tt>       char *array_of_commands[2] = {"ocean", "atmos"}; 
       char **array_of_argv[2]; 
       char *argv0[] = {"-gridfile", "ocean1.grd", (char *)0}; 
       char *argv1[] = {"atmos.grd", (char *)0}; 
       array_of_argv[0] = argv0; 
       array_of_argv[1] = argv1; 
       MPI_Comm_spawn_multiple(2, array_of_commands, array_of_argv, ...); 
</tt></pre> 
Here's how you do it in Fortran:  
<BR> 
<pre><tt>       CHARACTER*25 commands(2), array_of_argv(2, 3) 
       commands(1) = ' ocean ' 
       array_of_argv(1, 1) = ' -gridfile ' 
       array_of_argv(1, 2) = ' ocean1.grd' 
       array_of_argv(1, 3) = ' ' 
 
       commands(2) = ' atmos ' 
       array_of_argv(2, 1) = ' atmos.grd ' 
       array_of_argv(2, 2) = ' ' 
 
       call MPI_COMM_SPAWN_MULTIPLE(2, commands, array_of_argv, ...) 
</tt></pre> 
  
<P> 

<P>
<HR>
<A HREF="node95.htm#Node95"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node93.htm#Node93"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node97.htm#Node97"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node93.htm#Node93"> Process Manager Interface</a>
<b>Next: </b><A HREF="node97.htm#Node97"> Reserved Keys</a>
<b>Previous: </b><A HREF="node95.htm#Node95"> Starting Processes and Establishing Communication</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
