<HTML>
<!-- This file was generated by tohtml from misc-1.2.tex -->
<!-- with the command
tohtml -default -endpage ../mpi2-forum-tail.htm -basedef ../mpi2defs.txt -numbers -indexname myindex -dosnl -htables -quietlatex mpi2-report.tex 
-->
<TITLE>Minor Corrections</TITLE>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node40">3.2.10. Minor Corrections</a></H2>
<A HREF="node39.htm#Node39"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node30.htm#Node30"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node41.htm#Node41"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node30.htm#Node30"> MPI-1.0 and MPI-1.1 Clarifications</a>
<b>Next: </b><A HREF="node41.htm#Node41"> Miscellany</a>
<b>Previous: </b><A HREF="node39.htm#Node39"> Clarification of  MPI_PROBE and  MPI_IPROBE</a>
<P>
  
<P> 
The following corrections to  MPI-1.1 are (all page and line numbers  
are for the June 12, 1995 version without changebars):  
<P> 
<ul> 
 
<li>Page 11, line 36 reads <BR>  
 MPI_ADDRESS <BR>  
but should read <BR>  
 MPI_ADDRESS_TYPE <BR>  
<P> 
<P> 
 
<li>Page 19, lines 1--2 reads <BR>  
for (64 bit) C integers declared to be of type  longlong int <BR>  
but should read <BR>  
  
for C integers declared to be of type  long long <BR>  
  
<P> 
<P> 
 
<li>Page 40, line 48 should have the following text added: <BR>  
<P> 
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
To prevent problems with the argument copying and register optimization done  
  by Fortran compilers, please note the hints in subsections ``Problems Due to  
  Data Copying and Sequence Association,'' and ``A Problem with  
  Register Optimization'' in Section <a href="node236.htm#Node241">A Problem with Register Optimization 
</a> of the  MPI-2 Standard,  
  .  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
<P> 
<P> 
<P> 
 
<li>Page 41, lines 16--18 reads <BR>  
A <b> empty</b> status is a status which is set to return  tag =  
MPI_ANY_TAG,  source = MPI_ANY_SOURCE, and is also  
internally configured so that calls to  MPI_GET_COUNT and  
 MPI_GET_ELEMENTS return  count = 0. <BR>  
but should read <BR>  
A <b> empty</b> status is a status which is set to return  tag =  
MPI_ANY_TAG,  source = MPI_ANY_SOURCE,  error =  
MPI_SUCCESS,  and is also internally configured so that calls to  
 MPI_GET_COUNT and  MPI_GET_ELEMENTS return  
 count = 0  
and  MPI_TEST_CANCELLED returns  false.  
<BR>  
<P> 
<P> 
  
 
<li>Page 52, lines 46--48 read <BR>  
<BR> 
<pre><tt>100            CALL MPI_RECV(i, 1, MPI_INTEGER, 0, 0, status, ierr) 
          ELSE 
200            CALL MPI_RECV(x, 1, MPI_REAL, 1, 0, status, ierr) 
</tt></pre> 
but should read <BR>  
<BR> 
<pre><tt>100            CALL MPI_RECV(i, 1, MPI_INTEGER, 0, 0, comm, status, ierr) 
          ELSE 
200            CALL MPI_RECV(x, 1, MPI_REAL, 1, 0, comm, status, ierr) 
</tt></pre> 
  
 
<li>Page 53, lines 18--23 read <BR>  
<BR> 
<pre><tt>100                CALL MPI_RECV(i, 1, MPI_INTEGER, MPI_ANY_SOURCE, 
                                 0, status, ierr) 
              ELSE 
200                CALL MPI_RECV(x, 1, MPI_REAL, MPI_ANY_SOURCE, 
                                 0, status, ierr) 
</tt></pre> 
but should read <BR>  
<BR> 
<pre><tt>100                CALL MPI_RECV(i, 1, MPI_INTEGER, MPI_ANY_SOURCE, 
                                 0, comm, status, ierr) 
              ELSE 
200                CALL MPI_RECV(x, 1, MPI_REAL, MPI_ANY_SOURCE, 
                                 0, comm, status, ierr) 
</tt></pre> 
  
<P> 
 
<li>Page 59, line 3 should have the following text added: <BR>  
<P> 
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
To prevent problems with the argument copying and register optimization done  
  by Fortran compilers, please note the hints in subsections ``Problems Due to  
  Data Copying and Sequence Association,'' and ``A Problem with  
  Register Optimization'' in Section <a href="node236.htm#Node241">A Problem with Register Optimization 
</a> of the  MPI-2 Standard,  
  .  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
<P> 
  
 
<li>Page 59, lines 42--45 read <BR>  
 <tt> int   
MPI_Sendrecv(void *sendbuf, int sendcount, MPI_Datatype sendtype, <BR>  
int dest, int sendtag, void *recvbuf, int recvcount, <BR>  
MPI_Datatype recvtype, int source, MPI_Datatype recvtag, <BR>  
MPI_Comm comm, MPI_Status *status)  
 <BR></tt>  
but should read <BR>  
 <tt> int   
MPI_Sendrecv(void *sendbuf, int sendcount, MPI_Datatype sendtype, <BR>  
int dest, int sendtag, void *recvbuf, int recvcount, <BR>  
MPI_Datatype recvtype, int source, int recvtag, <BR>  
MPI_Comm comm, MPI_Status *status)  
 <BR></tt>  
<P> 
  
<P> 
  
 
<li>Page 60, line 3 reads <BR>  
 <tt> SOURCE, RECV  
TAG, COMM, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
but should read <BR>  
 <tt> SOURCE, RECVTAG, COMM, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
<P> 
  
<P> 
 
<li>Page 70, line 16 should have the following text added: <BR>  
<P> 
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
To prevent problems with the argument copying and register optimization done  
  by Fortran compilers, please note the hints in subsections ``Problems Due to  
  Data Copying and Sequence Association,'' and ``A Problem with  
  Register Optimization'' in Section <a href="node236.htm#Node241">A Problem with Register Optimization 
</a> of the  MPI-2 Standard,  
  .  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
<P> 
 
<li>Page 71, line 10 reads <BR>  
and do not affect the the content of a message <BR>  
but should read <BR>  
and do not affect the content of a message <BR>  
<P> 
<P> 
 
<li>Page 74, lines 39--45 read <BR>  
A datatype may specify overlapping entries. The use of such a  
datatype in a receive operation is erroneous. (This is erroneous even  
if the actual message received is short enough not to write any entry  
more than once.)  
<P> 
A datatype may specify overlapping entries.  If such a datatype is used  
in a receive operation, that is, if some part of the receive buffer  
is written more than once by the receive operation, then the  
call is erroneous.  
<P> 
The first part was an  MPI-1.1 addition.  The second part overlaps  
with it.  The old text will be removed so it now reads <BR>  
A datatype may specify overlapping entries. The use of such a  
datatype in a receive operation is erroneous. (This is erroneous even  
if the actual message received is short enough not to write any entry  
more than once.)  
<P> 
<P> 
 
<li>Page 75, line 24 should have the following text added:<BR>  
The  datatype argument should match the argument provided by the  
receive call that set the  status variable.  
<P> 
 
<li>Page 85, line 36 reads<BR>  
``specified by  outbuf and  outcount''<BR>  
but should read<BR>  
``specified by  outbuf and  outsize.''<BR>  
<P> 
 
<li>Page 90, line 3 reads <BR>  
MPI_Pack_size(count, MPI_CHAR, &amp;k2); <BR>  
but should read <BR>  
MPI_Pack_size(count, MPI_CHAR, comm, &amp;k2); <BR>  
<P> 
<P> 
 
<li>Page 90, line 10 reads <BR>  
MPI_Pack(chr, count, MPI_CHAR, &amp;lbuf, k, &amp;position, comm); <BR>  
but should read <BR>  
MPI_Pack(chr, count, MPI_CHAR, lbuf, k, &amp;position, comm); <BR>  
<P> 
<P> 
  
 
<li>Page 97, line 41 reads <BR>  
<p><I> 
 MPI_Recv(recvbuf+disp[i]&#183; extent(recvtype), recvcounts[i], 
recvtype, i, ...). 
</I><p>  
but should read <BR>  
<P><IMG WIDTH=401 HEIGHT=11 SRC="img0.gif"><P>
  
<P> 
  
<P> 
 
<li>Page 109, lines 26--27 and page 110, lines 28--29 reads <BR>  
The <tt> j</tt>th block of data sent from each process is received  
by every process and placed in the <tt> j</tt>th block of the  
buffer  recvbuf.<BR>  
but should read <BR>  
The block of data sent from the <tt> j</tt>th process is received  
by every process and placed in the <tt> j</tt>th block of the  
buffer  recvbuf.<BR>  
<P> 
  
<P> 
 
<li>Page 117, lines 22--23 reads <BR>  
MPI provides seven such predefined datatypes. <BR>  
but should read <BR>  
MPI provides nine such predefined datatypes. <BR>  
<BR>  
<P> 
  
<P> 
  
 
<li>Page 121, line 1 reads <BR>  
<BR> 
<pre><tt>FUNCTION USER_FUNCTION( INVEC(*), INOUTVEC(*), LEN, TYPE) 
</tt></pre> 
but should read <BR>  
<BR> 
<pre><tt>SUBROUTINE USER_FUNCTION(INVEC, INOUTVEC, LEN, TYPE) 
</tt></pre> 
  
<P> 
 
<li>Page 122, lines 35--36 read <BR>  
        
      
      
      
      
     MPI_OP_FREE( op)  
    <TR><TD> IN op</TD><TD> operation (handle) </TD></TR>  
<BR> 
  
but should read <BR>  
        
      
      
      
      
     MPI_OP_FREE( op)  
    <TR><TD> INOUT op</TD><TD> operation (handle) </TD></TR>  
<BR> 
  
<P> 
<P> 
 
<li>Page 125, line 1 reads <BR>  
CALL MPI_ALLREDUCE(sum, c, n, MPI_REAL, MPI_SUM, 0, comm, ierr) <BR>  
but should read <BR>  
CALL MPI_ALLREDUCE(sum, c, n, MPI_REAL, MPI_SUM, comm, ierr) <BR>  
<P> 
<P> 
  
 
<li>Page 141, lines 27--27 read <BR>  
<TABLE><TR><TD COLSPAN=2></TD></TR>  
<TR><TD> IN ranges</TD><TD> an array of integer triplets, of the  
form (first rank, last rank, stride) indicating ranks in  
 group of processes to be included in  newgroup</TD></TR>  
</TABLE>  
but should read <BR>  
<TABLE><TR><TD COLSPAN=2></TD></TR>  
<TR><TD> IN ranges</TD><TD>a one-dimensional array of integer triplets, of the  
form (first rank, last rank, stride) indicating ranks in  
 group of processes to be included in  newgroup</TD></TR>  
</TABLE>  
<P> 
  
<P> 
 
<li>Page 142, line 10 reads <BR>  
<TABLE><TR><TD COLSPAN=2></TD></TR>  
<TR><TD> IN n</TD><TD> number of elements in array ranks (integer)</TD></TR>  
</TABLE>  
but should read <BR>  
<TABLE><TR><TD COLSPAN=2></TD></TR>  
<TR><TD> IN n</TD><TD> number of triplets in array  ranges (integer)</TD></TR>  
</TABLE>  
<P> 
  
  
<P> 
 
<li>Page 194, lines 30--31 reads <BR>  
to the greatest possible, extent, <BR>  
but should read <BR>  
to the greatest possible extent, <BR>  
<P> 
  
<P> 
 
<li>Page 194, line 48 reads <BR>  
 MPI_ERRHANDLER_CREATE(FUNCTION, HANDLER, IERROR) <BR>  
but should read <BR>  
 MPI_ERRHANDLER_CREATE(FUNCTION, ERRHANDLER, IERROR) <BR>  
<P> 
  
<P> 
  
 
<li>Page 195, line 15 should have the following text added: <BR>  
In the Fortran language, the user routine should be of the form:  
<P> 
<BR> 
<pre><tt>SUBROUTINE HANDLER_FUNCTION(COMM, ERROR_CODE, .....) 
INTEGER COMM, ERROR_CODE 
</tt></pre> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Users are discouraged from using a Fortran  HANDLER_FUNCTION since the  
routine expects a variable number of arguments.  Some Fortran systems  
may allow this but some may fail to give the correct result or  
compile/link this code.  Thus, it will not, in general, be possible to  
create portable code with a Fortran  HANDLER_FUNCTION.  
 (<em> End of advice to users.</em>) <BR> 
  
  
<P> 
 
<li>Page 196, lines 1--2 reads <BR>  
        
      
      
      
      
     MPI_ERRHANDLER_FREE( errhandler )  
    <TR><TD> IN errhandler</TD><TD>MPI error handler (handle)</TD></TR>  
<BR> 
  
but should read <BR>  
        
      
      
      
      
     MPI_ERRHANDLER_FREE( errhandler )  
    <TR><TD> INOUT errhandler</TD><TD>MPI error handler (handle)</TD></TR>  
<BR> 
  
<P> 
  
<P> 
  
 
<li>Page 197, line 25 should have added:<BR>  
<P> 
An  MPI error class is a valid  MPI error code.  Specifically, the values  
defined for  MPI error classes are valid  MPI error codes.  
<P> 
  
  
<P> 
 
<li>Page 201, line 28 reads <BR>  
...of different language bindings is is done .... <BR>  
but should read <BR>  
...of different language bindings is done ....  
<P> 
  
<P> 
<P> 
<P> 
<P> 
<P> 
 
<li>Page 203, line 1 reads <BR>  
 <tt> MPI_PCONTROL(level) <BR></tt>  
but should read <BR>  
 <tt> MPI_PCONTROL(LEVEL) <BR></tt>  
<P> 
  
<P> 
 
<li>Page 210, line 44 reads <BR>  
 MPI_PENDING <BR>  
but should read <BR>  
 MPI_ERR_PENDING <BR>  
<P> 
  
<P> 
 
<li>Page 211, line 44 reads <BR>  
 MPI_DOUBLE_COMPLEX <BR>  
but should be moved to Page 212, line 22 since it is an optional  
Fortran datatype.  
<P> 
  
<P> 
 
<li>Page 212, add new lines of text at line 22 and line 25 to read: <BR>  
etc. <BR>  
Thus, the text will now read:<BR>  
<BR> 
<pre><tt>/* optional datatypes (Fortran) */ 
MPI_INTEGER1 
MPI_INTEGER2 
MPI_INTEGER4 
MPI_REAL2 
MPI_REAL4 
MPI_REAL8 
etc. 
 
/* optional datatypes (C) */ 
MPI_LONG_LONG_INT 
etc. 
</tt></pre> 
  
<P> 
 
<li>Page 213, line 28.  The following text should be added:<BR>  
<BR> 
<pre><tt>/* Predefined functions in C and Fortran */ 
MPI_NULL_COPY_FN 
MPI_NULL_DELETE_FN 
MPI_DUP_FN 
</tt></pre> 
  
<P> 
  
 
<li>Page 213, line 41. Add the line  
<BR> 
<pre><tt>MPI_Errhandler 
</tt></pre> 
  
<P> 
  
 
<li>Page 214, line 9 reads <BR>  
<BR> 
<pre><tt>FUNCTION USER_FUNCTION( INVEC(*), INOUTVEC(*), LEN, TYPE) 
</tt></pre> 
but should read <BR>  
<BR> 
<pre><tt>SUBROUTINE USER_FUNCTION( INVEC, INOUTVEC, LEN, TYPE) 
</tt></pre> 
  
<P> 
 
<li>Page 214, lines 14 and 15 read <BR>  
<BR> 
<pre><tt> PROCEDURE COPY_FUNCTION(OLDCOMM, KEYVAL, EXTRA_STATE, 
               ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERR) 
</tt></pre> 
but should read <BR>  
<BR> 
<pre><tt> SUBROUTINE COPY_FUNCTION(OLDCOMM, KEYVAL, EXTRA_STATE, 
               ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERR) 
</tt></pre> 
  
<P> 
 
<li>Page 214, line 21 reads <BR>  
<BR> 
<pre><tt>PROCEDURE DELETE_FUNCTION(COMM, KEYVAL, ATTRIBUTE_VAL, EXTRA_STATE, IERR) 
</tt></pre> 
but should read <BR>  
<BR> 
<pre><tt>SUBROUTINE DELETE_FUNCTION(COMM, KEYVAL, ATTRIBUTE_VAL, EXTRA_STATE, IERR) 
</tt></pre> 
  
  
<P> 
  
 
<li>Page 214, line 23 should have the following text added: <BR>  
The handler-function for error handlers should be declared like this:  
<P> 
<BR> 
<pre><tt>SUBROUTINE HANDLER_FUNCTION(COMM, ERROR_CODE, .....) 
INTEGER COMM, ERROR_CODE 
</tt></pre> 
  
  
<P> 
  
 
<li>Page 216, lines 4--7 read <BR>  
 <tt> int   
MPI_Sendrecv(void *sendbuf, int sendcount, MPI_Datatype sendtype, <BR>  
int dest, int sendtag, void *recvbuf, int recvcount, <BR>  
MPI_Datatype recvtype, int source, MPI_Datatype recvtag, <BR>  
MPI_Comm comm, MPI_Status *status)  
 <BR></tt>  
but should read <BR>  
 <tt> int   
MPI_Sendrecv(void *sendbuf, int sendcount, MPI_Datatype sendtype, <BR>  
int dest, int sendtag, void *recvbuf, int recvcount, <BR>  
MPI_Datatype recvtype, int source, int recvtag, <BR>  
MPI_Comm comm, MPI_Status *status)  
 <BR></tt>  
<P> 
  
  
<P> 
 
<li>Page 220, lines 19--20 reads <BR>  
 int double MPI_Wtime(void) <BR>  
 int double MPI_Wtick(void) <BR>  
but should read <BR>  
 double MPI_Wtime(void) <BR>  
 double MPI_Wtick(void) <BR>  
<P> 
  
<P> 
<P> 
<P> 
<P> 
<P> 
 
<li>Page 222, line 34 reads <BR>  
 INTEGER REQUEST, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR>  
but should read <BR>  
 INTEGER COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR>  
<P> 
  
<P> 
 
<li>Page 222, line 38 reads <BR>  
 INTEGER REQUEST, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR>  
but should read <BR>  
 INTEGER COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR>  
<P> 
  
<P> 
 
<li>Page 227, lines 19--20  reads <BR>  
 MPI_INTERCOMM_MERGE(INTERCOMM, HIGH, INTRACOMM, IERROR) <BR>  
  INTEGER INTERCOMM, INTRACOMM, IERROR  <BR>  
but should read <BR>  
 MPI_INTERCOMM_MERGE(INTERCOMM, HIGH, NEWINTRACOMM, IERROR) <BR>  
  INTEGER INTERCOMM, NEWINTRACOMM, IERROR  <BR>  
<P> 
  
<P> 
 
<li>Page 228, line 46 reads <BR>  
 MPI_ERRHANDLER_CREATE(FUNCTION, HANDLER, IERROR) <BR>  
but should read <BR>  
 MPI_ERRHANDLER_CREATE(FUNCTION, ERRHANDLER, IERROR) <BR>  
<P> 
  
<P> 
 
<li>Page 229, line 33  reads <BR>  
 <tt> MPI_PCONTROL(level) <BR></tt>  
but should read <BR>  
 <tt> MPI_PCONTROL(LEVEL) <BR></tt>  
<P> 
  
</ul> 
<BR> 
  
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
  
<P> 
  
  
  
<P> 

<P>
<HR>
<A HREF="node39.htm#Node39"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node30.htm#Node30"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node41.htm#Node41"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node30.htm#Node30"> MPI-1.0 and MPI-1.1 Clarifications</a>
<b>Next: </b><A HREF="node41.htm#Node41"> Miscellany</a>
<b>Previous: </b><A HREF="node39.htm#Node39"> Clarification of  MPI_PROBE and  MPI_IPROBE</a>
<P>
<HR>
Return to <A HREF="node306.htm">MPI-2 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/docs/mpi-11-html/node182.html">MPI 1.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 18, 1997<BR>
HTML Generated on September 10, 2001
</FONT>
</BODY>
</HTML>
