<HTML>
<HEAD>
<!-- This file was generated by tohtml from erratabuild.tex -->
<!-- with the command
tohtml -default -split -1 -nocontents erratabuild.tex 
-->
<TITLE>erratabuild.tex</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
  
  
  
  
<P> 
  
  
  
  
<P> 
  
<P> 
<HR><H1><A NAME="Node0">Errata for  MPI-2</a></H1>
This document was processed on Tue Mar  5 15:49:36 2002.  
  
<P> 
The known corrections to  MPI-2 are listed in this document.  All  
page and line numbers are for the official version of the  MPI-2  
document available from the  MPI Forum home page at <tt>  
http://www.mpi-forum.org</tt>.  Information on reporting mistakes in the  
 MPI documents is also located on the  MPI Forum home page.  
<P> 
This is a <b> DRAFT</b> and is not official.  
<P> 
<ul> 
  
 
<li>Page 24, lines 20-21 read <BR>  
 MPI_FINALIZE is collective on  MPI_COMM_WORLD.<BR>  
but should read <BR>  
 MPI_FINALIZE is collective over all connected processes.  
If no processes were spawned, accepted or connected then this means  
over  MPI_COMM_WORLD; otherwise it is collective over the  
union of all processes that have been and continue to be connected,   
as explained in Section 5.5.4.  
  
  
 
<li>Page 27, line 26 reads <BR>  
must be added to line 3 of page 54.<BR>  
but should read <BR>  
must be added to line 3 of page 52.  
  
  
  
 
<li>Add to page 36, after line 3  
<P> 
3.2.11 MPI_GET_COUNT with zero-length datatypes  
<BR>  
The value returned as the <tt> count</tt> argument of  
<tt> MPI_GET_COUNT</tt> for a datatype of length zero where zero bytes  
have been transferred is zero.  If the number of bytes transfered is  
greater than zero, <tt> MPI_UNDEFINED</tt> is returned.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
Zero-length datatypes may be created in a number of cases.  In MPI-2,  
an important case is <tt> MPI_TYPE_CREATE_DARRAY</tt>, where the  
definition of the particular darry results in an empty block on some  
MPI process.  Programs written in an SPMD style will not check for  
this special case and may want to use <tt> MPI_GET_COUNT</tt> to check  
the status.    
 (<em> End of rationale.</em>) <BR> 
  
  
  
 
<li>Add to page 36, after 3.2.11 (above)  
<P> 
3.2.12 MPI_GROUP_TRANSLATE_RANKS and MPI_PROC_NULL  
<P> 
<tt> MPI_PROC_NULL</tt> is a valid rank for input to  
<tt> MPI_GROUP_TRANSLATE_RANKS</tt>, which returns  
<tt> MPI_PROC_NULL</tt> as the translated rank.  
<P> 
  
  
 
<li>Page 51, after line 43, add  
<P> 
 <tt> MPI_Errhandler MPI_Errhandler_f2c(MPI_Fint errhandler) <BR></tt>  
 <tt> MPI_Fint MPI_Errhandler_c2f(MPI_Errhandler errhandler) <BR></tt>  
<P> 
These were overlooked.  
  
  
 
<li>Page 53, line 7 reads  
<BR> 
<pre><tt>void cpp_lib_call(MPI::Comm&amp; cpp_comm); 
</tt></pre> 
but should read  
<BR> 
<pre><tt>void cpp_lib_call(MPI::Comm cpp_comm); 
</tt></pre> 
  
  
 
<li>Page 60, Line 1 reads<BR>  
<P> 
<BR> 
<pre><tt>char name[MPI_MAX_NAME_STRING]; 
</tt></pre> 
but should read  
<BR> 
<pre><tt>char name[MPI_MAX_OBJECT_NAME]; 
</tt></pre> 
since <tt> MPI_MAX_NAME_STRING</tt> is not an MPI-defined constant.  
  
  
  
 
<li>Page 61, after line 36.  Add the following (paralleling the errata to  
  MPI-1.1):    
<P> 
<tt> MPI_{COMM,WIN,FILE}_GET_ERRHANDLER</tt> behave as if a   
new error handler object is created.  
That is, once the error handler is no longer needed,  
<tt> MPI_ERRHANDLER_FREE</tt> should be called with the error handler returned  
from <tt> MPI_ERRHANDLER_GET</tt> or  
<tt> MPI_{COMM,WIN,FILE}_GET_ERRHANDLER</tt>  
to mark the error handler for deallocation.  
This provides behavior similar to that of <tt> MPI_COMM_GROUP</tt> and  
<tt> MPI_GROUP_FREE</tt>.   
  
  
 
<li>Page 69, lines 14-15 read <BR>  
 <tt> MPI::Datatype MPI::Datatype::Resized(const MPI::Aint lb, const MPI::Aint extent) const <BR></tt>  
but should read <BR>  
 <tt> MPI::Datatype MPI::Datatype::Create_resized(const MPI::Aint lb, const MPI::Aint extent) const <BR></tt>  
  
  
  
 
<li>On Page 78, after line 27, add:  
<P> 
<tt> MPI_BYTE</tt> should be used to send and receive data that is packed  
using <tt> MPI_PACK_EXTERNAL</tt>.   
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
<tt> MPI_PACK_EXTERNAL</tt> specifies that there is no header on the message  
and further   
specifies the exact format of the data.  Since <tt> MPI_PACK</tt> may (and is  
allowed   
to) use a header, the datatype <tt> MPI_PACKED</tt> cannot be used for data  
packed with   
<tt> MPI_PACK_EXTERNAL</tt>.    
 (<em> End of rationale.</em>) <BR> 
  
  
 
<li>On page 93 after line 48, add  
<P> 
Many of the descriptions of the collective routines provide illustrations in  
terms of blocking MPI point-to-point routines.  These are intended solely to   
indicate what data is sent or received by what process.  Many of these  
examples    
are <em> not</em> correct MPI programs; for purposes of simplicity, they often  
assume infinite buffering.  
<P> 
  
  
 
<li>Page 94, line 29 reads <BR>  
are the original sets of of processes.<BR>  
but should read <BR>  
are the original sets of processes.  
  
  
  
 
<li>Page 114, after line 4, add  
<P> 
<tt> MPI_PROC_NULL</tt> is a valid target rank in the MPI RMA calls  
<tt> MPI_ACCUMULATE</tt>, <tt> MPI_GET</tt>, and <tt> MPI_PUT</tt>.  The  
effect is the same as for <tt> MPI_PROC_NULL</tt> in MPI point-to-point  
communication.   
  
  
 
<li>Page 116, line 31, reads  
<P> 
 <tt> void MPI::Win::Get(const void *origin_addr, int origin_count, const MPI::Datatype&amp; origin_datatype, int target_rank, MPI::Aint target_disp, int target_count, const MPI::Datatype&amp; target_datatype) const <BR></tt>  
<P> 
but should read   
<P> 
 <tt> void MPI::Win::Get(void *origin_addr, int origin_count, const  
  MPI::Datatype&amp; origin_datatype, int target_rank, MPI::Aint target_disp,  
  int target_count, const MPI::Datatype&amp; target_datatype) const <BR></tt>  
  
  
  
 
<li>Page 120, after line 13:  
<P> 
<tt> MPI_REPLACE</tt>, like the other predefined operations, is defined  
only for the predefined MPI datatypes.   
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The rationale for this is that, for consistency, <tt> MPI_REPLACE</tt>  
should have the same limitations as the other operations.  Extending  
it to all datatypes doesn't provide any real benefit.  
 (<em> End of rationale.</em>) <BR> 
  
  
 
<li>Page 162, lines 43--44 curently read<BR>  
The ``in place'' option for intracommunicators is specified by passing  
the value  MPI_IN_PLACE to the argument  sendbuf  
at the root.<BR>  
but should read<BR>  
The ``in place'' option for intracommunicators is specified by passing  
the value  MPI_IN_PLACE to the argument  sendbuf  
at all processes.  
  
  
  
 
<li>Page 162, line 48 reads  
<P> 
Both groups should provide the same <tt> count</tt> value.  
<P> 
but should read  
<P> 
Both groups should  
provide count and datatype arguments that specify the same type  
signature.  
  
  
 
<li>Page 165, lines 4--22 read <BR>  
      
      
      
      
      
       
     
<BR> 
  IN   sendcounts integer array equal to the group size specifying the  
number of elements to send to each processor (integer)  
 
<BR> 
  IN   sdispls integer array (of length group size). Entry j specifies  
the displacement in bytes (relative to  sendbuf) from which to take  
the outgoing data destined for process j  
 
<BR> 
  IN   sendtypes array of datatypes (of length group size). Entry j  
specifies the type of data to send to process j (handle)  
 
<BR> 
  OUT   recvbuf address of receive buffer (choice)  
 
<BR> 
  IN   recvcounts integer array equal to the group size specifying the  
number of elements that can be received from each processor (integer)  
 
<BR> 
  IN   rdispls integer array (of length group size). Entry i specifies  
the displacement in bytes (relative to  recvbuf) at which to place the  
incoming data from process i  
 
<BR> 
  IN   recvtypes array of datatypes (of length group size). Entry i  
specifies the type of data received from process i (handle)  
<BR> 
  
but should read <BR>  
      
      
      
      
      
       
     
<BR> 
  IN   sendcounts integer array equal to the group size specifying the  
number of elements to send to each processor (array of integers)  
 
<BR> 
  IN   sdispls integer array (of length group size). Entry j specifies  
the displacement in bytes (relative to  sendbuf) from which to take  
the outgoing data destined for process j (array of integers)  
 
<BR> 
  IN   sendtypes array of datatypes (of length group size). Entry j  
specifies the type of data to send to process j (array of handles)  
 
<BR> 
  OUT   recvbuf address of receive buffer (choice)  
 
<BR> 
  IN   recvcounts integer array equal to the group size specifying the  
number of elements that can be received from each processor (array of integers)  
 
<BR> 
  IN   rdispls integer array (of length group size). Entry i specifies  
the displacement in bytes (relative to  recvbuf) at which to place the  
incoming data from process i (array of integers)  
 
<BR> 
  IN   recvtypes array of datatypes (of length group size). Entry i  
specifies the type of data received from process i (array of handles)  
<BR> 
  
  
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
  
 
<li>Page 199, after line 11, add:  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
High quality implementations should raise an error when a keyval  
that was created by a call to <tt> MPI_XXX_CREATE_KEYVAL</tt> is  
used with an object of the wrong type with a call to  
<tt> MPI_YYY_GET_ATTR</tt>, <tt> MPI_YYY_SET_ATTR</tt>, <tt> MPI_YYY_DELETE_ATTR</tt>, or  
<tt> MPI_YYY_FREE_KEYVAL</tt>. To do so, it is necessary to maintain, with   
each keyval, information on the type of the associated user  
function.   
 (<em> End of advice to implementors.</em>) <BR> 
  
  
 
<li>Page 204, line 30 reads  
<P> 
 <tt> bool MPI::Win::Get_attr(const MPI::Win&amp; win, int win_keyval, void* attribute_val) const <BR></tt>  
<P> 
but should read  
<P> 
 <tt> bool MPI::Win::Get_attr(int win_keyval, void* attribute_val) const <BR></tt>  
  
  
  
 
<li>Page 221, after line 40, add  
<P> 
<tt> MPI_DISPLACEMENT_CURRENT</tt> is invalid unless the amode for the  
file has <tt> MPI_MODE_SEQUENTIAL</tt> set.    
<P> 
  
  
 
<li>Page 230, line 17, reads  
<P> 
If <tt> MPI_MODE_SEQUENTIAL</tt> mode was specified when the file  
was opened, it is erroneous to call the routines in this section.  
<P> 
but should read  
<P> 
If <tt> MPI_MODE_SEQUENTIAL</tt> mode was specified when the file  
was opened, it is erroneous to call the routines in this section, with  
the exception of <tt> MPI_FILE_GET_BYTE_OFFSET</tt>.  
  
  
 
<li>Page 250, line 8 reads <BR>  
with 15 exponent bits, bias = +10383, 112 fraction bits,<BR>  
but should read <BR>  
with 15 exponent bits, bias = +16383, 112 fraction bits,  
  
  
 
<li>Page 251, Line 18 reads  
<BR> 
<pre><tt>        MPI_LONG_LONG             8 
</tt></pre> 
but should read  
<BR> 
<pre><tt>        MPI_LONG_LONG_INT         8 
</tt></pre> 
In addition, the type <tt> MPI_LONG_LONG</tt> should be added as an optional  
type; it is a synonym for  MPI_LONG_LONG_INT.  
  
  
  
 
<li>Page 253, line 4 reads  
<BR> 
<pre><tt>typedef MPI::Datarep_extent_function(const MPI::Datatype&amp; datatype, 
</tt></pre> 
but should read  
<P> 
<BR> 
<pre><tt>typedef void MPI::Datarep_extent_function(const MPI::Datatype&amp; datatype, 
</tt></pre> 
  
  
 
<li>Page 253, lines 22-24 read  
<P> 
 <tt> typedef MPI::Datarep_conversion_function(void* userbuf, MPI::Datatype&amp; datatype, int count, void* filebuf, MPI::Offset position, void* extra_state); <BR></tt>  
<P> 
but should read  
<P> 
 <tt> typedef void MPI::Datarep_conversion_function(void* userbuf, MPI::Datatype&amp; datatype, int count, void* filebuf, MPI::Offset position, void* extra_state); <BR></tt>  
  
  
 
<li>Page 273, line 24 reads <BR>  
<BR> 
<pre><tt>  void Send(void* buf, int count, const MPI::Datatype&amp; type,  
</tt></pre> 
but should read <BR>  
<BR> 
<pre><tt>  void Send(const void* buf, int count, const MPI::Datatype&amp; type,  
</tt></pre> 
  
<P> 
  
 
<li>Page 332, lines 23-24 read <BR>  
 <tt> MPI::Datatype MPI::Datatype::Resized(const MPI::Aint lb, const MPI::Aint extent) const <BR></tt>  
but should read <BR>  
 <tt> MPI::Datatype MPI::Datatype::Create_resized(const MPI::Aint lb, const MPI::Aint extent) const <BR></tt>  
  
  
  
 
<li>Page 334, line 22 read  
<BR> 
<pre><tt>void MPI::Win::Get(const void *origin_addr, int origin_count, const 
</tt></pre> 
but should read  
<BR> 
<pre><tt>void MPI::Win::Get(void *origin_addr, int origin_count, const 
</tt></pre> 
  
  
  
 
<li>Page 341, line 18 reads  
<BR> 
<pre><tt>typedef MPI::Datarep_conversion_function(void* userbuf, 
</tt></pre> 
but should read  
<BR> 
<pre><tt>typedef void MPI::Datarep_conversion_function(void* userbuf, 
</tt></pre> 
  
  
 
<li>Page 341, line 22 reads  
<BR> 
<pre><tt>typedef MPI::Datarep_extent_function(const MPI::Datatype&amp; Datatype, 
</tt></pre> 
but should read  
<BR> 
<pre><tt>typedef void MPI::Datarep_extent_function(const MPI::Datatype&amp; Datatype, 
</tt></pre> 
  
  
  
 
<li>Page 343, line 44  
<P> 
Remove the <tt> const</tt> from <tt> const MPI::Datatype</tt>.  
<P> 
  
  
  
 
<li>Page 344, lines 13, 23, 32, 38, and 47  
<P> 
Remove the <tt> const</tt> from <tt> const MPI::Datatype</tt>.  
  
<P> 
  
  
 
<li>Page 345, lines 5 and 11  
<P> 
Remove the <tt> const</tt> from <tt> const MPI::Datatype</tt>.  
  
  
 
<li>Page 346, line 16 reads  
<BR> 
<pre><tt>// Type: MPI::Errhandler 
</tt></pre> 
but should read  
<BR> 
<pre><tt>// Type: const MPI::Errhandler 
</tt></pre> 
  
  
 
<li>Page 354, line 17 reads <BR>  
<P> 
   <tt> void Get_version(int&amp; version, int&amp; subversion); <BR></tt>  
but should read <BR>  
<P> 
   <tt> void Get_version(int&amp; version, int&amp; subversion) <BR></tt>  
  
<P> 
  
 
<li>Page 354, lines 25-30  read <BR>  
<P> 
   <tt> Exception::Exception(int error_code); <BR></tt>  
   <tt> int Exception::Get_error_code() const; <BR></tt>  
   <tt> int Exception::Get_error_class() const; <BR></tt>  
   <tt> const char* Exception::Get_error_string() const; <BR></tt>  
but should read <BR>  
<P> 
   <tt> Exception::Exception(int error_code) <BR></tt>  
   <tt> int Exception::Get_error_code() const <BR></tt>  
   <tt> int Exception::Get_error_class() const <BR></tt>  
   <tt> const char* Exception::Get_error_string() const <BR></tt>  
  
<P> 
  
 
<li>Page 357, line 24 reads <BR>  
<P><IMG WIDTH=257 HEIGHT=9 SRC="img1.xbm"><P>
<BR>  
but should read <BR>  
<P><IMG WIDTH=284 HEIGHT=9 SRC="img2.xbm"><P>
  
  
 
<li>Page 359, line 27 reads <BR>  
<P><IMG WIDTH=365 HEIGHT=10 SRC="img3.xbm"><P>
<BR>but should read <BR>  
<P><IMG WIDTH=365 HEIGHT=10 SRC="img4.xbm"><P>
  
</ul> 
<BR> 
</BODY>
</HTML>
