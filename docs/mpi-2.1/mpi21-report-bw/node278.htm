<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-io/io-2.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Data Access with Shared File Pointers</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node278">257. Data Access with Shared File Pointers</a></H2>
<A HREF="node277.htm#Node277"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node270.htm#Node270"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node278.htm#Node279"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node270.htm#Node270"> Data Access</a>
<b>Next: </b><A HREF="node278.htm#Node279"> Noncollective Operations</a>
<b>Previous: </b><A HREF="node277.htm#Node277"> Data Access with Individual File Pointers</a>
<P>
  
<P> 
 MPI maintains exactly one shared file pointer  
per collective  MPI_FILE_OPEN  
(shared among processes in the communicator group).  
The current value of this pointer implicitly specifies  
the offset in the data access routines described in this section.  
  
These routines only use and update the shared file pointer  
maintained by  MPI.  
The individual file pointers are not used nor updated.  
<P> 
The shared file pointer routines  
have the same semantics as the data access with explicit offset routines  
described in Section <a href="node276.htm#Node276">Data Access with Explicit Offsets 
</a>, page <a href="node276.htm#Node276">Data Access with Explicit Offsets 
</a>,  
with the following modifications:  
<ul> 
 
<li>the  offset is defined to be the current value  
        of the  MPI-maintained shared file pointer,  
 
<li>the effect of multiple calls to shared file pointer routines  
        is defined to behave as if the calls were serialized, and  
 
<li>the use of shared file pointer routines is erroneous unless  
        all processes use the same file view.  
</ul> 
<BR> 
For the noncollective shared file pointer routines,  
the  
serialization ordering is not deterministic.  
The user needs to use other synchronization means  
to enforce a specific order.  
<P> 
After a shared file pointer operation is initiated,  
the shared file pointer is updated to point to the next  
etype after the last one   
  
that will be accessed.  
  
The file pointer is updated relative to the current view of the file.  
<P> 
  
<P> 
<menu> 
</menu> 

<P>
<HR>
<A HREF="node277.htm#Node277"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node270.htm#Node270"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node278.htm#Node279"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node270.htm#Node270"> Data Access</a>
<b>Next: </b><A HREF="node278.htm#Node279"> Noncollective Operations</a>
<b>Previous: </b><A HREF="node277.htm#Node277"> Data Access with Individual File Pointers</a>
<P>
<HR><H3><A NAME="Node279">257.1. Noncollective Operations</a></H3>
<A HREF="node278.htm#Node278"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node278.htm#Node278"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node278.htm#Node280"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node278.htm#Node278"> Data Access with Shared File Pointers</a>
<b>Next: </b><A HREF="node278.htm#Node280"> Collective Operations</a>
<b>Previous: </b><A HREF="node278.htm#Node278"> Data Access with Shared File Pointers</a>
<P>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_READ_SHARED(fh, buf, count, datatype, status)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_File_read_shared(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <BR></tt>  
 <tt> MPI_FILE_READ_SHARED(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <BR> &lt;type&gt; BUF(*) <BR>INTEGER FH, COUNT, DATATYPE, STATUS(MPI_STATUS_SIZE), IERROR  <BR></tt>  
 <tt> void MPI::File::Read_shared(void* buf, int count, const MPI::Datatype&amp; datatype, MPI::Status&amp; status) <BR></tt>  
 <tt> void MPI::File::Read_shared(void* buf, int count, const MPI::Datatype&amp; datatype) <BR></tt>  
<P> 
 MPI_FILE_READ_SHARED reads a file  
using the shared file pointer.  
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_WRITE_SHARED(fh, buf, count, datatype, status)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
 <P> 
 <tt> int MPI_File_write_shared(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <BR></tt>  
 <tt> MPI_FILE_WRITE_SHARED(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <BR> &lt;type&gt; BUF(*) <BR>INTEGER FH, COUNT, DATATYPE, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <tt> void MPI::File::Write_shared(const void* buf, int count, const MPI::Datatype&amp; datatype, MPI::Status&amp; status) <BR></tt>  
 <tt> void MPI::File::Write_shared(const void* buf, int count, const MPI::Datatype&amp; datatype) <BR></tt>  
<P> 
 MPI_FILE_WRITE_SHARED writes a file  
using the shared file pointer.  
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_IREAD_SHARED(fh, buf, count, datatype, request)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>request object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_File_iread_shared(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Request *request) <BR></tt>  
 <tt> MPI_FILE_IREAD_SHARED(FH, BUF, COUNT, DATATYPE, REQUEST, IERROR) <BR> &lt;type&gt; BUF(*) <BR>INTEGER FH, COUNT, DATATYPE, REQUEST, IERROR <BR></tt>  
 <tt> MPI::Request MPI::File::Iread_shared(void* buf, int count, const MPI::Datatype&amp; datatype) <BR></tt>  
<P> 
 MPI_FILE_IREAD_SHARED is a nonblocking version  
of the  MPI_FILE_READ_SHARED interface.  
  
  
 <P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_IWRITE_SHARED(fh, buf, count, datatype, request)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>request object (handle)</TD></TR>  
</TABLE>  
 <P> 
 <tt> int MPI_File_iwrite_shared(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Request *request) <BR></tt>  
 <tt> MPI_FILE_IWRITE_SHARED(FH, BUF, COUNT, DATATYPE, REQUEST, IERROR) <BR> &lt;type&gt; BUF(*) <BR>INTEGER FH, COUNT, DATATYPE, REQUEST, IERROR <BR></tt>  
 <tt> MPI::Request MPI::File::Iwrite_shared(const void* buf, int count, const MPI::Datatype&amp; datatype) <BR></tt>  
<P> 
 MPI_FILE_IWRITE_SHARED is a nonblocking version  
of the  MPI_FILE_WRITE_SHARED interface.  
  
  
<P> 

<P>
<HR>
<A HREF="node278.htm#Node278"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node278.htm#Node278"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node278.htm#Node280"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node278.htm#Node278"> Data Access with Shared File Pointers</a>
<b>Next: </b><A HREF="node278.htm#Node280"> Collective Operations</a>
<b>Previous: </b><A HREF="node278.htm#Node278"> Data Access with Shared File Pointers</a>
<P>
<HR><H3><A NAME="Node280">257.2. Collective Operations</a></H3>
<A HREF="node278.htm#Node279"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node278.htm#Node278"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node278.htm#Node281"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node278.htm#Node278"> Data Access with Shared File Pointers</a>
<b>Next: </b><A HREF="node278.htm#Node281"> Seek</a>
<b>Previous: </b><A HREF="node278.htm#Node279"> Noncollective Operations</a>
<P>
  
<P> 
The semantics of a collective access using a shared file pointer is  
that the accesses to the file will be  
in the order determined by the ranks of the processes  
within the group.  
For each process, the location in the file at which data is accessed is the   
position at which the shared file pointer would be after all processes whose   
ranks within the group less than that of this process had accessed their data.  
In addition, in order to prevent subsequent  
shared offset accesses by the same processes from interfering  
with this collective   
access, the call might return only after all the processes   
  
within the group have initiated their   
accesses.  
When the call returns, the shared file pointer points  
to the next etype accessible,  
according to the file view used by all processes,  
after the last etype requested.  
  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
There may be some programs in which all processes in the  
group  
need to access the  
file using the shared file pointer, but the program may not <em> require</em>  
that data be accessed in order of process rank.  
In such programs, using the shared ordered routines  
(e.g.,  MPI_FILE_WRITE_ORDERED  
rather than  MPI_FILE_WRITE_SHARED)  
may enable an implementation to optimize access, improving performance.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Accesses to the data requested by all processes do not have to be serialized.   
Once all processes have issued their requests, locations within the file for  
all accesses can be computed, and accesses can proceed independently from each  
other, possibly in parallel.  
 (<em> End of advice to implementors.</em>) <BR> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_READ_ORDERED(fh, buf, count, datatype, status)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_File_read_ordered(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <BR></tt>  
 <tt> MPI_FILE_READ_ORDERED(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <BR> &lt;type&gt; BUF(*) <BR>INTEGER FH, COUNT, DATATYPE, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <tt> void MPI::File::Read_ordered(void* buf, int count, const MPI::Datatype&amp; datatype, MPI::Status&amp; status) <BR></tt>  
 <tt> void MPI::File::Read_ordered(void* buf, int count, const MPI::Datatype&amp; datatype) <BR></tt>  
<P> 
 MPI_FILE_READ_ORDERED is a collective version of the  
 MPI_FILE_READ_SHARED interface.  
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_WRITE_ORDERED(fh, buf, count, datatype, status)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_File_write_ordered(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <BR></tt>  
 <tt> MPI_FILE_WRITE_ORDERED(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <BR> &lt;type&gt; BUF(*) <BR>INTEGER FH, COUNT, DATATYPE, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <tt> void MPI::File::Write_ordered(const void* buf, int count, const MPI::Datatype&amp; datatype, MPI::Status&amp; status) <BR></tt>  
 <tt> void MPI::File::Write_ordered(const void* buf, int count, const MPI::Datatype&amp; datatype) <BR></tt>  
<P> 
 MPI_FILE_WRITE_ORDERED is a collective version of the  
  
 MPI_FILE_WRITE_SHARED interface.  
  
  
<P> 

<P>
<HR>
<A HREF="node278.htm#Node279"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node278.htm#Node278"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node278.htm#Node281"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node278.htm#Node278"> Data Access with Shared File Pointers</a>
<b>Next: </b><A HREF="node278.htm#Node281"> Seek</a>
<b>Previous: </b><A HREF="node278.htm#Node279"> Noncollective Operations</a>
<P>
<HR><H3><A NAME="Node281">257.3. Seek</a></H3>
<A HREF="node278.htm#Node280"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node278.htm#Node278"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node282.htm#Node282"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node278.htm#Node278"> Data Access with Shared File Pointers</a>
<b>Next: </b><A HREF="node282.htm#Node282"> Split Collective Data Access Routines</a>
<b>Previous: </b><A HREF="node278.htm#Node280"> Collective Operations</a>
<P>
  
<P> 
If  MPI_MODE_SEQUENTIAL mode was specified when the file was opened,  
it is erroneous to call the following two routines  
( MPI_FILE_SEEK_SHARED and  MPI_FILE_GET_POSITION_SHARED).  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_SEEK_SHARED(fh, offset, whence)</TD></TR>  
<TR><TD> INOUT fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> IN offset</TD><TD>file offset (integer)</TD></TR>  
<TR><TD> IN whence</TD><TD>update mode (state)</TD></TR>  
</TABLE>  
 <P> 
 <tt> int MPI_File_seek_shared(MPI_File fh, MPI_Offset offset, int whence) <BR></tt>  
 <tt> MPI_FILE_SEEK_SHARED(FH, OFFSET, WHENCE, IERROR)<BR> INTEGER FH, WHENCE, IERROR <BR>INTEGER(KIND=MPI_OFFSET_KIND) OFFSET <BR></tt>  
 <tt> void MPI::File::Seek_shared(MPI::Offset offset, int whence) <BR></tt>  
 <P> 
 MPI_FILE_SEEK_SHARED updates the shared file pointer according to   
 whence,  
which has  
  
the following possible values:  
<ul> 
 
<li> MPI_SEEK_SET:  
        the pointer is set to  offset  
 
<li> MPI_SEEK_CUR:  
        the pointer is set to the current pointer position plus  offset  
 
<li> MPI_SEEK_END:  
        the pointer is set to the end of   
  
file  
  
plus  offset  
</ul> 
<BR> 
 MPI_FILE_SEEK_SHARED is collective;  
all the processes in the communicator group associated with the file  
handle  fh must call  MPI_FILE_SEEK_SHARED with the same  
values for  
  
 offset and  whence.  
  
 <P> 
The  offset can be negative, which allows seeking backwards.  
It is erroneous to seek to a negative position in the view.  
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_GET_POSITION_SHARED(fh, offset)</TD></TR>  
<TR><TD> IN fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD> OUT offset</TD><TD>offset of shared pointer (integer)</TD></TR>  
</TABLE>  
 <P> 
 <tt> int MPI_File_get_position_shared(MPI_File fh, MPI_Offset *offset) <BR></tt>  
 <tt> MPI_FILE_GET_POSITION_SHARED(FH, OFFSET, IERROR)<BR> INTEGER FH, IERROR <BR>INTEGER(KIND=MPI_OFFSET_KIND) OFFSET <BR></tt>  
  
 <tt> MPI::Offset MPI::File::Get_position_shared() const <BR></tt>  
  
 <P> 
 MPI_FILE_GET_POSITION_SHARED returns, in  offset,  
the current position of the shared file pointer in etype units  
relative to the current  
view.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
The  offset can be used in a future call  
to  MPI_FILE_SEEK_SHARED  
using  whence = MPI_SEEK_SET to return to the current position.  
To set the displacement to the current file pointer position,  
first convert  offset into an absolute byte position using  
 MPI_FILE_GET_BYTE_OFFSET,  
then call  MPI_FILE_SET_VIEW with the resulting  
displacement.  
 (<em> End of advice to users.</em>) <BR> 

<P>
<HR>
<A HREF="node278.htm#Node280"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node278.htm#Node278"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node282.htm#Node282"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node278.htm#Node278"> Data Access with Shared File Pointers</a>
<b>Next: </b><A HREF="node282.htm#Node282"> Split Collective Data Access Routines</a>
<b>Previous: </b><A HREF="node278.htm#Node280"> Collective Operations</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
