<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Communication Completion</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node58">57. Communication Completion</a></H2>
<A HREF="node57.htm#Node57"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node55.htm#Node55"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node59.htm#Node59"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node55.htm#Node55"> Nonblocking Communication</a>
<b>Next: </b><A HREF="node59.htm#Node59"> Semantics of Nonblocking Communications</a>
<b>Previous: </b><A HREF="node57.htm#Node57"> Communication Initiation</a>
<P>
  
<P> 
The functions  MPI_WAIT and  MPI_TEST are used to complete a  
nonblocking communication.  The completion of a send operation indicates that  
the sender is now free  
to update the locations in the send buffer  
(the send operation itself leaves the content  
of the send buffer unchanged). It does not indicate that the  
message has been received,  
rather, it may have been buffered by the communication  
subsystem.  However, if a  synchronous  
mode send was used, the completion of the  
send operation indicates that a matching receive was initiated, and that the  
message will eventually be received by this matching receive.  
<P> 
The completion of a receive operation indicates that the receive buffer  
contains the received message, the receiver is now free to access it,  
and that the status object is set.  It does  
not indicate that the matching send operation has completed (but indicates, of  
course, that the send was initiated).  
<P> 
We shall use the following terminology:  
A <b> null</b> handle is a handle with  
value <BR> MPI_REQUEST_NULL.  
A persistent  
request and the handle to it are <b> inactive</b>  
if the request is not associated with any ongoing  
communication (see Section <a href="node63.htm#Node63">Persistent Communication Requests 
</a>).  
A handle is <b> active</b> if it is neither null nor inactive.  
  
  
  
An   
<b> empty</b> status is a status which is set to return  tag =  
MPI_ANY_TAG,  source = MPI_ANY_SOURCE,  error =  
MPI_SUCCESS,  and is also internally configured so that calls to  
 MPI_GET_COUNT and  MPI_GET_ELEMENTS return  
 count = 0  
and  MPI_TEST_CANCELLED returns  false.  
<P> 
We set a status variable to empty when the value returned by it is not  
significant. Status is set in this  
way so as to prevent errors due to accesses of stale information.  
  
<P> 
  
The fields in a  status object returned by a call to  
 MPI_WAIT,  MPI_TEST, or any of the other derived functions   
( MPI_{TEST<I>|</I>WAIT}{ALL<I>|</I>SOME<I>|</I>ANY}),   
where the  request corresponds to a send call, are undefined, with two  
exceptions: The error status field will contain valid information if the wait  
or test call returned with  MPI_ERR_IN_STATUS; and the returned  
status can be queried by the call  MPI_TEST_CANCELLED.  
<P> 
Error codes belonging to the error class  MPI_ERR_IN_STATUS should  
be returned only by the  MPI completion functions that take arrays of  
 MPI_STATUS.    
For the functions  MPI_TEST,  MPI_TESTANY,  MPI_WAIT, and  MPI_WAITANY, which  
return a single  MPI_STATUS value,  
the normal  MPI error return process should be used (not the  MPI_ERROR  
field in the  MPI_STATUS argument).  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WAIT(request, status)</TD></TR>  
<TR><TD> INOUT request</TD><TD>request (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
   
 <tt> int MPI_Wait(MPI_Request *request, MPI_Status *status) <BR></tt>  
<P> 
 <tt> MPI_WAIT(REQUEST, STATUS, IERROR)<BR> INTEGER  REQUEST, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <tt> void MPI::Request::Wait(MPI::Status&amp; status) <BR></tt>  
 <tt> void MPI::Request::Wait() <BR></tt>  
  
<P> 
A call to  MPI_WAIT returns when the operation  
identified by  request is complete.  If the communication object  
associated with this request was created by a nonblocking send or  
receive call, then the object is deallocated by the call to  MPI_WAIT  
and the request handle is set to  MPI_REQUEST_NULL.  
 MPI_WAIT is a non-local operation.  
<P> 
The call returns, in  status, information on  
the completed operation.  The content of the status object for a receive  
operation can be accessed as  
described in Section <a href="node45.htm#Node45">Return Status 
</a>.  
The status object for a send operation may be queried by  
a call to  MPI_TEST_CANCELLED  
(see Section <a href="node62.htm#Node62">Probe and Cancel 
</a>).  
<P> 
  
One is allowed to call  MPI_WAIT with a null or inactive  
 request argument.  
In this case the operation returns immediately with empty  status.  
  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Successful return of  MPI_WAIT after a  MPI_IBSEND implies  
that the user send buffer can be reused --- i.e., data has been sent  
out or copied into a  
buffer attached with  MPI_BUFFER_ATTACH.   Note that, at this point,  
we can no longer cancel the send (see Section <a href="node62.htm#Node62">Probe and Cancel 
</a>).  
If a matching receive is never  
posted, then the buffer cannot be freed.  This runs somewhat  
counter to the stated goal of  MPI_CANCEL (always being able to free  
program space that was committed to the communication subsystem).  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
In a multi-threaded environment, a call to  
  MPI_WAIT should block only the calling thread, allowing the thread  
scheduler to schedule another thread for execution.  
 (<em> End of advice to implementors.</em>) <BR> 
<TABLE><TR><TD COLSPAN=2>MPI_TEST(request, flag, status)</TD></TR>  
<TR><TD> INOUT request</TD><TD>communication request (handle)</TD></TR>  
<TR><TD> OUT flag</TD><TD> true if operation completed (logical)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Test(MPI_Request *request, int *flag, MPI_Status *status) <BR></tt>  
<P> 
 <tt> MPI_TEST(REQUEST, FLAG, STATUS, IERROR)<BR> LOGICAL  FLAG <BR>INTEGER  REQUEST, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <tt> bool MPI::Request::Test(MPI::Status&amp; status) <BR></tt>  
 <tt> bool MPI::Request::Test() <BR></tt>  
  
<P> 
A call to  MPI_TEST returns  flag = true if the  
operation identified by  request is complete.  In such a case, the  
status object is set to contain information on the completed  
operation;  if the communication object was created by a nonblocking  
send or receive, then it is deallocated and the request handle is set to  
 MPI_REQUEST_NULL. The call returns  
 flag = false, otherwise. In this case, the value  
of the status object is undefined.  
 MPI_TEST is a local operation.  
<P> 
The return status object for a receive operation carries information that  
can be accessed as described in  
Section <a href="node45.htm#Node45">Return Status 
</a>.  
The status object for a send operation carries information that can be  
accessed by  
a call to  MPI_TEST_CANCELLED  
(see Section <a href="node62.htm#Node62">Probe and Cancel 
</a>).  
<P> 
  
One  
is allowed to call  MPI_TEST with a null or inactive  request  
argument. In such a case the operation returns with  flag = true and  
empty  status.  
  
<P> 
The functions  MPI_WAIT and  MPI_TEST can be used to  
complete both sends and receives.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
The use of  
the nonblocking  MPI_TEST call allows the user to  
schedule alternative activities within a single thread of execution.  
An event-driven thread scheduler can be emulated with periodic calls to  
 MPI_TEST.  
 (<em> End of advice to users.</em>) <BR> 
  
 
<BR> 
<em> Rationale.</em>  
<P> 
The function  MPI_TEST returns with  flag = true  
exactly in those situations where the function  MPI_WAIT  
returns; both functions return in such case the same value in  
 status.  Thus, a blocking Wait can be easily replaced by a  
nonblocking Test.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
<BR><b> Example</b>   
  
  
  
  
  
Simple usage of nonblocking operations and  MPI_WAIT.  
<BR> 
<pre><tt>CALL MPI_COMM_RANK(comm, rank, ierr) 
IF (rank.EQ.0) THEN 
    CALL MPI_ISEND(a(1), 10, MPI_REAL, 1, tag, comm, request, ierr) 
    **** do some computation to mask latency **** 
    CALL MPI_WAIT(request, status, ierr) 
ELSE IF (rank.EQ.1) THEN 
    CALL MPI_IRECV(a(1), 15, MPI_REAL, 0, tag, comm, request, ierr) 
    **** do some computation to mask latency **** 
    CALL MPI_WAIT(request, status, ierr) 
END IF 
</tt></pre> 
   
<P> 
A request object can be deallocated without waiting for the associated  
communication to complete, by using the following operation.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_REQUEST_FREE(request)</TD></TR>  
<TR><TD> INOUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Request_free(MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_REQUEST_FREE(REQUEST, IERROR)<BR> INTEGER  REQUEST, IERROR <BR></tt>  
 <tt> void MPI::Request::Free() <BR></tt>  
  
Mark the request object for deallocation and set  request to  
 MPI_REQUEST_NULL.  
An ongoing communication that is associated with the request will be allowed  
to complete. The request will be deallocated only after its completion.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The  MPI_REQUEST_FREE mechanism is provided for  
reasons of performance and convenience on the sending side.  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Once a request is freed by a call to  MPI_REQUEST_FREE, it is not  
possible to check for the successful completion of the associated  
communication with calls to  MPI_WAIT or  MPI_TEST.  Also,  
if an error occurs subsequently during the communication, an error code cannot  
be returned to the user --- such an error must be treated as fatal.  
Questions arise as to how one knows when the operations have completed  
when using  MPI_REQUEST_FREE.  Depending on the program logic,  
there may be other ways in which the program knows that certain operations  
have completed and this makes usage of  MPI_REQUEST_FREE  
practical.   For example, an active send request  
could be freed when the logic of the program is such that the  
receiver sends a reply to the message sent --- the arrival of the reply informs  
the sender that the send has completed and the send buffer can be reused.  
An active receive request should never be freed as the receiver will have no  
way to verify that the receive has completed and the receive buffer can be  
reused.  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
<BR><b> Example</b>   
  
  
  
  
  
  
An example using  MPI_REQUEST_FREE.  
<P> 
  
  
<BR> 
<pre><tt>CALL MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr) 
IF (rank.EQ.0) THEN 
    DO i=1, n 
      CALL MPI_ISEND(outval, 1, MPI_REAL, 1, 0, MPI_COMM_WORLD, req, ierr) 
      CALL MPI_REQUEST_FREE(req, ierr) 
      CALL MPI_IRECV(inval, 1, MPI_REAL, 1, 0, MPI_COMM_WORLD, req, ierr) 
      CALL MPI_WAIT(req, status, ierr) 
    END DO 
ELSE IF (rank.EQ.1) THEN 
    CALL MPI_IRECV(inval, 1, MPI_REAL, 0, 0, MPI_COMM_WORLD, req, ierr) 
    CALL MPI_WAIT(req, status, ierr) 
    DO I=1, n-1 
       CALL MPI_ISEND(outval, 1, MPI_REAL, 0, 0, MPI_COMM_WORLD, req, ierr) 
       CALL MPI_REQUEST_FREE(req, ierr) 
       CALL MPI_IRECV(inval, 1, MPI_REAL, 0, 0, MPI_COMM_WORLD, req, ierr) 
       CALL MPI_WAIT(req, status, ierr) 
    END DO 
    CALL MPI_ISEND(outval, 1, MPI_REAL, 0, 0, MPI_COMM_WORLD, req, ierr) 
    CALL MPI_WAIT(req, status, ierr) 
END IF 
</tt></pre> 
   
<P> 

<P>
<HR>
<A HREF="node57.htm#Node57"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node55.htm#Node55"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node59.htm#Node59"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node55.htm#Node55"> Nonblocking Communication</a>
<b>Next: </b><A HREF="node59.htm#Node59"> Semantics of Nonblocking Communications</a>
<b>Previous: </b><A HREF="node57.htm#Node57"> Communication Initiation</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
