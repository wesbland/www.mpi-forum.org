<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Persistent Communication Requests</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H1><A NAME="Node63">62. Persistent Communication Requests</a></H1>
<A HREF="node62.htm#Node62"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi21-report-bw.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node64.htm#Node64"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi21-report-bw.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node64.htm#Node64"> Send-Receive</a>
<b>Previous: </b><A HREF="node62.htm#Node62"> Probe and Cancel</a>
<P>
  
<P> 
Often a communication with the same argument list is repeatedly  
executed within the inner loop of a parallel computation.  In such a  
situation, it may be possible to optimize the communication by  
binding the list of communication arguments to a <b> persistent</b> communication  
request once and, then, repeatedly using  
the request to initiate and complete messages.  The  
persistent request thus created can be thought of as a  
communication port or a ``half-channel.''  
It does not provide the full functionality of a conventional channel,  
since there is no binding of the send port to the receive port. This  
construct allows reduction of the overhead for communication  
between the process and communication controller, but not of the overhead for  
communication between one communication controller and another.  
It is not necessary that messages sent with a persistent request be received  
by a receive operation using a persistent request, or vice versa.  
<P> 
A persistent communication request is created using one of the   
five  
following calls.  These calls involve no communication.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SEND_INIT(buf, count, datatype, dest, tag,  
comm, request)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements sent (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Send_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_SEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  REQUEST, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
  
 <tt> MPI::Prequest MPI::Comm::Send_init(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <BR></tt>  
  
Creates a persistent communication request  
for a standard mode send operation, and binds to it all the  
arguments of a send operation.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BSEND_INIT(buf, count, datatype, dest, tag,  
comm, request)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements sent (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Bsend_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_BSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  REQUEST, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
 <tt> MPI::Prequest MPI::Comm::Bsend_init(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <BR></tt>  
  
Creates a persistent communication request for a buffered mode send.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SSEND_INIT(buf, count, datatype, dest, tag,  
comm, request)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements sent (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Ssend_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_SSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
 <tt> MPI::Prequest MPI::Comm::Ssend_init(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <BR></tt>  
  
Creates a persistent communication object  
for a synchronous mode send operation.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_RSEND_INIT(buf, count, datatype, dest, tag,  
comm, request)</TD></TR>  
<TR><TD> IN buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements sent (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Rsend_init(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_RSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR <BR></tt>  
 <tt> MPI::Prequest MPI::Comm::Rsend_init(const void* buf, int count, const MPI::Datatype&amp; datatype, int dest, int tag) const <BR></tt>  
  
Creates a persistent communication object  
for a ready mode send operation.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_RECV_INIT(buf, count, datatype, source, tag,  
comm, request)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of receive buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements received (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD> IN source</TD><TD>rank of source or  MPI_ANY_SOURCE (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag or  MPI_ANY_TAG (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Recv_init(void* buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_RECV_INIT(BUF, COUNT, DATATYPE, SOURCE, TAG, COMM, REQUEST, IERROR)<BR> &lt;type&gt;  BUF(*) <BR>INTEGER  COUNT, DATATYPE, SOURCE, TAG, COMM, REQUEST, IERROR <BR></tt>  
 <tt> MPI::Prequest MPI::Comm::Recv_init(void* buf, int count, const MPI::Datatype&amp; datatype, int source, int tag) const <BR></tt>  
  
Creates a persistent communication request  
for a receive operation.  The argument  buf is marked as  OUT  
because the user gives permission to write on the receive buffer by passing the  
argument to  MPI_RECV_INIT.  
<P> 
A persistent communication request is inactive after it was created  
--- no active communication is attached to the request.  
<P> 
A communication (send or receive) that uses a persistent request  
is initiated by the function  MPI_START.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_START(request)</TD></TR>  
<TR><TD> INOUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Start(MPI_Request *request) <BR></tt>  
<P> 
 <tt> MPI_START(REQUEST, IERROR)<BR> INTEGER  REQUEST, IERROR <BR></tt>  
 <tt> void MPI::Prequest::Start() <BR></tt>  
  
<P> 
The argument,  request, is a handle returned  
by one of the previous five calls.   The associated request should be  
inactive.  The request becomes active once the call is made.  
<P> 
If the request is for a send with ready mode, then  
a matching receive should be posted before the call is made.  The  
communication buffer should not be accessed after the call, and  
until the operation completes.  
<P> 
The call is local, with similar semantics to the nonblocking  
communication operations described in  
Section <a href="node55.htm#Node55">Nonblocking Communication 
</a>.  That is,  
a call to  MPI_START with a  
request created by  MPI_SEND_INIT  
starts a  
communication in the same manner as a call to  MPI_ISEND;  
a call to  MPI_START with a  
request created by  MPI_BSEND_INIT  
starts a  
communication in the same manner as a call to  
 MPI_IBSEND;  and so on.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_STARTALL(count, array_of_requests)</TD></TR>  
<TR><TD> IN count</TD><TD>list length (non-negative  
integer)</TD></TR>  
<TR><TD> INOUT array_of_requests</TD><TD>array of requests (array of handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Startall(int count, MPI_Request *array_of_requests) <BR></tt>  
<P> 
 <tt> MPI_STARTALL(COUNT, ARRAY_OF_REQUESTS, IERROR)<BR> INTEGER  COUNT, ARRAY_OF_REQUESTS(*), IERROR <BR></tt>  
 <tt> static void MPI::Prequest::Startall(int count, MPI::Prequest array_of_requests[]) <BR></tt>  
  
<P> 
Start all communications associated with requests in  
 array_of_requests.  A call to  
<BR>  
 MPI_STARTALL(count, array_of_requests) has the  
same effect as calls to  
 MPI_START  (&amp;array_of_requests[i]),executed for  i=0 ,..., count-1, in some arbitrary order.  
<P> 
A communication started with a call to  MPI_START or  
 MPI_STARTALL is  
completed by a call to  MPI_WAIT,  MPI_TEST, or  
one of the derived functions described in  
Section <a href="node60.htm#Node60">Multiple Completions 
</a>.  The request becomes inactive after  
successful completion of such call.   The request is not deallocated  
and it can be activated anew by an  MPI_START or  
 MPI_STARTALL call.  
<P> 
A persistent request is deallocated by a call to  
 MPI_REQUEST_FREE  
(Section <a href="node58.htm#Node58">Communication Completion 
</a>).  
<P> 
The call to  MPI_REQUEST_FREE can occur at any point in the program  
after the persistent request was created.  However, the request will be  
deallocated only after it becomes inactive.  
Active receive requests should not be freed. Otherwise, it will not be  
possible to check that the receive has completed.  
It is preferable, in general, to free requests when they are inactive.  If this  
rule is followed, then the functions  
described in this section will be invoked  
in a sequence of the form,  
<P> 
  
<IMG WIDTH=163 HEIGHT=11 SRC="img4.gif">
  
  
  
<BR>  
where   
<I>*</I> indicates zero or more repetitions.  
If the same communication object is used in several concurrent  
threads, it is the user's responsibility to coordinate calls so that the  
correct sequence is obeyed.  
<P> 
A send operation initiated with  MPI_START can be matched with  
any receive operation and, likewise, a receive operation initiated  
with  MPI_START can receive messages generated by any send  
operation.  
<P> 
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
To prevent problems with the argument copying and register optimization done  
  by Fortran compilers, please note the hints in subsections ``Problems Due to  
  Data Copying and Sequence Association,'' and ``A Problem with  
  Register Optimization''    
  in Section <a href="node337.htm#Node337">Problems With Fortran Bindings for  MPI 
</a> on  
  pages <a href="node337.htm#Node339">Problems Due to Data Copying and Sequence Association 
</a> and <a href="node337.htm#Node342">A Problem with Register Optimization 
</a>.  
 (<em> End of advice to users.</em>) <BR> 

<P>
<HR>
<A HREF="node62.htm#Node62"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="mpi21-report-bw.htm#Node0"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node64.htm#Node64"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="mpi21-report-bw.htm#Node0">Contents</a>
<b>Next: </b><A HREF="node64.htm#Node64"> Send-Receive</a>
<b>Previous: </b><A HREF="node62.htm#Node62"> Probe and Cancel</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
