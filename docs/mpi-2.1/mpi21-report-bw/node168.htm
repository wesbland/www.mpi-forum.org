<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-topol/topol.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Topology Inquiry Functions</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node168">160. Topology Inquiry Functions</a></H2>
<A HREF="node167.htm#Node167"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node164.htm#Node164"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node169.htm#Node169"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node164.htm#Node164"> Topology Constructors</a>
<b>Next: </b><A HREF="node169.htm#Node169"> Cartesian Shift Coordinates</a>
<b>Previous: </b><A HREF="node167.htm#Node167"> General (Graph) Constructor</a>
<P>
  
<P> 
If a topology has been defined with one of the above functions, then the topology  
information can be looked up using inquiry functions. They all are local  
calls.  
<P> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TOPO_TEST(comm, status)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator (handle)</TD></TR>  
<TR><TD> OUT  status</TD><TD> topology type of communicator <tt> comm</tt> (state)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Topo_test(MPI_Comm comm, int *status) <BR></tt>  
<P> 
 <tt> MPI_TOPO_TEST(COMM, STATUS, IERROR)<BR> INTEGER COMM, STATUS, IERROR <BR></tt>  
 <tt> int MPI::Comm::Get_topology() const <BR></tt>  
  
The function  MPI_TOPO_TEST returns the type of topology that  
is assigned to a communicator.  
<P> 
The output value <tt> status</tt> is one of the following:  
    
      
      
     
<BR> 
 MPI_GRAPH graph topology  
 
<BR> 
 MPI_CART Cartesian topology  
 
<BR> 
 MPI_UNDEFINED no topology  
<BR> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPHDIMS_GET(comm, nnodes, nedges)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator for group with graph structure (handle)</TD></TR>  
<TR><TD> OUT  nnodes</TD><TD> number of nodes in graph (integer) (same as number of processes in the group)</TD></TR>  
<TR><TD> OUT  nedges</TD><TD> number of edges in graph (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graphdims_get(MPI_Comm comm, int *nnodes, int *nedges) <BR></tt>  
<P> 
 <tt> MPI_GRAPHDIMS_GET(COMM, NNODES, NEDGES, IERROR)<BR> INTEGER COMM, NNODES, NEDGES, IERROR <BR></tt>  
 <tt> void MPI::Graphcomm::Get_dims(int nnodes[], int nedges[]) const <BR></tt>  
  
Functions  MPI_GRAPHDIMS_GET and  
 MPI_GRAPH_GET retrieve the graph-topology information  
that was associated with a communicator by  
 MPI_GRAPH_CREATE.  
<P> 
The information provided by  MPI_GRAPHDIMS_GET can be used  
to dimension the  
vectors <tt> index</tt> and <tt> edges</tt> correctly for the following call  
to  MPI_GRAPH_GET.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_GET(comm, maxindex, maxedges, index, edges)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with graph structure (handle)</TD></TR>  
<TR><TD> IN  maxindex</TD><TD> length of vector  index in the calling program <BR>(integer)</TD></TR>  
<TR><TD> IN  maxedges</TD><TD> length of vector  edges in the calling program <BR>(integer)</TD></TR>  
<TR><TD> OUT  index</TD><TD> array of integers containing the graph structure (for details see the definition of  MPI_GRAPH_CREATE)</TD></TR>  
<TR><TD> OUT  edges</TD><TD> array of integers containing the graph structure </TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graph_get(MPI_Comm comm, int maxindex, int maxedges, int *index, int *edges) <BR></tt>  
<P> 
 <tt> MPI_GRAPH_GET(COMM, MAXINDEX, MAXEDGES, INDEX, EDGES, IERROR)<BR> INTEGER COMM, MAXINDEX, MAXEDGES, INDEX(*), EDGES(*), IERROR <BR></tt>  
 <tt> void MPI::Graphcomm::Get_topo(int maxindex, int maxedges, int index[], int edges[]) const <BR></tt>  
  
<TABLE><TR><TD COLSPAN=2>MPI_CARTDIM_GET(comm, ndims)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with Cartesian structure (handle)</TD></TR>  
<TR><TD> OUT  ndims</TD><TD> number of dimensions of the Cartesian structure (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Cartdim_get(MPI_Comm comm, int *ndims) <BR></tt>  
<P> 
 <tt> MPI_CARTDIM_GET(COMM, NDIMS, IERROR)<BR> INTEGER COMM, NDIMS, IERROR <BR></tt>  
 <tt> int MPI::Cartcomm::Get_dim() const <BR></tt>  
  
The functions  MPI_CARTDIM_GET and  
 MPI_CART_GET return the Cartesian topology information that was  
associated with a communicator by  
 MPI_CART_CREATE.  
If  comm is associated with a zero-dimensional Cartesian topology,  
 MPI_CARTDIM_GET returns  ndims=0 and  MPI_CART_GET will keep  
all output arguments unchanged.   
  
<TABLE><TR><TD COLSPAN=2>MPI_CART_GET(comm, maxdims, dims, periods, coords)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with Cartesian structure (handle)</TD></TR>  
<TR><TD> IN  maxdims</TD><TD> length of vectors <tt> dims, periods</tt>, and <tt> coords</tt> in the calling program (integer)</TD></TR>  
<TR><TD> OUT  dims</TD><TD> number of processes for each Cartesian dimension (array of integer)</TD></TR>  
<TR><TD> OUT  periods</TD><TD> periodicity ( true/ false) for each Cartesian dimension (array of logical)</TD></TR>  
<TR><TD> OUT  coords</TD><TD> coordinates of calling process in Cartesian structure (array of integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Cart_get(MPI_Comm comm, int maxdims, int *dims, int *periods, int *coords) <BR></tt>  
<P> 
 <tt> MPI_CART_GET(COMM, MAXDIMS, DIMS, PERIODS, COORDS, IERROR)<BR> INTEGER COMM, MAXDIMS, DIMS(*), COORDS(*), IERROR <BR>LOGICAL PERIODS(*) <BR></tt>  
 <tt> void MPI::Cartcomm::Get_topo(int maxdims, int dims[], bool periods[], int coords[]) const <BR></tt>  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CART_RANK(comm, coords, rank)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with Cartesian structure (handle)</TD></TR>  
<TR><TD> IN  coords</TD><TD> integer array (of size <tt> ndims</tt>) specifying the Cartesian coordinates of a process </TD></TR>  
<TR><TD> OUT  rank</TD><TD> rank of specified process (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Cart_rank(MPI_Comm comm, int *coords, int *rank) <BR></tt>  
<P> 
 <tt> MPI_CART_RANK(COMM, COORDS, RANK, IERROR)<BR> INTEGER COMM, COORDS(*), RANK, IERROR <BR></tt>  
 <tt> int MPI::Cartcomm::Get_cart_rank(const int coords[]) const <BR></tt>  
  
For a process group with Cartesian structure, the function  
 MPI_CART_RANK translates the logical process coordinates to process  
ranks as they are used by the point-to-point routines.  
<P> 
For dimension <tt> i</tt> with <tt> periods(i) = true</tt>, if the coordinate,  
<tt> coords(i)</tt>, is out of range, that is, <tt> coords(i) <I>&lt;</I> 0</tt> or  
<tt> coords(i) <IMG WIDTH=48 HEIGHT=12 SRC="img84.gif">
 dims(i)</tt>, it is shifted back to the interval  
<BR>  
<tt> 0 <IMG WIDTH=137 HEIGHT=11 SRC="img85.gif">
 coords(i) <I>&lt;</I> dims(i)</tt> automatically. Out-of-range  
coordinates are erroneous for non-periodic dimensions.  
 <P> 
If  comm is associated with a zero-dimensional Cartesian topology,  
 coord is not significant and 0 is returned in  rank.   
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CART_COORDS(comm, rank, maxdims, coords)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with Cartesian structure (handle)</TD></TR>  
<TR><TD> IN  rank</TD><TD> rank of a process within group of  comm (integer)</TD></TR>  
<TR><TD> IN  maxdims</TD><TD> length of vector  <tt> coords</tt> in the calling program (integer)</TD></TR>  
<TR><TD> OUT  coords</TD><TD> integer array (of size <tt> ndims</tt>) containing the Cartesian coordinates of specified process (array of integers)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Cart_coords(MPI_Comm comm, int rank, int maxdims, int *coords) <BR></tt>  
<P> 
 <tt> MPI_CART_COORDS(COMM, RANK, MAXDIMS, COORDS, IERROR)<BR> INTEGER COMM, RANK, MAXDIMS, COORDS(*), IERROR <BR></tt>  
 <tt> void MPI::Cartcomm::Get_coords(int rank, int maxdims, int coords[]) const <BR></tt>  
  
The inverse mapping, rank-to-coordinates translation is provided by  
 MPI_CART_COORDS.   
If  comm is associated with a zero-dimensional Cartesian topology,  
 coords will be unchanged.   
  
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_NEIGHBORS_COUNT(comm, rank, nneighbors)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with graph topology (handle)</TD></TR>  
<TR><TD> IN  rank</TD><TD> rank of process in group of  comm (integer)</TD></TR>  
<TR><TD> OUT  nneighbors</TD><TD> number of neighbors of specified process (integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graph_neighbors_count(MPI_Comm comm, int rank, int *nneighbors) <BR></tt>  
<P> 
 <tt> MPI_GRAPH_NEIGHBORS_COUNT(COMM, RANK, NNEIGHBORS, IERROR)<BR> INTEGER COMM, RANK, NNEIGHBORS, IERROR <BR></tt>  
 <tt> int MPI::Graphcomm::Get_neighbors_count(int rank) const <BR></tt>  
  
 MPI_GRAPH_NEIGHBORS_COUNT and  MPI_GRAPH_NEIGHBORS provide  
adjacency information for a general graph topology.  
  
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_NEIGHBORS(comm, rank, maxneighbors, neighbors)</TD></TR>  
<TR><TD> IN  comm</TD><TD> communicator with graph topology (handle)</TD></TR>  
<TR><TD> IN  rank</TD><TD> rank of process in group of  comm (integer)</TD></TR>  
<TR><TD> IN  maxneighbors</TD><TD> size of array  neighbors (integer)</TD></TR>  
<TR><TD> OUT  neighbors</TD><TD> ranks of processes that are neighbors to specified process (array of integer)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graph_neighbors(MPI_Comm comm, int rank, int maxneighbors, int *neighbors) <BR></tt>  
<P> 
 <tt> MPI_GRAPH_NEIGHBORS(COMM, RANK, MAXNEIGHBORS, NEIGHBORS, IERROR)<BR> INTEGER COMM, RANK, MAXNEIGHBORS, NEIGHBORS(*), IERROR <BR></tt>  
 <tt> void MPI::Graphcomm::Get_neighbors(int rank, int maxneighbors, int neighbors[]) const <BR></tt>  
  
<BR><b> Example</b>    
  
  
<P> 
Suppose that <tt> comm</tt> is a communicator with a  
shuffle-exchange topology.   The group has <I>2<SUP>n</SUP></I> members.  
Each process is labeled by <I>a<SUB>1</SUB> , ..., a<SUB>n</SUB></I> with <IMG WIDTH=45 HEIGHT=7 SRC="img86.gif">
, and has three neighbors:  
exchange(<IMG WIDTH=7 HEIGHT=10 SRC="img87.gif">
  
(<IMG WIDTH=7 HEIGHT=10 SRC="img88.gif">
), shuffle(<I>a<SUB>1</SUB> , ..., a<SUB>n</SUB> )= a<SUB>2</SUB> , ..., 
a<SUB>n</SUB>, a<SUB>1</SUB></I>, and unshuffle(<I>a<SUB>1</SUB> , ..., a<SUB>n</SUB> ) = a<SUB>n</SUB> , a<SUB>1</SUB> , ... , a<SUB>n-1</SUB></I>.  
The graph adjacency list is illustrated below for <I>n=3</I>.  
<BR>  
<CENTER>  
<TABLE><TR><TD ALIGN="CENTER">  
2|c|<b> node</b></TD><TD ALIGN="CENTER"><b> exchange</b></TD><TD ALIGN="CENTER"><b> shuffle</b></TD><TD ALIGN="CENTER"><b> unshuffle</b></TD></TR> 
<TR><TD ALIGN="CENTER">  
</TD><TD ALIGN="CENTER"></TD><TD ALIGN="CENTER"> neighbors(1)</TD><TD ALIGN="CENTER"> neighbors(2)</TD><TD ALIGN="CENTER"> neighbors(3) </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="CENTER"> (000)</TD><TD ALIGN="CENTER"> 1</TD><TD ALIGN="CENTER"> 0</TD><TD ALIGN="CENTER"> 0</TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="CENTER"> (001)</TD><TD ALIGN="CENTER"> 0</TD><TD ALIGN="CENTER"> 2</TD><TD ALIGN="CENTER"> 4</TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="CENTER"> (010)</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="CENTER"> 4</TD><TD ALIGN="CENTER"> 1</TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="CENTER"> (011)</TD><TD ALIGN="CENTER"> 2</TD><TD ALIGN="CENTER"> 6</TD><TD ALIGN="CENTER"> 5</TD></TR> 
<TR><TD ALIGN="CENTER">  
4</TD><TD ALIGN="CENTER"> (100)</TD><TD ALIGN="CENTER"> 5</TD><TD ALIGN="CENTER"> 1</TD><TD ALIGN="CENTER"> 2</TD></TR> 
<TR><TD ALIGN="CENTER">  
5</TD><TD ALIGN="CENTER"> (101)</TD><TD ALIGN="CENTER"> 4</TD><TD ALIGN="CENTER"> 3</TD><TD ALIGN="CENTER"> 6</TD></TR> 
<TR><TD ALIGN="CENTER">  
6</TD><TD ALIGN="CENTER"> (110)</TD><TD ALIGN="CENTER"> 7</TD><TD ALIGN="CENTER"> 5</TD><TD ALIGN="CENTER"> 3</TD></TR> 
<TR><TD ALIGN="CENTER">  
7</TD><TD ALIGN="CENTER"> (111)</TD><TD ALIGN="CENTER"> 6</TD><TD ALIGN="CENTER"> 7</TD><TD ALIGN="CENTER"> 7</TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
</CENTER>  
<P> 
  
Suppose that the communicator <tt> comm</tt> has this topology associated with it.  
The following code fragment cycles through the three types of neighbors  
and performs an appropriate permutation for each.  
<P> 
<BR> 
<pre><tt>C  assume: each process has stored a real number A. 
C  extract neighborhood information 
      CALL MPI_COMM_RANK(comm, myrank, ierr) 
      CALL MPI_GRAPH_NEIGHBORS(comm, myrank, 3, neighbors, ierr) 
C  perform exchange permutation 
      CALL MPI_SENDRECV_REPLACE(A, 1, MPI_REAL, neighbors(1), 0, 
     +     neighbors(1), 0, comm, status, ierr) 
C  perform shuffle permutation 
      CALL MPI_SENDRECV_REPLACE(A, 1, MPI_REAL, neighbors(2), 0, 
     +     neighbors(3), 0, comm, status, ierr) 
C  perform unshuffle permutation 
      CALL MPI_SENDRECV_REPLACE(A, 1, MPI_REAL, neighbors(3), 0, 
     +     neighbors(2), 0, comm, status, ierr) 
</tt></pre> 
   
<P> 

<P>
<HR>
<A HREF="node167.htm#Node167"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node164.htm#Node164"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node169.htm#Node169"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node164.htm#Node164"> Topology Constructors</a>
<b>Next: </b><A HREF="node169.htm#Node169"> Cartesian Shift Coordinates</a>
<b>Previous: </b><A HREF="node167.htm#Node167"> General (Graph) Constructor</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
