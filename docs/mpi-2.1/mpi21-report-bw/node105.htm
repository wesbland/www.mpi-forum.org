<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-coll/coll.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>User-Defined Reduction Operations</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node105">104. User-Defined Reduction Operations</a></H2>
<A HREF="node104.htm#Node104"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node100.htm#Node100"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node105.htm#Node106"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node100.htm#Node100"> Global Reduction Operations</a>
<b>Next: </b><A HREF="node105.htm#Node106"> Example of User-defined Reduce</a>
<b>Previous: </b><A HREF="node104.htm#Node104"> MINLOC and MAXLOC</a>
<P>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_OP_CREATE(function, commute, op)</TD></TR>  
<TR><TD> IN function</TD><TD> user defined function (function)</TD></TR>  
<TR><TD> IN commute</TD><TD> <tt> true</tt> if commutative; <tt> false</tt> otherwise.</TD></TR>  
<TR><TD> OUT op</TD><TD> operation (handle) </TD></TR>  
</TABLE>  
<P> 
   
 <tt> int MPI_Op_create(MPI_User_function *function, int commute, MPI_Op *op) <BR></tt>  
<P> 
 <tt> MPI_OP_CREATE( FUNCTION, COMMUTE, OP, IERROR) <BR> EXTERNAL FUNCTION <BR>LOGICAL COMMUTE <BR>INTEGER OP, IERROR <BR></tt>  
 <tt> void MPI::Op::Init(MPI::User_function* function, bool commute) <BR></tt>  
  
 MPI_OP_CREATE binds a user-defined global operation  
to an  op handle that can subsequently be used in  
 MPI_REDUCE,  MPI_ALLREDUCE,  
 MPI_REDUCE_SCATTER,   
 MPI_SCAN, and  MPI_EXSCAN.  
The user-defined operation is assumed to be associative.  
If  commute <I>=</I> <tt> true</tt>, then the operation should be both  
commutative and associative. If   commute <I>=</I> <tt> false</tt>,  
  
then the order of operands is fixed and is defined to be in ascending, process  
rank order, beginning with process zero.  The order of evaluation can be  
changed, talking advantage of the associativity of the operation.  If  
 commute <I>=</I> <tt> true</tt> then the order of evaluation can be changed,  
taking advantage of commutativity and associativity.  
  
<P> 
 function is the user-defined function, which must have the  
following four arguments:  invec, inoutvec, len and  datatype.  
<P> 
The   
ISO C   
prototype for the function is the following.  
<P> 
 <tt> typedef void MPI_User_function(void *invec, void *inoutvec, int *len, MPI_Datatype *datatype); <BR></tt>  
  
The Fortran declaration of the user-defined function appears below.  
  
<P> 
 <tt> SUBROUTINE USER_FUNCTION(INVEC, INOUTVEC, LEN, TYPE) <BR> &lt;type&gt; INVEC(LEN), INOUTVEC(LEN) <BR>INTEGER LEN, TYPE <BR></tt>  
  
The C++ declaration of the user-defined function appears below.  
<P> 
 <tt> typedef void MPI::User_function(const void* invec, void *inoutvec, int len, const Datatype&amp; datatype); <BR></tt>  
  
The  datatype argument  
is a handle to the data type that was passed into the call  
to  MPI_REDUCE.  
The user reduce function should be written such that the following  
holds:  
Let  u[0], ... , u[len-1] be the  len elements in the  
communication buffer described by the arguments  invec, len  
and  datatype when the function is invoked;  
let  v[0], ... , v[len-1] be  len elements in the  
communication buffer described by the arguments  inoutvec, len  
and  datatype when the function is invoked;  
let  w[0], ... , w[len-1] be   len elements in the  
communication buffer described by the arguments  inoutvec, len  
and  datatype when the function returns;  
then  w[i] = u[i]<I>&#176;</I>v[i], for  i=0 , ... , len-1,  
where <I>&#176;</I> is the reduce operation that the function computes.  
<P> 
Informally, we can think of  
 invec and  inoutvec as arrays of  len elements that  
 function  
is combining.  The result of the reduction over-writes values in  
 inoutvec, hence the name.  Each invocation of the function results in  
the pointwise evaluation of the reduce operator on  len  
elements:  
I.e, the function returns in  inoutvec[i] the value  
<I> invec[i] &#176; inoutvec[i]</I>, for <I> i=0, ... , count-1</I>,  
where <I> &#176;</I> is the combining operation computed by the function.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The   
 len   
argument allows  
 MPI_REDUCE to avoid calling the function for each element  
in the input buffer.  Rather, the system can choose to apply  
the function to chunks of input.  In C, it is passed in as  
a reference for reasons of compatibility with Fortran.  
<P> 
By internally comparing the value of the  datatype argument to  
known, global handles,  
it is possible to overload the use of a single user-defined function  
for several, different data types.  
 (<em> End of rationale.</em>) <BR> 
General datatypes may be passed to the user function.  
However, use of datatypes that are not contiguous is likely to lead to  
inefficiencies.  
<P> 
No  MPI communication function may be called inside the user function.  
 MPI_ABORT may be called inside the  
function in case of an error.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Suppose one defines a library of user-defined reduce  
functions that are overloaded: the  datatype argument is used  
to select the right execution path at each invocation, according to  
the types of the operands.  
The user-defined reduce function cannot ``decode'' the  
 datatype argument that it is passed, and cannot identify,  
by itself, the correspondence between the datatype handles and the datatype  
they represent.  This correspondence was established when the datatypes  
were created.  Before the library is used, a library initialization  
preamble must be executed.  This preamble code will define the  
datatypes that are used by the library, and store handles to these  
datatypes in global, static variables that are shared by the user code and the  
library code.  
<P> 
The Fortran version of  MPI_REDUCE will invoke a user-defined reduce  
function using the Fortran calling conventions and will pass a Fortran-type  
datatype argument;  the C version will use C calling convention and the C  
representation of a datatype handle.  Users who plan to mix languages should  
define their reduction functions accordingly.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
We outline below a naive and inefficient implementation of  MPI_REDUCE  
not   
supporting the ``in place'' option.  
  
<BR> 
<pre><tt>        MPI_Comm_size(comm, &amp;groupsize); 
        MPI_Comm_rank(comm, &amp;rank); 
        if (rank &gt; 0) { 
            MPI_Recv(tempbuf, count, datatype, rank-1,...); 
            User_reduce(tempbuf, sendbuf, count, datatype); 
        } 
        if (rank &lt; groupsize-1) { 
            MPI_Send(sendbuf, count, datatype, rank+1, ...); 
        } 
        /* answer now resides in process groupsize-1 ... now send to root 
         */ 
        if (rank == root) { 
            MPI_Irecv(recvbuf, count, datatype, groupsize-1,..., &amp;req); 
        } 
        if (rank == groupsize-1) { 
            MPI_Send(sendbuf, count, datatype, root, ...); 
        } 
        if (rank == root) { 
            MPI_Wait(&amp;req, &amp;status); 
        } 
</tt></pre> 
The reduction computation proceeds, sequentially, from process <tt> 0</tt>  
to process   
<tt> groupsize-1</tt>.    
This order is chosen so as to respect  
the order of a possibly non-commutative operator defined by the  
function <tt> User_reduce()</tt>.  
A more efficient implementation is achieved by taking advantage  
of associativity and  
using a logarithmic tree reduction.  Commutativity can be used  
to advantage, for those cases in which the  commute argument  
to  MPI_OP_CREATE is true.  Also, the amount of temporary buffer  
required can be reduced, and communication can be pipelined with  
computation, by transferring and reducing the elements in chunks of  
size <tt> len</tt> <I>&lt;</I><tt> count</tt>.  
<P> 
The predefined reduce operations can be implemented as a library of  
user-defined operations.  However, better performance might be  
achieved if  MPI_REDUCE handles these functions as a special  
case.  
 (<em> End of advice to implementors.</em>) <BR> 
  
<TABLE><TR><TD COLSPAN=2>MPI_OP_FREE( op)</TD></TR>  
<TR><TD> INOUT op</TD><TD> operation (handle) </TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_op_free( MPI_Op *op) <BR></tt>  
<P> 
 <tt> MPI_OP_FREE( OP, IERROR) <BR> INTEGER OP, IERROR <BR></tt>  
 <tt> void MPI::Op::Free() <BR></tt>  
  
Marks a user-defined reduction operation for deallocation and sets  
 op to  MPI_OP_NULL.  
<P> 
<menu> 
</menu> 

<P>
<HR>
<A HREF="node104.htm#Node104"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node100.htm#Node100"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node105.htm#Node106"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node100.htm#Node100"> Global Reduction Operations</a>
<b>Next: </b><A HREF="node105.htm#Node106"> Example of User-defined Reduce</a>
<b>Previous: </b><A HREF="node104.htm#Node104"> MINLOC and MAXLOC</a>
<P>
<HR><H3><A NAME="Node106">104.1. Example of User-defined Reduce</a></H3>
<A HREF="node105.htm#Node105"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node105.htm#Node105"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node107.htm#Node107"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node105.htm#Node105"> User-Defined Reduction Operations</a>
<b>Next: </b><A HREF="node107.htm#Node107"> All-Reduce</a>
<b>Previous: </b><A HREF="node105.htm#Node105"> User-Defined Reduction Operations</a>
<P>
  
<P> 
It is time for an example of user-defined reduction.  
The example in this section uses an intracommunicator.  
  
<BR><b> Example</b>   
  
  
  
Compute the product of an array of complex numbers, in C.  
<P> 
<BR> 
<pre><tt>typedef struct { 
    double real,imag; 
} Complex; 
 
/* the user-defined function 
 */ 
void myProd( Complex *in, Complex *inout, int *len, MPI_Datatype *dptr ) 
{ 
    int i; 
    Complex c; 
 
    for (i=0; i&lt; *len; ++i) { 
        c.real = inout-&gt;real*in-&gt;real - 
                   inout-&gt;imag*in-&gt;imag; 
        c.imag = inout-&gt;real*in-&gt;imag + 
                   inout-&gt;imag*in-&gt;real; 
        *inout = c; 
        in++; inout++; 
    } 
} 
 
/* and, to call it... 
 */ 
... 
 
    /* each process has an array of 100 Complexes 
     */ 
    Complex a[100], answer[100]; 
    MPI_Op myOp; 
    MPI_Datatype ctype; 
 
    /* explain to MPI how type Complex is defined 
     */ 
    MPI_Type_contiguous( 2, MPI_DOUBLE, &amp;ctype ); 
    MPI_Type_commit( &amp;ctype ); 
    /* create the complex-product user-op 
     */ 
    MPI_Op_create( myProd, True, &amp;myOp ); 
 
    MPI_Reduce( a, answer, 100, ctype, myOp, root, comm ); 
 
    /* At this point, the answer, which consists of 100 Complexes, 
     * resides on process root 
     */ 
</tt></pre> 
   
  

<P>
<HR>
<A HREF="node105.htm#Node105"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node105.htm#Node105"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node107.htm#Node107"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node105.htm#Node105"> User-Defined Reduction Operations</a>
<b>Next: </b><A HREF="node107.htm#Node107"> All-Reduce</a>
<b>Previous: </b><A HREF="node105.htm#Node105"> User-Defined Reduction Operations</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
