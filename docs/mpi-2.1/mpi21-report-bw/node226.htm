<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-one-side/one-side-2.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Window Creation</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node226">210. Window Creation</a></H2>
<A HREF="node225.htm#Node225"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node225.htm#Node225"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node227.htm#Node227"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node225.htm#Node225"> Initialization</a>
<b>Next: </b><A HREF="node227.htm#Node227"> Window Attributes</a>
<b>Previous: </b><A HREF="node225.htm#Node225"> Initialization</a>
<P>
  
The initialization operation allows each process in an  
intracommunicator  
  
group to specify, in a collective operation, a ``window'' in its  
memory that is made accessible to accesses by remote   
processes.  
The call returns an opaque object  
that represents the group of  
processes that own and access the set of windows,  
and the attributes of each window, as specified by the initialization call.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_CREATE(base, size, disp_unit, info, comm, win)</TD></TR>  
<TR><TD> IN base</TD><TD>initial address of window (choice)</TD></TR>  
<TR><TD> IN size</TD><TD>size of window in bytes (nonnegative integer)</TD></TR>  
<TR><TD> IN disp_unit</TD><TD>local unit size for displacements, in bytes (positive integer)</TD></TR>  
<TR><TD> IN info</TD><TD>info argument (handle)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT win</TD><TD>window object returned by the call (handle)</TD></TR>  
</TABLE>  
<P> 
   
 <tt> int MPI_Win_create(void *base, MPI_Aint size, int disp_unit, MPI_Info info, MPI_Comm comm, MPI_Win *win) <BR></tt>  
<P> 
 <tt> MPI_WIN_CREATE(BASE, SIZE, DISP_UNIT, INFO, COMM, WIN, IERROR)<BR>  &lt;type&gt; BASE(*) <BR>INTEGER(KIND=MPI_ADDRESS_KIND) SIZE  <BR>INTEGER DISP_UNIT, INFO, COMM, WIN, IERROR <BR></tt>  
<P> 
  
 <tt> static MPI::Win MPI::Win::Create(const void* base, MPI::Aint size, int disp_unit, const MPI::Info&amp; info, const MPI::Intracomm&amp; comm) <BR></tt>  
  
<P> 
This is a collective call executed by all processes in the group of  
 comm.  It returns a window object that can be used by these  
processes to perform  RMA operations.  Each process specifies  
a window of existing memory that it exposes to  RMA accesses by the  
processes in the group of  
  comm.  
The window consists of  size bytes,  
starting at address  base.  
A process may elect to expose no memory by  
specifying  size = 0.  
<P> 
The displacement unit argument  
is provided to facilitate address arithmetic in  RMA  
operations: the target displacement argument of an  RMA operation is  
scaled by the factor  disp_unit specified by the target  
process, at window creation.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The window size is specified using an address sized integer, so as to  
allow windows that span more than 4 GB of address space.  (Even if  
the physical memory size is less than 4 GB, the address range  
may be larger than 4 GB, if addresses are not contiguous.)  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
Common choices for  disp_unit  
are 1 (no scaling), and (in C syntax) <tt> sizeof(type)</tt>, for a  
window that consists of an array of elements of type <tt> type</tt>.  The  
later choice will allow one to use array indices in  RMA calls, and have those scaled correctly to byte displacements, even in a heterogeneous environment.  
 (<em> End of advice to users.</em>) <BR> 
The  info argument  provides  
optimization hints to the runtime about the expected  
usage pattern of the window.  
The following info key is  predefined:  
<P> 
<dl> 
 
<dt> 
<b> </b><dd> 
 no_locks --- if  set to  true,  
then the implementation may assume that the  
local window is never locked (by a call to  MPI_WIN_LOCK).  
This implies that this window is not used for  
3-party communication, and  RMA can be implemented with no (less)  
asynchronous  
agent activity at this process.  
</dl> 
<BR> 
The various processes in the group of  
 comm may specify completely different  
target windows, in location, size, displacement units and info arguments.  
As long as all the get, put and accumulate accesses   
to a particular process fit their  
specific target window this should pose no problem.  
The same area in memory may appear in multiple windows, each  
associated with a different window object.  However, concurrent  
communications to distinct, overlapping windows may lead to  
erroneous results.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
A window can be created in any part of the process memory.  However,  
on some systems, the performance of windows in  
memory allocated by  MPI_ALLOC_MEM   
(Section <a href="node181.htm#Node181">Memory Allocation 
</a>,   
page <a href="node181.htm#Node181">Memory Allocation 
</a>) will be better.  
Also, on some systems, performance is improved when window boundaries  
are aligned at ``natural'' boundaries (word, double-word, cache line,  
page frame, etc.).  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
In cases where  RMA operations use different mechanisms in different  
memory areas (e.g., load/store in a shared memory segment, and an  
asynchronous handler in private memory), the  MPI_WIN_CREATE  
call needs to figure out which type of memory is used for the  
window.  To do so,  MPI maintains, internally, the  
list of memory segments allocated by  MPI_ALLOC_MEM, or by  
other, implementation specific, mechanisms, together with information  
on the type of memory segment allocated.  When a call to   
 MPI_WIN_CREATE occurs, then  MPI checks which segment  
contains each window, and decides, accordingly, which mechanism to use  
for  RMA operations.  
<P> 
Vendors may provide additional, implementation-specific mechanisms to  
allow  ``good'' memory to be used for static variables.  
<P> 
Implementors should document any performance impact of window alignment.  
 (<em> End of advice to implementors.</em>) <BR> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_FREE(win)</TD></TR>  
<TR><TD> INOUT win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Win_free(MPI_Win *win) <BR></tt>  
<P> 
 <tt> MPI_WIN_FREE(WIN, IERROR)<BR> INTEGER WIN, IERROR <BR></tt>  
<P> 
  
 <tt> void MPI::Win::Free() <BR></tt>  
  
<P> 
Frees the window object  win and returns a null handle  
(equal to  MPI_WIN_NULL).  
This is a collective call executed by all processes in the group  
associated with  win.  MPI_WIN_FREE(win) can be  
invoked by a process only after it has completed its involvement in  
 RMA communications on window  win: i.e., the process has  
called  MPI_WIN_FENCE, or called  
 MPI_WIN_WAIT to match a previous call to  
 MPI_WIN_POST or called  MPI_WIN_COMPLETE to  
match a previous call to  MPI_WIN_START or called  
 MPI_WIN_UNLOCK to match a previous call to   
 MPI_WIN_LOCK.  
When the call returns, the window memory can be freed.  
<P> 
  
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
 MPI_WIN_FREE requires a barrier synchronization: no process  
can return from free until all processes in the group of  win  
called free.  This, to ensure that no process will attempt to access a  
remote window (e.g., with lock/unlock) after it was freed.  
 (<em> End of advice to implementors.</em>) <BR> 
  
<P> 

<P>
<HR>
<A HREF="node225.htm#Node225"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node225.htm#Node225"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node227.htm#Node227"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node225.htm#Node225"> Initialization</a>
<b>Next: </b><A HREF="node227.htm#Node227"> Window Attributes</a>
<b>Previous: </b><A HREF="node225.htm#Node225"> Initialization</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
