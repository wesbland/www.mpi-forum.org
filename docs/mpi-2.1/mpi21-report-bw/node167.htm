<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-topol/topol.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>General (Graph) Constructor</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node167">159. General (Graph) Constructor</a></H2>
<A HREF="node166.htm#Node166"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node164.htm#Node164"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node168.htm#Node168"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node164.htm#Node164"> Topology Constructors</a>
<b>Next: </b><A HREF="node168.htm#Node168"> Topology Inquiry Functions</a>
<b>Previous: </b><A HREF="node166.htm#Node166"> Cartesian Convenience Function:  MPI_DIMS_CREATE</a>
<P>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_CREATE(comm_old, nnodes, index, edges, reorder, comm_graph)</TD></TR>  
  
<TR><TD> IN  comm_old</TD><TD> input communicator (handle)</TD></TR>  
  
<TR><TD> IN  nnodes</TD><TD> number of nodes in graph (integer)</TD></TR>  
<TR><TD> IN  index</TD><TD>array of integers describing node degrees (see below)</TD></TR>  
<TR><TD> IN  edges</TD><TD>array of integers describing graph edges (see below)</TD></TR>  
<TR><TD> IN  reorder</TD><TD> ranking may be reordered ( true) or not ( false) (logical)</TD></TR>  
<TR><TD> OUT  comm_graph</TD><TD> communicator with graph topology added (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Graph_create(MPI_Comm comm_old, int nnodes, int *index, int *edges, int reorder, MPI_Comm *comm_graph) <BR></tt>  
<P> 
 <tt> MPI_GRAPH_CREATE(COMM_OLD, NNODES, INDEX, EDGES, REORDER, COMM_GRAPH, IERROR)<BR> INTEGER COMM_OLD, NNODES, INDEX(*), EDGES(*), COMM_GRAPH, IERROR <BR>LOGICAL REORDER <BR></tt>  
 <tt> MPI::Graphcomm MPI::Intracomm::Create_graph(int nnodes, const int index[], const int edges[], bool reorder) const <BR></tt>  
  
 MPI_GRAPH_CREATE returns a handle to a new communicator to which the  
graph topology information is attached.  If  reorder = false then the  
rank of each process in the new group is identical to its rank in the old  
group.  Otherwise, the function may reorder the processes.  If the size,  
 nnodes, of the graph is smaller than the size of the group of  
 comm, then some processes are returned  MPI_COMM_NULL, in  
analogy to  MPI_CART_CREATE and  MPI_COMM_SPLIT.  
If the graph is empty, i.e.,  nnodes == 0,   
then  MPI_COMM_NULL is returned in all processes.   
The call  
is erroneous if it specifies a graph that is larger than the group size of the  
input communicator.  
<P> 
The three parameters  nnodes, index and  edges define the graph  
structure.  
 nnodes is the number of nodes of the graph.   The nodes are numbered  
from <tt> 0</tt> to <tt> nnodes-1</tt>.  
The   
<tt> i</tt>-th   
entry of array  index stores the total number of  
neighbors of the first <tt> i</tt> graph nodes.   The lists of neighbors of  
nodes <tt> 0, 1, ..., nnodes-1</tt> are stored in consecutive locations in array  
 edges.  The array  edges is a flattened representation  
of the edge lists.  
The total number of entries in  index is  nnodes and  
the total number of entries in  edges is equal to the number of  
graph edges.  
<P> 
The definitions of the arguments <tt> nnodes</tt>, <tt> index</tt>, and  
<tt> edges</tt> are illustrated with the following simple example.  
<P> 
<BR><b> Example</b>   
  
  
<P> 
Assume there are four processes 0, 1, 2, 3 with the following  
adjacency matrix: <BR>  
  
<TABLE><TR><TD ALIGN="CENTER">  
process</TD><TD ALIGN="LEFT"> neighbors </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
0</TD><TD ALIGN="LEFT"> 1, 3      </TD></TR> 
<TR><TD ALIGN="CENTER">  
1</TD><TD ALIGN="LEFT"> 0         </TD></TR> 
<TR><TD ALIGN="CENTER">  
2</TD><TD ALIGN="LEFT"> 3         </TD></TR> 
<TR><TD ALIGN="CENTER">  
3</TD><TD ALIGN="LEFT"> 0, 2      </TD></TR> 
<TR><TD ALIGN="CENTER">  
  
</TD></TR></TABLE> 
  
<P> 
Then, the input arguments are: <BR>  
  
<TABLE><TR><TD ALIGN="LEFT">nnodes =</TD><TD ALIGN="LEFT"> 4 </TD></TR> 
<TR><TD ALIGN="LEFT">  
index =</TD><TD ALIGN="LEFT"> 2, 3, 4, 6 </TD></TR> 
<TR><TD ALIGN="LEFT">  
edges =</TD><TD ALIGN="LEFT"> 1, 3, 0, 3, 0, 2  
</TD></TR></TABLE> 
  
<P> 
Thus, in C, <tt> index[0]</tt> is the degree of node zero, and <tt> index[i] -  
index[i-1]</tt> is the degree of node <tt> i, i=1, ..., nnodes-1</tt>;  
the list of neighbors of node zero is stored in <tt> edges[j]</tt>, for  
<IMG WIDTH=81 HEIGHT=11 SRC="img80.gif">
 and the list of neighbors of node <tt> i</tt>,  
<I> i &gt; 0</I>,  
is stored in <tt> edges[j]</tt>, <IMG WIDTH=156 HEIGHT=11 SRC="img81.gif">
.  
<P> 
In Fortran, <tt> index(1)</tt> is the degree of node zero, and <tt> index(i+1) -  
index(i)</tt> is the degree of node <tt> i, i=1, ..., nnodes-1</tt>;  
the list of neighbors of node zero is stored in <tt> edges(j)</tt>, for  
<IMG WIDTH=7 HEIGHT=9 SRC="img82.gif">
 and the list of neighbors of node  
<tt> i</tt>, <I> i &gt; 0</I>,  
is stored in <tt> edges(j)</tt>, <IMG WIDTH=7 HEIGHT=9 SRC="img83.gif">
.  
<P> 
   
<P> 
A single process is allowed to be defined multiple times in the list of  
neighbors of a process (i.e., there may be multiple edges between two  
processes). A process is also allowed to be a neighbor to itself (i.e., a self  
loop in the graph). The adjacency matrix is allowed to be non-symmetric.  
 
<BR> 
<em> Advice to users.</em>  
 <P> 
Performance implications of using multiple edges or a non-symmetric  
adjacency matrix are not defined. The definition of a node-neighbor  
edge does not imply a direction of the communication.  
 (<em> End of advice to users.</em>) <BR> 
  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
The following topology information is likely to be stored with a communicator:  
<ul> 
 
<li>Type of topology (Cartesian/graph),  
 
<li>For a Cartesian topology:  
   <ol> 
    
1. ndims (number of dimensions),  
    
<BR> 
2. dims (numbers of processes per coordinate direction),  
    
<BR> 
3. periods (periodicity information),  
    
<BR> 
4. own_position (own position in grid, could also be computed  
                          from rank and dims)  
   </ol> 
 
<li>For a graph topology:  
   <ol> 
    
1. index,  
    
<BR> 
2. edges,  
   </ol> 
which are the vectors defining the graph structure.  
</ul> 
<BR> 
For a graph structure the number of nodes is equal to the number of processes  
in the group. Therefore, the number of nodes does not have to be stored explicitly.  An  
additional zero entry at the start of array  index simplifies  
access to the topology information.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node166.htm#Node166"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node164.htm#Node164"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node168.htm#Node168"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node164.htm#Node164"> Topology Constructors</a>
<b>Next: </b><A HREF="node168.htm#Node168"> Topology Inquiry Functions</a>
<b>Previous: </b><A HREF="node166.htm#Node166"> Cartesian Convenience Function:  MPI_DIMS_CREATE</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
