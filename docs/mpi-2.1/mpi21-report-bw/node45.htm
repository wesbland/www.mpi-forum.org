<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Return Status</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node45">45. Return Status</a></H2>
<A HREF="node44.htm#Node44"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node40.htm#Node40"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node46.htm#Node46"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node40.htm#Node40"> Blocking Send and Receive Operations</a>
<b>Next: </b><A HREF="node46.htm#Node46"> Passing  MPI_STATUS_IGNORE for Status</a>
<b>Previous: </b><A HREF="node44.htm#Node44"> Blocking Receive</a>
<P>
  
<P> 
The source or tag of a received message may not be known if wildcard  
values were used in the receive operation.  
  
Also, if multiple requests  
are completed by a single  MPI function (see  
Section <a href="node60.htm#Node60">Multiple Completions 
</a>), a distinct error code may need to be  
returned for each request.  
The information is returned by the  status  
argument of  MPI_RECV.  The type of  status is  
 MPI-defined.  
Status variables need to be explicitly  
allocated by the user, that is, they are not system objects.  
<P> 
In C,  status is a structure that contains three fields named  
 MPI_SOURCE,  MPI_TAG, and  MPI_ERROR; the  
structure may contain additional fields.  Thus,  status.MPI_SOURCE,  
 status.MPI_TAG and  status.MPI_ERROR contain the  
source, tag, and error code, respectively, of  
the received message.  
<P> 
In Fortran,  status is an array of <tt> INTEGER</tt>s of size  
 MPI_STATUS_SIZE.  The constants  MPI_SOURCE,  
 MPI_TAG and  MPI_ERROR  
are the indices of the entries that store the  
source, tag and error fields.  Thus,  status(MPI_SOURCE),  
 status(MPI_TAG) and  status(MPI_ERROR)  
contain, respectively, the source,  
tag and error code of the received message.  
 <P> 
In C++, the  status object is handled through the following methods:  
   
 <tt> int MPI::Status::Get_source() const <BR></tt>  
 <tt> void MPI::Status::Set_source(int source) <BR></tt>  
 <tt> int MPI::Status::Get_tag() const <BR></tt>  
 <tt> void MPI::Status::Set_tag(int tag) <BR></tt>  
 <tt> int MPI::Status::Get_error() const <BR></tt>  
 <tt> void MPI::Status::Set_error(int error) <BR></tt>  
  
In general, message-passing calls do not modify the value of the error  
code field of status variables.  This field may be updated only by  
the functions in Section <a href="node60.htm#Node60">Multiple Completions 
</a> which return multiple  
statuses.  The field is updated if and only if such function returns with  
an error code of  MPI_ERR_IN_STATUS.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
The error field in status is not needed for calls that return only one  
status, such as  MPI_WAIT, since that would only duplicate the  
information returned by the function itself.  The current design  
avoids the additional overhead of setting it, in such cases.  The field  
is needed for calls that return multiple statuses, since each request  
may have had a different failure.  
 (<em> End of rationale.</em>) <BR> 
  
<P> 
The status argument also returns information on the length of the message  
received.  However, this information is not directly available as a field  
of the status variable and a call to  MPI_GET_COUNT is required  
to ``decode'' this information.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GET_COUNT(status, datatype, count)</TD></TR>  
<TR><TD> IN status</TD><TD>return status of receive operation (Status)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each receive buffer entry (handle)</TD></TR>  
<TR><TD> OUT count</TD><TD>number of received entries (integer)</TD></TR>  
</TABLE>  
<P> 
  
 <tt> int MPI_Get_count(MPI_Status *status, MPI_Datatype datatype, int *count) <BR></tt>  
  
<P> 
 <tt> MPI_GET_COUNT(STATUS, DATATYPE, COUNT, IERROR)<BR> INTEGER  STATUS(MPI_STATUS_SIZE), DATATYPE, COUNT, IERROR <BR></tt>  
 <tt> int MPI::Status::Get_count(const MPI::Datatype&amp; datatype) const <BR></tt>  
  
  
Returns the number of entries received.  (Again, we count <em> entries</em>, each of  
type <em> datatype</em>, not <em> bytes</em>.)  
The  datatype argument should match  
the argument provided by the receive call that set the  status variable.  
(We shall later see, in Section <a href="node78.htm#Node78">Use of General Datatypes in Communication 
</a>, that  
 MPI_GET_COUNT may return, in certain situations, the value  
 MPI_UNDEFINED.)  
  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
Some message-passing libraries use   INOUT  count,  
 tag and  source arguments, thus using them both to specify  
the selection criteria for incoming messages and return the actual envelope  
values of the received message.  
The use of a separate status argument prevents errors that are often attached  
with   INOUT argument (e.g., using the  
 MPI_ANY_TAG constant as  
the tag in a receive).  
Some libraries use calls that refer implicitly to the ``last message  
received.''  This is not thread safe.  
<P> 
The  datatype argument is passed to  MPI_GET_COUNT so as to  
improve performance. A message might be received without counting the number  
of elements it contains, and the count value is often not needed.  
Also, this allows the same function to be used after a call to  
  
 MPI_PROBE or  MPI_IPROBE. With a status from  MPI_PROBE or  MPI_IPROBE,  
the same datatypes are allowed as in a call to  MPI_RECV to receive this message.  
 (<em> End of rationale.</em>) <BR> 
The value returned as the  count argument of  
 MPI_GET_COUNT for a datatype of length zero where zero bytes  
have been transferred is zero.  If the number of bytes transfered is  
greater than zero,  MPI_UNDEFINED is returned.  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
Zero-length datatypes may be created in a number of cases.    
An important case is  
 MPI_TYPE_CREATE_DARRAY, where the  
definition of the particular   
darray   
results in an empty block on some  
 MPI process.  Programs written in an SPMD style will not check for  
this special case and may want to use  MPI_GET_COUNT to check  
the status.    
 (<em> End of rationale.</em>) <BR> 
   
  
 
<BR> 
<em> Advice to users.</em>  
<P> 
The buffer size required for the receive can be affected by data conversions and  
by the stride of the receive datatype.  
In most cases, the safest approach is to use the same datatype with  MPI_GET_COUNT and the receive.  
 (<em> End of advice to users.</em>) <BR> 
  
All send and receive operations use the  buf,  count,   
datatype,  source,  dest,  tag,  
 comm and  status arguments in the same way as the blocking  
 MPI_SEND and  
 MPI_RECV operations described in this section.  
  
  
  

<P>
<HR>
<A HREF="node44.htm#Node44"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node40.htm#Node40"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node46.htm#Node46"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node40.htm#Node40"> Blocking Send and Receive Operations</a>
<b>Next: </b><A HREF="node46.htm#Node46"> Passing  MPI_STATUS_IGNORE for Status</a>
<b>Previous: </b><A HREF="node44.htm#Node44"> Blocking Receive</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
