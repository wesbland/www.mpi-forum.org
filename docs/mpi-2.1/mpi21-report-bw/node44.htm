<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Blocking Receive</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node44">44. Blocking Receive</a></H2>
<A HREF="node43.htm#Node43"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node40.htm#Node40"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node45.htm#Node45"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node40.htm#Node40"> Blocking Send and Receive Operations</a>
<b>Next: </b><A HREF="node45.htm#Node45"> Return Status</a>
<b>Previous: </b><A HREF="node43.htm#Node43"> Message Envelope</a>
<P>
  
<P> 
The syntax of the blocking receive operation is given below.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_RECV (buf, count, datatype, source, tag, comm, status)</TD></TR>  
<TR><TD> OUT buf</TD><TD>initial address of receive buffer (choice)</TD></TR>  
<TR><TD> IN count</TD><TD>number of elements in receive buffer (non-negative  
integer)</TD></TR>  
<TR><TD> IN datatype</TD><TD>datatype of each receive buffer element (handle)</TD></TR>  
<TR><TD> IN source</TD><TD>rank of source (integer)</TD></TR>  
<TR><TD> IN tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT status</TD><TD>status object (Status)</TD></TR>  
</TABLE>  
<P> 
   
 <tt> int MPI_Recv(void* buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status) <BR></tt>  
<P> 
 <tt> MPI_RECV(BUF, COUNT, DATATYPE, SOURCE, TAG, COMM, STATUS, IERROR)<BR> &lt;type&gt; BUF(*) <BR>INTEGER  COUNT, DATATYPE, SOURCE, TAG, COMM, STATUS(MPI_STATUS_SIZE), IERROR <BR></tt>  
 <tt> void MPI::Comm::Recv(void* buf, int count, const MPI::Datatype&amp; datatype, int source, int tag, MPI::Status&amp; status) const <BR></tt>  
 <tt> void MPI::Comm::Recv(void* buf, int count, const MPI::Datatype&amp; datatype, int source, int tag) const <BR></tt>  
  
The blocking semantics of this call are described in Section <a href="node51.htm#Node51">Communication Modes 
</a>.  
<P> 
The receive buffer consists of  
the storage containing  count consecutive elements of the type  
specified by  datatype, starting at address  buf.  
The length of the received message must be less than or equal to the length of  
the receive buffer. An overflow error occurs if all incoming data does  
not fit, without truncation, into the receive buffer.  
<P> 
If a  
message that is shorter than the receive buffer arrives, then only those  
locations corresponding to the (shorter) message are modified.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
The  MPI_PROBE function described in  
Section <a href="node62.htm#Node62">Probe and Cancel 
</a> can be used to receive messages of  
unknown length.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Even though no specific behavior is mandated by  MPI for erroneous programs, the  
recommended handling of overflow situations is to return in  
 status information about the  
source and tag of the incoming message.  The receive operation will return an  
error code.  A quality implementation will also ensure that no memory  
that is outside the receive buffer will ever be overwritten.  
<P> 
In the case of a message shorter than the receive buffer,  MPI is  
quite strict in that it allows no modification of the other locations.  
A more lenient statement would allow for some  
optimizations but this is not allowed.  The implementation must be ready to  
end a copy into the receiver memory exactly at the end of the receive  
buffer, even if it is an odd address.  
 (<em> End of advice to implementors.</em>) <BR> 
The selection of a message by a receive operation is governed by  
the value of the message envelope.  
A message can be received by a receive operation  
if its envelope matches the  source,  tag and  
 comm values specified by the  
receive operation.  The receiver may specify a wildcard  
 MPI_ANY_SOURCE  
value for  source, and/or  
a wildcard   MPI_ANY_TAG value for  tag,  
indicating that any source and/or tag are acceptable.   It cannot specify a  
wildcard value for  comm.  
Thus, a message can be received by a receive  
operation only if it is addressed  
to the receiving process, has a matching communicator, has  
matching source unless  
source= MPI_ANY_SOURCE  
in the pattern, and has a matching tag unless   
tag= MPI_ANY_TAG   
in the pattern.  
<P> 
The message tag is specified by the  tag argument of the  
receive operation.  
The argument  source, if different from  MPI_ANY_SOURCE,  
is specified as a rank within the process group associated  
with that same communicator (remote process group, for intercommunicators).  
Thus, the range of valid values for the  
 source argument is  
 {0,...,n-1}<IMG WIDTH=7 HEIGHT=7 SRC="img1.gif">
 {MPI_ANY_SOURCE}, where  
 n is the number of processes in this group.  
<P> 
Note the asymmetry between send and receive operations:  A receive  
operation may  
accept messages from an arbitrary sender, on the other hand, a send operation  
must specify a unique receiver.  This matches a ``push'' communication  
mechanism, where data transfer is effected by the sender (rather than a  
``pull'' mechanism, where data transfer is effected by the receiver).  
<P> 
Source = destination is allowed, that is, a process can send a  
message to itself.  
(However, it is unsafe to do so with the blocking send and receive  
operations described above, since this may lead to deadlock. See  
Section <a href="node52.htm#Node52">Semantics of Point-to-Point Communication 
</a>.)  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Message context and other communicator information  
can be implemented as an additional tag field.  It differs  
from the regular message tag in that wild card matching is not allowed on this  
field, and that value setting for this field is controlled by communicator  
manipulation functions.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node43.htm#Node43"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node40.htm#Node40"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node45.htm#Node45"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node40.htm#Node40"> Blocking Send and Receive Operations</a>
<b>Next: </b><A HREF="node45.htm#Node45"> Return Status</a>
<b>Previous: </b><A HREF="node43.htm#Node43"> Message Envelope</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
