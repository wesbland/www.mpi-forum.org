<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-binding/binding-2.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>MPI Opaque Objects</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node357">316. MPI Opaque Objects</a></H2>
<A HREF="node356.htm#Node356"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node351.htm#Node351"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node358"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node351.htm#Node351"> Language Interoperability</a>
<b>Next: </b><A HREF="node357.htm#Node358"> Datatypes</a>
<b>Previous: </b><A HREF="node356.htm#Node356"> Status</a>
<P>
  
  
Unless said otherwise, opaque objects are ``the same'' in all languages:  
  
  
they carry the same information, and have the same meaning in both  
languages.  The mechanism described in the previous section can be  
used to pass references to  MPI objects from language to language.  
An object created in one language can be accessed, modified or freed  
in another language.  
<P> 
We examine below in more detail, issues that arise for each type of  
 MPI object.  
<P> 
<menu> 
</menu> 

<P>
<HR>
<A HREF="node356.htm#Node356"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node351.htm#Node351"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node358"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node351.htm#Node351"> Language Interoperability</a>
<b>Next: </b><A HREF="node357.htm#Node358"> Datatypes</a>
<b>Previous: </b><A HREF="node356.htm#Node356"> Status</a>
<P>
<HR><H3><A NAME="Node358">316.1. Datatypes</a></H3>
<A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node359"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node357.htm#Node359"> Callback Functions</a>
<b>Previous: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<P>
  
<P> 
  
Datatypes encode the same information in all languages.  E.g., a  
datatype accessor like  MPI_TYPE_GET_EXTENT will return the  
same information in all languages.  
  
If a datatype defined in  
one language is used for a communication call in another language, then the  
message sent will  
be identical to the message that would be sent from the first language: the  
same  
communication buffer is accessed, and the same representation  
conversion is performed, if needed.  
  
  
All predefined  
  
datatypes can be used in datatype constructors in any language. If  
a datatype is committed, it can be used for  
communication in any language.  
<P> 
The function  MPI_GET_ADDRESS returns the same value in  
all languages.  Note that we do not require that the  
constant  MPI_BOTTOM have the same value in all languages (see  
<a href="node365.htm#Node365">Constants 
</a>, page <a href="node365.htm#Node365">Constants 
</a>).  
  
<P> 
  
<BR><b> Example</b>  
  
 <BR> 
<pre><tt>! FORTRAN CODE 
REAL R(5) 
INTEGER TYPE, IERR, AOBLEN(1), AOTYPE(1) 
INTEGER (KIND=MPI_ADDRESS_KIND) AODISP(1) 
 
! create an absolute datatype for array R 
AOBLEN(1) = 5 
CALL MPI_GET_ADDRESS( R, AODISP(1), IERR) 
AOTYPE(1) = MPI_REAL 
CALL MPI_TYPE_CREATE_STRUCT(1, AOBLEN,AODISP,AOTYPE, TYPE, IERR) 
CALL C_ROUTINE(TYPE) 
</tt></pre> 
  
<BR> 
<pre><tt>/* C code */ 
 
void C_ROUTINE(MPI_Fint *ftype) 
{ 
   int count = 5; 
   int lens[2] = {1,1}; 
   MPI_Aint displs[2]; 
   MPI_Datatype types[2], newtype; 
    
   /* create an absolute datatype for buffer that consists   */ 
   /*  of count, followed by R(5)                            */ 
    
   MPI_Get_address(&amp;count, &amp;displs[0]); 
   displs[1] = 0; 
   types[0] = MPI_INT; 
   types[1] = MPI_Type_f2c(*ftype); 
   MPI_Type_create_struct(2, lens, displs, types, &amp;newtype); 
   MPI_Type_commit(&amp;newtype); 
    
   MPI_Send(MPI_BOTTOM, 1, newtype, 1, 0, MPI_COMM_WORLD); 
   /* the message sent contains an int count of 5, followed  */ 
   /* by the 5 REAL entries of the Fortran array R.          */ 
} 
</tt></pre> 
  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
  
The following implementation can be used:   MPI addresses, as  
returned by  MPI_GET_ADDRESS, will have  
the same value in all languages.  
  
One obvious choice is that  
 MPI addresses be identical to regular addresses.  
The address is stored in the  
datatype, when datatypes with absolute addresses are constructed.  
When a send or receive operation is performed, then addresses stored in  
a datatype are interpreted as displacements that are all augmented by  
a base address.  This base address is (the address of)  buf,  
or zero, if  buf = MPI_BOTTOM.  Thus, if  
 MPI_BOTTOM is zero then a send or  
receive call with  buf = MPI_BOTTOM is implemented  
exactly as a call with a regular buffer argument:  in both cases the  
base address is  buf.  
On the other  
hand, if  MPI_BOTTOM is not zero, then the  
implementation has to be slightly different.  A test is performed  
to check whether  buf = MPI_BOTTOM.  If true, then  
the base address is zero, otherwise it is  buf.  
  
In particular, if  MPI_BOTTOM does not have the same value in  
Fortran and C/C++, then an additional test for  buf = MPI_BOTTOM  
is needed in at least one of the languages.  
<P> 
It may be desirable to use a value other than zero for  
 MPI_BOTTOM even in C/C++, so as to distinguish it from a NULL  
pointer.  
  
If  MPI_BOTTOM = c then one can still avoid the test  
 buf = MPI_BOTTOM, by using the displacement from  
 MPI_BOTTOM, i.e., the regular address - c, as the  MPI address  
returned by  MPI_GET_ADDRESS and stored in absolute datatypes.  
 (<em> End of advice to implementors.</em>) <BR> 
  
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
<P> 
  

<P>
<HR>
<A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node359"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node357.htm#Node359"> Callback Functions</a>
<b>Previous: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<P>
<HR><H3><A NAME="Node359">316.2. Callback Functions</a></H3>
<A HREF="node357.htm#Node358"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node360"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node357.htm#Node360"> Error Handlers</a>
<b>Previous: </b><A HREF="node357.htm#Node358"> Datatypes</a>
<P>
 MPI calls may associate callback functions with  MPI  
objects: error handlers are associated with communicators and files, attribute copy  
and  
delete functions are associated with attribute keys, reduce operations  
are   
associated  
with operation objects, etc.  In a multilanguage  
environment, a function passed in an  MPI call in one language may be  
invoked by an  MPI call in another language.   MPI implementations  
must make sure that such invocation will use the calling convention of  
the language the function is bound to.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Callback functions need to have a language tag.  This tag is set  
when the callback function is passed in by the library function (which  
is presumably different for each language), and is used to generate  
the right calling sequence when the callback function is invoked.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node357.htm#Node358"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node360"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node357.htm#Node360"> Error Handlers</a>
<b>Previous: </b><A HREF="node357.htm#Node358"> Datatypes</a>
<P>
<HR><H3><A NAME="Node360">316.3. Error Handlers</a></H3>
<A HREF="node357.htm#Node359"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node361"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node357.htm#Node361"> Reduce Operations</a>
<b>Previous: </b><A HREF="node357.htm#Node359"> Callback Functions</a>
<P>
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Error handlers, have,  
in C and C++, a ``<tt> stdargs</tt>'' argument list.  
  
It might be useful to  
provide to the handler information on the language environment where  
the error occurred.  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node357.htm#Node359"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node361"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node357.htm#Node361"> Reduce Operations</a>
<b>Previous: </b><A HREF="node357.htm#Node359"> Callback Functions</a>
<P>
<HR><H3><A NAME="Node361">316.4. Reduce Operations</a></H3>
<A HREF="node357.htm#Node360"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node362"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node357.htm#Node362"> Addresses</a>
<b>Previous: </b><A HREF="node357.htm#Node360"> Error Handlers</a>
<P>
 
<BR> 
<em> Advice to users.</em>  
<P> 
Reduce operations receive as one of their arguments the datatype of the  
operands.  
  
Thus, one can define ``polymorphic'' reduce  
operations that work for C, C++, and Fortran datatypes.  
  
 (<em> End of advice to users.</em>) <BR> 

<P>
<HR>
<A HREF="node357.htm#Node360"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node357.htm#Node362"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node357.htm#Node362"> Addresses</a>
<b>Previous: </b><A HREF="node357.htm#Node360"> Error Handlers</a>
<P>
<HR><H3><A NAME="Node362">316.5. Addresses</a></H3>
<A HREF="node357.htm#Node361"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node363"> Attributes</a>
<b>Previous: </b><A HREF="node357.htm#Node361"> Reduce Operations</a>
<P>
  
<P> 
  
Some of the datatype accessors and constructors have arguments of type  
   
 MPI_Aint (in C) or  MPI::Aint in C++, to hold  
addresses.  The corresponding arguments, in Fortran, have type  
 INTEGER.  This causes Fortran and C/C++ to be incompatible,  
in an environment where addresses have 64 bits, but Fortran  
 INTEGERs have 32 bits.  
  
<P> 
This is a problem, irrespective of  
interlanguage issues.  Suppose that a Fortran process has an address  
space of <IMG WIDTH=7 HEIGHT=9 SRC="img115.gif">
 4 GB.  What should be the value returned in Fortran by  
 MPI_ADDRESS, for a variable with an address above <I>2<SUP>32</SUP></I>?  
The design described here addresses this issue, while maintaining  
compatibility with current Fortran codes.  
<P> 
  
The constant  MPI_ADDRESS_KIND is defined so that, in Fortran  
90,  
<BR>  
<tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt>)  
is an address sized integer type (typically, but not necessarily,  
the size of an <tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt> is 4 on 32 bit address machines and 8 on 64  
bit address machines).  
Similarly, the constant  
 MPI_INTEGER_KIND is defined so that  
<tt> INTEGER(KIND=MPI_INTEGER_KIND)</tt> is a default size  
 INTEGER.  
  
<P> 
There are seven functions that have address arguments:  
 MPI_TYPE_HVECTOR,  
<BR>  
 MPI_TYPE_HINDEXED,  
 MPI_TYPE_STRUCT,  
 MPI_ADDRESS,  
 MPI_TYPE_EXTENT  
<BR>  
  MPI_TYPE_LB and  
 MPI_TYPE_UB.  
<P> 
  
Four new functions are provided to supplement the first four functions  
in this list.  These functions are described in  
Section <a href="node68.htm#Node68">Type Constructors with Explicit Addresses 
</a> on page <a href="node68.htm#Node68">Type Constructors with Explicit Addresses 
</a>.  
The remaining three functions are supplemented by the  
new function  
  
 MPI_TYPE_GET_EXTENT, described in  
that same section.  
The new functions have the same functionality as the old functions  
  
in C/C++, or on Fortran systems where default  INTEGERs are  
address sized.  In Fortran, they accept arguments of type  
<tt> INTEGER(KIND=MPI_ADDRESS_KIND)</tt>,  
wherever arguments of type   
 MPI_Aint   
and  MPI::Aint   
are used in C  
and C++.  
On Fortran 77 systems that do not support the Fortran 90  
 KIND notation, and where addresses are  
64 bits whereas default  INTEGERs are 32 bits,  
these arguments will be  
of an appropriate integer type.  The old functions will continue to be  
provided, for backward compatibility.  However, users are encouraged to switch to  
the new functions, in Fortran, so as to avoid problems on systems with  
an address range <I>&gt; 2<SUP>32</SUP></I>, and to provide compatibility across languages.  
  
<P> 

<P>
<HR>
<A HREF="node357.htm#Node361"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node357.htm#Node357"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node363.htm#Node363"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node357.htm#Node357"> MPI Opaque Objects</a>
<b>Next: </b><A HREF="node363.htm#Node363"> Attributes</a>
<b>Previous: </b><A HREF="node357.htm#Node361"> Reduce Operations</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
