<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-context/context.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Group Constructors</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node125">123. Group Constructors</a></H2>
<A HREF="node124.htm#Node124"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node123.htm#Node123"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node126.htm#Node126"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node123.htm#Node123"> Group Management</a>
<b>Next: </b><A HREF="node126.htm#Node126"> Group Destructors</a>
<b>Previous: </b><A HREF="node124.htm#Node124"> Group Accessors</a>
<P>
  
Group constructors are used  
to subset and superset existing groups.  
These constructors construct new groups from existing groups.  
These are local operations, and distinct groups may be defined on  
different processes; a process may also define a group that does not  
include itself.  Consistent definitions are required when groups are  
used as arguments in communicator-building functions.   MPI does not  
provide a mechanism to build a group from scratch, but only from  
other, previously defined groups.  The base group, upon which all  
other groups are defined, is the group associated with the initial  
communicator  MPI_COMM_WORLD (accessible through  
the function  MPI_COMM_GROUP).  
<P> 
 
<BR> 
<em> Rationale.</em>  
<P> 
In what follows, there is no group duplication function analogous to  
 MPI_COMM_DUP, defined later in this chapter.  There is no need for  
a group duplicator.  A group, once created, can have several references to it  
by making copies of the handle.  The following constructors address the need  
for subsets and supersets of existing groups.  
 (<em> End of rationale.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
Each group constructor behaves as if it returned a new group object.  
When this new group is a copy of an existing group, then  
one can avoid creating such new objects, using  
a reference-count mechanism.  
 (<em> End of advice to implementors.</em>) <BR> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_GROUP(comm, group)</TD></TR>  
<TR><TD> IN comm</TD><TD> communicator (handle)</TD></TR>  
<TR><TD> OUT group</TD><TD> group corresponding to  comm (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Comm_group(MPI_Comm comm, MPI_Group *group) <BR></tt>  
<P> 
 <tt> MPI_COMM_GROUP(COMM, GROUP, IERROR)<BR> INTEGER COMM, GROUP, IERROR <BR></tt>  
 <tt> MPI::Group MPI::Comm::Get_group() const <BR></tt>  
  
 MPI_COMM_GROUP returns in  group a handle to the  
group of  comm.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_UNION(group1, group2, newgroup)</TD></TR>  
<TR><TD> IN group1</TD><TD> first group  (handle)</TD></TR>  
<TR><TD> IN group2</TD><TD> second group (handle)</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> union group (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_union(MPI_Group group1, MPI_Group group2, MPI_Group *newgroup) <BR></tt>  
<P> 
 <tt> MPI_GROUP_UNION(GROUP1, GROUP2, NEWGROUP, IERROR)<BR> INTEGER GROUP1, GROUP2, NEWGROUP, IERROR <BR></tt>  
 <tt> static MPI::Group MPI::Group::Union(const MPI::Group&amp; group1, const MPI::Group&amp; group2) <BR></tt>  
  
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_INTERSECTION(group1, group2, newgroup)</TD></TR>  
<TR><TD> IN group1</TD><TD> first group (handle)</TD></TR>  
<TR><TD> IN group2</TD><TD> second group  (handle)</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> intersection group (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_intersection(MPI_Group group1, MPI_Group group2, MPI_Group *newgroup) <BR></tt>  
<P> 
 <tt> MPI_GROUP_INTERSECTION(GROUP1, GROUP2, NEWGROUP, IERROR)<BR> INTEGER GROUP1, GROUP2, NEWGROUP, IERROR <BR></tt>  
 <tt> static MPI::Group MPI::Group::Intersect(const MPI::Group&amp; group1, const MPI::Group&amp; group2) <BR></tt>  
  
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_DIFFERENCE(group1, group2, newgroup)</TD></TR>  
<TR><TD> IN group1</TD><TD> first group (handle)</TD></TR>  
<TR><TD> IN group2</TD><TD> second group (handle)</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> difference group (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_difference(MPI_Group group1, MPI_Group group2, MPI_Group *newgroup) <BR></tt>  
<P> 
 <tt> MPI_GROUP_DIFFERENCE(GROUP1, GROUP2, NEWGROUP, IERROR)<BR> INTEGER GROUP1, GROUP2, NEWGROUP, IERROR <BR></tt>  
 <tt> static MPI::Group MPI::Group::Difference(const MPI::Group&amp; group1, const MPI::Group&amp; group2) <BR></tt>  
  
 The set-like operations are defined as follows:  
<dl> 
 
<dt> 
<b>union</b><dd> 
All elements of the first group ( group1), followed by  
all elements of second group ( group2) not in first.  
 
<dt> 
<b>intersect</b><dd> 
all elements of the first group that are also  
in the second group, ordered as in first group.  
 
<dt> 
<b>difference</b><dd> 
all elements of the first group that are not  
in the second group, ordered as in the first group.  
</dl> 
<BR> 
Note that for these operations the order of processes in the output  
group is determined primarily by order in the first group (if possible)  
and then, if necessary, by order in the second group.  Neither union nor  
intersection are commutative, but both are associative.  
<P> 
The new group can be empty, that is, equal to  
 MPI_GROUP_EMPTY.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_INCL(group, n, ranks, newgroup)</TD></TR>  
<TR><TD> IN group</TD><TD>  group (handle)</TD></TR>  
<TR><TD> IN n</TD><TD> number of elements in array ranks (and size of  newgroup) (integer)</TD></TR>  
<TR><TD> IN ranks</TD><TD>  ranks of processes in  group to appear in  newgroup (array of integers)</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> new group derived from above, in the order defined by   ranks (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_incl(MPI_Group group, int n, int *ranks, MPI_Group *newgroup) <BR></tt>  
<P> 
 <tt> MPI_GROUP_INCL(GROUP, N, RANKS, NEWGROUP, IERROR)<BR> INTEGER GROUP, N, RANKS(*), NEWGROUP, IERROR <BR></tt>  
 <tt> MPI::Group MPI::Group::Incl(int n, const int ranks[]) const <BR></tt>  
  
The function  MPI_GROUP_INCL creates a group  
 newgroup that consists of the  n processes in  
 group with ranks  rank[0],<I>...</I>, rank[n-1];  
the process with rank  i in  
 newgroup is the process with rank  ranks[i] in  
 group.  Each of the  n elements of  ranks must be a  
valid rank in  group and all elements must be distinct, or else the  
program is erroneous.  If  n<I>~=~0</I>, then  newgroup is  
 MPI_GROUP_EMPTY.  
This function can, for instance, be used to reorder the  
elements of a group.  See also  MPI_GROUP_COMPARE.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_EXCL(group, n, ranks, newgroup)</TD></TR>  
<TR><TD> IN group</TD><TD> group (handle)</TD></TR>  
<TR><TD> IN n</TD><TD> number of elements in array ranks (integer)</TD></TR>  
<TR><TD> IN ranks</TD><TD> array of integer ranks in  group not to appear in  newgroup</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> new group derived from above, preserving the order defined by   group (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_excl(MPI_Group group, int n, int *ranks, MPI_Group *newgroup) <BR></tt>  
<P> 
 <tt> MPI_GROUP_EXCL(GROUP, N, RANKS, NEWGROUP, IERROR)<BR> INTEGER GROUP, N, RANKS(*), NEWGROUP, IERROR <BR></tt>  
 <tt> MPI::Group MPI::Group::Excl(int n, const int ranks[]) const <BR></tt>  
  
The function  MPI_GROUP_EXCL creates a group of processes  
 newgroup that is obtained by deleting from  group  
those processes with ranks  
 ranks[0] ,<I>...</I> ranks[n-1].  
The ordering of processes in  newgroup is identical to the ordering  
in  group.  
Each of the  n elements of  ranks must be a valid  
rank in  group and all elements must be distinct; otherwise, the  
program is erroneous.  
If  n<I>~=~0</I>, then  newgroup is identical to  group.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_RANGE_INCL(group, n, ranges, newgroup)</TD></TR>  
<TR><TD> IN group</TD><TD>  group (handle)</TD></TR>  
<TR><TD> IN n</TD><TD> number of triplets in array  ranges (integer) </TD></TR>  
<TR><TD> IN ranges</TD><TD> a one-dimensional array of integer triplets, of the  
form (first rank, last rank, stride) indicating ranks in  
 group of processes to be included in  newgroup</TD></TR>  
<TR><TD> OUT newgroup</TD><TD> new group derived from above, in the  
order defined by  ranges (handle) </TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_range_incl(MPI_Group group, int n, int ranges[][3], MPI_Group *newgroup) <BR></tt>  
<P> 
 <tt> MPI_GROUP_RANGE_INCL(GROUP, N, RANGES, NEWGROUP, IERROR)<BR> INTEGER GROUP, N, RANGES(3,*), NEWGROUP, IERROR <BR></tt>  
 <tt> MPI::Group MPI::Group::Range_incl(int n, const int ranges[][3]) const <BR></tt>  
  
 If   ranges consist of the triplets  
<p><I> 
(first<SUB>1</SUB> , last<SUB>1</SUB>, stride<SUB>1</SUB>) , ..., (first<SUB>n</SUB>, last<SUB>n</SUB>, stride<SUB>n</SUB>) 
</I><p>  
then  newgroup consists of the sequence of  
processes in  group with ranks  
<P><IMG WIDTH=8 HEIGHT=8 SRC="img59.gif"><P>
  
<P><IMG WIDTH=14 HEIGHT=8 SRC="img60.gif"><P>
  
<P> 
Each computed rank must be a valid  
rank in  group and all computed ranks must be distinct, or else the  
program is erroneous.  
Note that we may have <I>first<SUB>i</SUB> &gt; last<SUB>i</SUB></I>, and <I>stride<SUB>i</SUB></I> may be negative, but  
cannot be zero.  
<P> 
The functionality of this routine is specified to be equivalent to  
expanding the array of ranges to an array of the included ranks and  
passing the resulting array of ranks and other arguments to  
 MPI_GROUP_INCL.  A call to  MPI_GROUP_INCL is  
equivalent to a call to  
 MPI_GROUP_RANGE_INCL with each rank  i  
in  ranks replaced by the triplet <tt> (i,i,1)</tt> in the argument  ranges.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_RANGE_EXCL(group, n, ranges, newgroup)</TD></TR>  
<TR><TD> IN group</TD><TD>  group (handle)</TD></TR>  
<TR><TD> IN n</TD><TD> number of elements in array ranges (integer)</TD></TR>  
<TR><TD> IN ranges</TD><TD> a one-dimensional  
array of integer triplets of the  
form (first rank, last rank, stride), indicating the ranks in  
 group of processes to be excluded  
from the output group  newgroup. </TD></TR>  
<TR><TD> OUT newgroup</TD><TD> new group derived from above, preserving the  
order in  group (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Group_range_excl(MPI_Group group, int n, int ranges[][3], MPI_Group *newgroup) <BR></tt>  
<P> 
 <tt> MPI_GROUP_RANGE_EXCL(GROUP, N, RANGES, NEWGROUP, IERROR)<BR> INTEGER GROUP, N, RANGES(3,*), NEWGROUP, IERROR <BR></tt>  
 <tt> MPI::Group MPI::Group::Range_excl(int n, const int ranges[][3]) const <BR></tt>  
  
 Each computed rank must be a valid  
rank in  group and all computed ranks must be distinct, or else the  
program is erroneous.  
<P> 
The functionality of this routine is specified to be equivalent to  
expanding the array of ranges to an array of the excluded ranks and  
passing the resulting array of ranks and other arguments to  
 MPI_GROUP_EXCL. A call to  MPI_GROUP_EXCL is  
equivalent to a call to  MPI_GROUP_RANGE_EXCL with each rank  
 i in  ranks replaced by the triplet <tt> (i,i,1)</tt> in the argument  
 ranges.  
<P> 
 
<BR> 
<em> Advice to users.</em>  
<P> 
The range operations do not explicitly enumerate ranks, and therefore  
are more scalable if implemented efficiently.  Hence, we recommend  MPI programmers  
to use them whenenever possible, as high-quality implementations will  
take advantage of this fact.  
 (<em> End of advice to users.</em>) <BR> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
The range operations should be implemented, if possible, without  
enumerating the group members,  
in order to obtain better scalability (time and space).  
 (<em> End of advice to implementors.</em>) <BR> 

<P>
<HR>
<A HREF="node124.htm#Node124"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node123.htm#Node123"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node126.htm#Node126"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node123.htm#Node123"> Group Management</a>
<b>Next: </b><A HREF="node126.htm#Node126"> Group Destructors</a>
<b>Previous: </b><A HREF="node124.htm#Node124"> Group Accessors</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
