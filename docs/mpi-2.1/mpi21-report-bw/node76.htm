<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Commit and Free</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node76">75. Commit and Free</a></H2>
<A HREF="node75.htm#Node75"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node67.htm#Node67"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node77.htm#Node77"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node67.htm#Node67"> Derived Datatypes</a>
<b>Next: </b><A HREF="node77.htm#Node77"> Duplicating a Datatype</a>
<b>Previous: </b><A HREF="node75.htm#Node75"> True Extent of Datatypes</a>
<P>
  
<P> 
A datatype object has to be <b> committed</b> before it can be used in a  
communication.  
As an argument in datatype constructors, uncommitted and also  
committed datatypes can be used.  
There is no need to commit basic datatypes. They are ``pre-committed.''  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_COMMIT(datatype)</TD></TR>  
<TR><TD> INOUT datatype</TD><TD>datatype that is committed (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_commit(MPI_Datatype *datatype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_COMMIT(DATATYPE, IERROR)<BR> INTEGER  DATATYPE, IERROR <BR></tt>  
 <tt> void MPI::Datatype::Commit() <BR></tt>  
  
The commit operation commits the datatype, that is, the formal description of  
a communication buffer, not the content of that buffer.  Thus, after a datatype  
has been committed, it can be repeatedly reused to communicate the changing  
content  
of a buffer or, indeed, the content of different buffers, with different  
starting addresses.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
The system may ``compile'' at commit time an internal  
representation for the datatype that facilitates  
communication, e.g.  
change from a compacted representation to a flat representation of the  
datatype, and select the most convenient transfer mechanism.  
 (<em> End of advice to implementors.</em>) <BR> 
  
 MPI_TYPE_COMMIT   
will accept a committed datatype;  
in this case, it is equivalent to a no-op.  
<P> 
  
  
<BR><b> Example</b>   
  
  
The following code fragment gives examples of using  
 MPI_TYPE_COMMIT.  
<BR> 
<pre><tt>INTEGER type1, type2 
CALL MPI_TYPE_CONTIGUOUS(5, MPI_REAL, type1, ierr) 
              ! new type object created 
CALL MPI_TYPE_COMMIT(type1, ierr) 
              ! now type1 can be used for communication 
type2 = type1 
              ! type2 can be used for communication 
              ! (it is a handle to same object as type1) 
CALL MPI_TYPE_VECTOR(3, 5, 4, MPI_REAL, type1, ierr) 
              ! new uncommitted type object created 
CALL MPI_TYPE_COMMIT(type1, ierr) 
              ! now type1 can be used anew for communication 
</tt></pre> 
   
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_FREE(datatype)</TD></TR>  
<TR><TD> INOUT datatype</TD><TD>datatype that is freed (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_free(MPI_Datatype *datatype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_FREE(DATATYPE, IERROR)<BR> INTEGER  DATATYPE, IERROR <BR></tt>  
 <tt> void MPI::Datatype::Free() <BR></tt>  
  
Marks the datatype object associated with  datatype for  
deallocation and sets  datatype to  MPI_DATATYPE_NULL.  
Any communication that is currently using this datatype will complete   
normally.  
Freeing a datatype does not affect any other datatype that was  
built from the freed datatype.  The system behaves as if  
input datatype arguments to derived datatype constructors are passed by value.  
<P> 
 
<BR> 
<em> Advice  
        to implementors.</em>  
<P> 
The implementation may keep a reference count of active communications  
that use the datatype, in order to decide when to free it.  
Also, one may implement constructors of derived datatypes so that they keep  
pointers to their datatype arguments, rather then copying them.  In this  
case, one needs to keep track of active datatype definition references in order  
to know when a datatype object can be freed.  
 (<em> End of advice to implementors.</em>) <BR> 
  

<P>
<HR>
<A HREF="node75.htm#Node75"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node67.htm#Node67"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node77.htm#Node77"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node67.htm#Node67"> Derived Datatypes</a>
<b>Next: </b><A HREF="node77.htm#Node77"> Duplicating a Datatype</a>
<b>Previous: </b><A HREF="node75.htm#Node75"> True Extent of Datatypes</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
