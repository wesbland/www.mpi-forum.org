<HTML>
<HEAD>
<!-- This file was generated by tohtml from chap-datatypes/datatypes.tex -->
<!-- with the command
tohtml -default -basedef ../mpi2defs-bw.txt -numbers -indexname myindex -dosnl -htables -quietlatex -allgif -endpage mpi2-forum-tail.htm -Wnoredef -o mpi21-report-bw.tex mpi-report.tex 
-->
<TITLE>Datatype Constructors</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<HR><H2><A NAME="Node69">68. Datatype Constructors</a></H2>
<A HREF="node68.htm#Node68"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node67.htm#Node67"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node70.htm#Node70"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node67.htm#Node67"> Derived Datatypes</a>
<b>Next: </b><A HREF="node70.htm#Node70"> Subarray Datatype Constructor</a>
<b>Previous: </b><A HREF="node68.htm#Node68"> Type Constructors with Explicit Addresses</a>
<P>
  
<P> 
<P> 
Contiguous The simplest datatype constructor is  
 MPI_TYPE_CONTIGUOUS which  
allows replication of a datatype into contiguous locations.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CONTIGUOUS(count, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>replication count (nonnegative integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
   
 <tt> int MPI_Type_contiguous(int count, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CONTIGUOUS(COUNT, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER  COUNT, OLDTYPE, NEWTYPE, IERROR <BR></tt>  
 <tt> MPI::Datatype MPI::Datatype::Create_contiguous(int count) const <BR></tt>  
  
<P> 
 newtype is the datatype obtained by concatenating  
 count copies of  
 oldtype.   Concatenation is defined using <em> extent</em> as the size of  
the concatenated copies.  
<P> 
<BR><b> Example</b>   
  
  
  
Let  oldtype have type map  
<I> 
{ ( double, 0), ( char, 8) } , 
</I>  
with extent 16,  
and let <IMG WIDTH=45 HEIGHT=7 SRC="img8.gif">
.  The type map of  
the datatype returned by  newtype is  
<I> 
{ ( double, 0), ( char, 8), ( double, 16), ( 
char, 24), ( double, 32), ( char, 40) } ; 
</I>  
i.e., alternating  double and  char elements, with displacements  
<I>0, 8, 16, 24, 32, 40</I>.  
   
<P> 
  
In general,  
assume that the type map of  oldtype is  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <I>ex</I>.  
Then  newtype has a type map with <I> count &#183; n</I> entries  
defined by:  
<I> 
{ (type<SUB>0</SUB>, disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>), (type<SUB>0</SUB>, disp<SUB>0</SUB> 
+ex), ... ,(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> + ex) , 
</I>  
<I> 
...,(type<SUB>0</SUB>, disp<SUB>0</SUB> +ex &#183;( count-1) ), ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ex &#183; ( count-1)) } . 
</I>  
  
<P> 
<P> 
Vector The function  
 MPI_TYPE_VECTOR is a more general constructor that  
allows replication of a datatype  
into locations that consist of equally spaced blocks.  Each block  
is obtained by concatenating the same number of copies of the old datatype.  
The spacing between blocks is a multiple of the extent of the old datatype.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_VECTOR( count, blocklength, stride, oldtype,  
newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks (nonnegative integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>number of elements in each block  
(nonnegative integer)</TD></TR>  
<TR><TD> IN stride</TD><TD>number of elements between start of each block (integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_vector(int count, int blocklength, int stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_VECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER  COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR <BR></tt>  
 <tt> MPI::Datatype MPI::Datatype::Create_vector(int count, int blocklength, int stride) const <BR></tt>  
  
<P> 
<BR><b> Example</b>   
  
  
  
Assume, again, that  oldtype has type map  
<I> 
{ ( double, 0), ( char, 8) } , 
</I>  
with extent 16.  
A call to  MPI_TYPE_VECTOR( 2, 3, 4, oldtype, newtype) will  
create the datatype with type map,  
<I> 
{ 
( double, 0), ( char, 8), ( double, 16), ( char, 
24), ( double, 32), ( char, 40), 
</I>  
<I> 
( double, 64), ( char, 72), ( double, 80), ( char, 
88), ( double, 96), ( char, 104) 
} . 
</I>  
That is, two blocks with three copies each of the old  
type, with a stride of 4 elements (<I>4 &#183; 16</I> bytes) between the blocks.  
   
<P> 
<BR><b> Example</b>   
  
  
  
A call to  MPI_TYPE_VECTOR(3, 1, -2, oldtype, newtype) will create  
the datatype,  
<I> 
{ 
( double, 0), ( char, 8), ( double, -32), ( char, 
-24), ( double, -64), ( char, -56) 
} . 
</I>  
   
<P> 
  
In general, assume that  oldtype has type map,  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <I>ex</I>.  Let  bl be the  blocklength.  
The newly created  datatype has a type map with  
<I> count &#183;  bl &#183; n</I><P> 
entries:  
<I> 
{ 
(type<SUB>0</SUB>, disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB>), 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> + ex) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ex ), ..., 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> + ( bl -1) &#183; ex 
) , ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ( bl -1) &#183; ex ) , 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> +  stride &#183; ex ) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> +  stride &#183; ex ), ... , 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> + ( stride +  bl -1) &#183; ex ) , ... , 
(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> + ( stride +  bl -1) &#183; 
ex ) , ...., 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> +  stride &#183; ( count-1) &#183; ex ) , ... , 
</I>  
<I> 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> +  stride &#183; ( count -1) &#183; 
ex ) 
, ... , 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> + ( stride &#183; ( count -1) 
+  bl -1) &#183; ex ) , ... , 
</I>  
<I> 
(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> + ( stride &#183; ( count -1) 
+  bl -1) &#183; ex ) 
} . 
</I>  
  
<P> 
A call to  MPI_TYPE_CONTIGUOUS(count, oldtype, newtype) is  
equivalent to a call to  
 MPI_TYPE_VECTOR(count, 1, 1, oldtype, newtype), or to a call to  
 MPI_TYPE_VECTOR(1, count, n, oldtype, newtype),  n arbitrary.  
<P> 
<P> 
Hvector The function   
 MPI_TYPE_CREATE_HVECTOR   
is identical to  
 MPI_TYPE_VECTOR, except that  stride is given in bytes,  
rather than in elements.  The use for both types of vector  
constructors is illustrated in Section <a href="node81.htm#Node81">Examples 
</a>.  
( H stands for ``heterogeneous'').  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HVECTOR( count, blocklength, stride,  
oldtype, newtype)</TD></TR> <TR><TD> IN count</TD><TD>number of blocks (nonnegative  
integer)</TD></TR> <TR><TD> IN blocklength</TD><TD>number of elements in each block  
(nonnegative integer)</TD></TR> <TR><TD> IN stride</TD><TD>number of bytes between start  
of each block (integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_hvector(int count, int blocklength, MPI_Aint stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_HVECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, BLOCKLENGTH, OLDTYPE, NEWTYPE, IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) STRIDE <BR></tt>  
  
 <tt> MPI::Datatype MPI::Datatype::Create_hvector(int count, int blocklength, MPI::Aint stride) const <BR></tt>  
  
This function replaces  MPI_TYPE_HVECTOR, whose use is deprecated. See also Chapter <a href="node321.htm#Node321">Deprecated Functions 
</a>.   
  
<P> 
  
Assume that  oldtype has type map,  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <I>ex</I>.  Let  bl be the  blocklength.  
The newly created  datatype has a type map with  
<I> count &#183;  bl &#183; n</I><P> 
entries:  
<I> 
{ 
(type<SUB>0</SUB>, disp<SUB>0</SUB>), ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB>), 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> + ex) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ex ), ..., 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> + ( bl -1) &#183; ex 
) , ... , (type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> + ( bl -1) &#183; ex ) , 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> +  stride  ) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> +  stride ) , ... , 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> +  stride + (  bl -1) &#183; ex 
) , ... , 
</I>  
<I> 
(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> +  stride + ( bl -1) &#183; 
ex ) , 
...., 
</I>  
<I> 
(type<SUB>0</SUB> ,disp<SUB>0</SUB> +  stride &#183; ( count-1) ) , ... , 
(type<SUB>n-1</SUB> , disp<SUB>n-1</SUB> +  stride &#183; ( count -1)  ) 
, ... , 
</I>  
<I> 
(type<SUB>0</SUB> , disp<SUB>0</SUB> +  stride &#183; ( count -1) 
+ ( bl -1) &#183; ex ) , ... , 
</I>  
<I> 
(type<SUB>n-1</SUB>, disp<SUB>n-1</SUB> +  stride &#183; ( count -1) 
+ ( bl -1) &#183; ex ) 
} . 
</I>  
  
<P> 
<P> 
Indexed The function  
 MPI_TYPE_INDEXED allows  
replication of an old datatype into a sequence of blocks (each block is  
a concatenation of the old datatype), where  
each block can contain a different number of copies and have a different  
displacement.  All block displacements are multiples of the old type  
extent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_INDEXED( count, array_of_blocklengths,  
array_of_displacements, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks -- also number of entries in  
<BR> array_of_displacements and  
 array_of_blocklengths (nonnegative integer)</TD></TR>  
<TR><TD> IN array_of_blocklengths</TD><TD>number of elements per block  
(array of nonnegative integers)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>displacement for each block,  
in multiples of  oldtype extent (array of integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_indexed(int count, int *array_of_blocklengths, int *array_of_displacements, MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_INDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_DISPLACEMENTS(*), OLDTYPE, NEWTYPE, IERROR <BR></tt>  
 <tt> MPI::Datatype MPI::Datatype::Create_indexed(int count, const int array_of_blocklengths[], const int array_of_displacements[]) const <BR></tt>  
  
<P> 
<BR><b> Example</b>   
  
  
  
<P> 
Let  oldtype have type map  
<I> 
{ ( double, 0), ( char, 8) } , 
</I>  
with extent 16.  
Let   B = (3, 1) and let  D = (4, 0).  A call to  
 MPI_TYPE_INDEXED(2, B, D, oldtype, newtype) returns a datatype with  
type map,  
<I> 
{ 
( double, 64), ( char, 72), ( double, 80), ( char, 
88), ( double, 96), ( char, 104), 
</I>  
<I> 
( double, 0), ( char, 8) 
} . 
</I>  
That is, three copies of the old type starting at displacement  
64, and one copy starting at displacement 0.  
   
<P> 
  
In general,  
assume that  oldtype has type map,  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <em> ex</em>.  
Let  B be the  array_of_blocklength argument and  
 D be the  
<BR>  
 array_of_displacements argument. The newly created datatype  
has <IMG WIDTH=73 HEIGHT=13 SRC="img9.gif">
 entries:  
<IMG WIDTH=293 HEIGHT=11 SRC="img10.gif">
  
<IMG WIDTH=407 HEIGHT=11 SRC="img11.gif">
  
<IMG WIDTH=366 HEIGHT=11 SRC="img12.gif">
  
<IMG WIDTH=268 HEIGHT=11 SRC="img13.gif">
  
<IMG WIDTH=282 HEIGHT=12 SRC="img14.gif">
  
  
<P> 
A call to  MPI_TYPE_VECTOR(count, blocklength, stride, oldtype,  
newtype) is equivalent to a call to  
 MPI_TYPE_INDEXED(count, B, D, oldtype, newtype) where  
<IMG WIDTH=168 HEIGHT=11 SRC="img15.gif">
  
and  
<IMG WIDTH=181 HEIGHT=11 SRC="img16.gif">
  
<P> 
<P> 
Hindexed The function   
 MPI_TYPE_CREATE_HINDEXED   
is identical to  
 MPI_TYPE_INDEXED, except that block displacements in  
 array_of_displacements are specified in  
bytes, rather than in multiples of the  oldtype extent.  
  
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HINDEXED( count,  
array_of_blocklengths, array_of_displacements, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks --- also number of entries in  
<BR> array_of_displacements and  array_of_blocklengths   
(nonnegative integer)</TD></TR>  
<TR><TD> IN array_of_blocklengths</TD><TD>number of elements in each block  
(array of nonnegative integers)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>byte displacement of each block  
(array of integer)</TD></TR> <TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_hindexed(int count, int array_of_blocklengths[], MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_HINDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), OLDTYPE, NEWTYPE, IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*) <BR></tt>  
<P> 
 <tt> MPI::Datatype MPI::Datatype::Create_hindexed(int count, const int array_of_blocklengths[], const MPI::Aint array_of_displacements[]) const <BR></tt>  
  
This function replaces  MPI_TYPE_HINDEXED, whose use is deprecated. See also Chapter <a href="node321.htm#Node321">Deprecated Functions 
</a>.   
  
  
Assume that  oldtype has type map,  
<I> 
{ (type<SUB>0</SUB>,disp<SUB>0</SUB>), ..., (type<SUB>n-1</SUB>, disp<SUB>n-1</SUB>) } , 
</I>  
with extent <I>ex</I>.  
Let  B be the  array_of_blocklength argument and  
 D be the  
 array_of_displacements argument. The newly created datatype  
has a type map with  
<IMG WIDTH=73 HEIGHT=13 SRC="img17.gif">
 entries:  
<IMG WIDTH=254 HEIGHT=11 SRC="img18.gif">
  
<IMG WIDTH=190 HEIGHT=11 SRC="img19.gif">
  
<IMG WIDTH=214 HEIGHT=11 SRC="img20.gif">
  
<IMG WIDTH=327 HEIGHT=11 SRC="img21.gif">
  
<IMG WIDTH=268 HEIGHT=11 SRC="img22.gif">
  
<IMG WIDTH=282 HEIGHT=12 SRC="img23.gif">
  
  
  
<P> 
Indexed_block   
<P> 
This function is the same as  MPI_TYPE_INDEXED except that the  
blocklength is the same for all blocks.  
There are many codes using indirect addressing arising from  
unstructured grids where the blocksize is always 1 (gather/scatter).  The  
following convenience function allows for constant blocksize and arbitrary  
displacements.  
<P> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_INDEXED_BLOCK(count, blocklength, array_of_displacements, oldtype, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>length of array of displacements (non-negative   
        integer)</TD></TR>  
<TR><TD> IN blocklength</TD><TD>size of block (non-negative   
        integer)</TD></TR>  
<TR><TD> IN array_of_displacements</TD><TD>array of displacements (array of integer)</TD></TR>  
<TR><TD> IN oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD> OUT newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_indexed_block(int count, int blocklength, int array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_INDEXED_BLOCK(COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <BR> INTEGER COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS(*), OLDTYPE, NEWTYPE, IERROR <BR></tt>  
<P> 
  
<P> 
  
<P> 
  
 <tt> MPI::Datatype MPI::Datatype::Create_indexed_block(int count, int blocklength, const int array_of_displacements[]) const <BR></tt>  
  
<P> 
  
  
<P> 
<P> 
Struct  MPI_TYPE_STRUCT is the most general type constructor.  
It further generalizes  
 MPI_TYPE_CREATE_HINDEXED   
in that it allows each block to consist of replications of  
different datatypes.  
  
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_STRUCT(count, array_of_blocklengths,  
array_of_displacements,  array_of_types, newtype)</TD></TR>  
<TR><TD> IN count</TD><TD>number of blocks   
(nonnegative integer)  
--- also number of entries  
in arrays  array_of_types,  array_of_displacements and  
 array_of_blocklengths</TD></TR>  
<TR><TD> IN array_of_blocklength</TD><TD>number of elements in each block  
(array of nonnegative integer)</TD></TR>   
<TR><TD> IN array_of_displacements</TD><TD>byte  
displacement of each block (array of integer)</TD></TR>  
<TR><TD> IN array_of_types</TD><TD>type of elements in each block (array of  
handles to datatype objects)</TD></TR> <TR><TD> OUT newtype</TD><TD>new datatype  
(handle)</TD></TR>  
</TABLE>  
<P> 
 <tt> int MPI_Type_create_struct(int count, int array_of_blocklengths[], MPI_Aint array_of_displacements[], MPI_Datatype array_of_types[], MPI_Datatype *newtype) <BR></tt>  
<P> 
 <tt> MPI_TYPE_CREATE_STRUCT(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, ARRAY_OF_TYPES, NEWTYPE, IERROR)<BR> INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_TYPES(*), NEWTYPE, IERROR<BR>INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*) <BR></tt>  
<P> 
  
 <tt> static MPI::Datatype MPI::Datatype::Create_struct(int count, const int array_of_blocklengths[], const MPI::Aint array_of_displacements[], const MPI::Datatype array_of_types[]) <BR></tt>  
  
  
This function replaces  MPI_TYPE_STRUCT, whose use is deprecated. See also Chapter <a href="node321.htm#Node321">Deprecated Functions 
</a>.   
  
<BR><b> Example</b>   
  
  
  
  
Let  type1 have type map,  
<p><I> 
{ ( double, 0), ( char, 8) } , 
</I><p>  
with extent 16.  
Let  B = (2, 1, 3),  D = (0, 16, 26),  
and  T = (MPI_FLOAT, type1, MPI_CHAR).  Then a call to  
 MPI_TYPE_STRUCT(3, B, D, T, newtype) returns  
a datatype with type map,  
<I> 
{ 
( float, 0), ( float, 4), ( double, 16), ( char, 
24), ( char, 26), ( char, 27), ( char, 28) 
} . 
</I>  
That is, two copies of  MPI_FLOAT starting at 0, followed by  
one copy of  type1 starting at 16, followed by three copies of  
 MPI_CHAR, starting at 26.  
(We assume that a float occupies four bytes.)  
   
<P> 
  
In general,  
let  T be the  array_of_types argument, where  T[i]  
is a handle to,  
<I> 
typemap<SUB>i</SUB> = { (type<SUB>0</SUB><SUP>i</SUP> , disp<SUB>0</SUB><SUP>i</SUP> ) , ... , (type<SUB>n<SUB>i</SUB>-1</SUB><SUP>i</SUP> , 
disp<SUB>n<SUB>i</SUB>-1</SUB><SUP>i</SUP> ) } , 
</I>  
with extent <I>ex<SUB>i</SUB></I>.  
Let  
 B be the  array_of_blocklength argument and  D be  
the  array_of_displacements argument.Let  c be the  
 count argument.  
Then the newly created datatype has a type map with  
<IMG WIDTH=60 HEIGHT=13 SRC="img24.gif">
<P> 
entries:  
<IMG WIDTH=241 HEIGHT=13 SRC="img25.gif">
  
<IMG WIDTH=403 HEIGHT=13 SRC="img26.gif">
  
<IMG WIDTH=332 HEIGHT=14 SRC="img27.gif">
  
<IMG WIDTH=262 HEIGHT=13 SRC="img28.gif">
  
<IMG WIDTH=281 HEIGHT=14 SRC="img29.gif">
  
  
<P> 
A call to   
 MPI_TYPE_CREATE_HINDEXED(count, B, D, oldtype, newtype)  
is equivalent to a call to  
 MPI_TYPE_CREATE_STRUCT(count, B, D, T, newtype),   
where each entry of  T is equal to  oldtype.  
  
  

<P>
<HR>
<A HREF="node68.htm#Node68"><IMG WIDTH=16 HEIGHT=16 SRC="previous.gif"></A><A HREF="node67.htm#Node67"><IMG WIDTH=16 HEIGHT=16 SRC="up.gif"></A><A HREF="node70.htm#Node70"><IMG WIDTH=16 HEIGHT=16 SRC="next.gif"></A><BR>
<b>Up: </b><A HREF="node67.htm#Node67"> Derived Datatypes</a>
<b>Next: </b><A HREF="node70.htm#Node70"> Subarray Datatype Constructor</a>
<b>Previous: </b><A HREF="node68.htm#Node68"> Type Constructors with Explicit Addresses</a>
<P>
<HR>
Return to <A HREF="node428.htm">MPI-2.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>MPI-2.0 of July 1, 2008<BR>
HTML Generated on July 6, 2008
</FONT>
</BODY>
</HTML>
